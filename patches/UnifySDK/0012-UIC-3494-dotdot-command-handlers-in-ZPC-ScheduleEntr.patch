From 0bf584e7c1a862d0cace11019900f0b29c9d9bdb Mon Sep 17 00:00:00 2001
From: Thirupathi S <Thirupathi.S@silabs.com>
Date: Wed, 25 Sep 2024 13:15:55 +0000
Subject: [PATCH] UIC-3494:dotdot command handlers in ZPC ScheduleEntryLock CC

Merge in UIC/uic from feature/UIC-3494-dotdot-command-handlers-in-ZPC-ScheduleEntryLock-CC to feature/UIC-3271-Schedule-Entry-Lock-CC
---
 .../cluster-types/cluster-type-attributes.ts  |  245 ++
 .../src/cluster-types/cluster-types.ts        |    1 +
 .../src/cluster-types/supported-clusters.js   |    1 +
 .../dev_ui/dev_gui/zap/addon-helper.js        |    3 +-
 .../dotdot-xml/Unify_ScheduleEntryLock.xml    |   47 +-
 components/uic_dotdot/dotdot-xml/library.xml  |    5 +-
 .../zap-generated/include/dotdot_mqtt.h       |  629 +++++
 .../include/dotdot_mqtt_attributes.h          |  113 +
 .../include/dotdot_mqtt_generated_commands.h  |   85 +
 .../include/dotdot_mqtt_group_commands.h      |   65 +
 .../include/dotdot_mqtt_send_commands.h       |  117 +
 ...dotdot_mqtt_supported_generated_commands.h |   31 +
 .../zap-generated/src/dotdot_mqtt.cpp         | 2017 ++++++++++++++++-
 .../zap-generated/src/dotdot_mqtt.hpp         |   85 +
 .../src/dotdot_mqtt_attributes.cpp            |  707 ++++++
 .../src/dotdot_mqtt_command_helpers.cpp       |  462 ++++
 .../src/dotdot_mqtt_command_helpers.hpp       |  142 ++
 .../src/dotdot_mqtt_generated_commands.cpp    |  228 ++
 .../src/dotdot_mqtt_group_commands.cpp        |  528 +++++
 .../zap-generated/src/dotdot_mqtt_helpers.cpp |  102 +
 .../src/dotdot_mqtt_send_commands.cpp         |  222 ++
 ...tdot_mqtt_supported_generated_commands.cpp |   52 +
 .../test/dotdot_mqtt_test.include             |   98 +
 .../include/dotdot_attributes.uam             |   10 +
 .../include/dotdot_attributes_camel_case.uam  |   10 +
 .../unify_dotdot_attribute_store_helpers.h    |  876 +++++++
 .../unify_dotdot_defined_attribute_types.h    |    9 +
 ...ot_attribute_store_attribute_publisher.cpp |  481 ++++
 ..._force_read_attributes_command_callbacks.c |   67 +
 .../unify_dotdot_attribute_store_helpers.cpp  |  955 ++++++++
 ...fy_dotdot_attribute_store_registration.cpp |  192 ++
 ...store_write_attributes_command_callbacks.c |   65 +
 .../test/unify_dotdot_attribute_store_test.c  |  320 +++
 .../test/unify_dotdot_attribute_store_test.h  |   13 +
 34 files changed, 8900 insertions(+), 83 deletions(-)

diff --git a/applications/dev_ui/dev_gui/zap-generated/src/cluster-types/cluster-type-attributes.ts b/applications/dev_ui/dev_gui/zap-generated/src/cluster-types/cluster-type-attributes.ts
index 2fa7a4c728..c8f421a395 100644
--- a/applications/dev_ui/dev_gui/zap-generated/src/cluster-types/cluster-type-attributes.ts
+++ b/applications/dev_ui/dev_gui/zap-generated/src/cluster-types/cluster-type-attributes.ts
@@ -15352,4 +15352,249 @@ export let ClusterTypeAttrs: any = {
         ] 
       }
     },
+    UnifyScheduleEntryLock: {
+      server:{
+        attributes: [
+            {                
+              id: 1,
+              name: "SlotsWeekDay",
+              type: "number",            
+              max: 255,
+              min: 0,
+              required: true,
+              reportRequired: false,
+              sceneRequired: false,
+              writable: true,
+              isArray: false,
+            },
+            {                
+              id: 2,
+              name: "SlotsYearDay",
+              type: "number",            
+              max: 255,
+              min: 0,
+              required: true,
+              reportRequired: false,
+              sceneRequired: false,
+              writable: true,
+              isArray: false,
+            },
+            {                
+              id: 3,
+              name: "SignTZO",
+              type: "number",            
+              required: true,
+              reportRequired: false,
+              sceneRequired: false,
+              writable: true,
+              isArray: false,
+            },
+            {                
+              id: 4,
+              name: "HourTZO",
+              type: "number",            
+              required: true,
+              reportRequired: false,
+              sceneRequired: false,
+              writable: true,
+              isArray: false,
+            },
+            {                
+              id: 5,
+              name: "MinuteTZO",
+              type: "number",            
+              required: true,
+              reportRequired: false,
+              sceneRequired: false,
+              writable: true,
+              isArray: false,
+            },
+            {                
+              id: 6,
+              name: "DSTOffsetSign",
+              type: "number",            
+              required: true,
+              reportRequired: false,
+              sceneRequired: false,
+              writable: true,
+              isArray: false,
+            },
+            {                
+              id: 7,
+              name: "DSTOffsetMinute",
+              type: "number",            
+              required: true,
+              reportRequired: false,
+              sceneRequired: false,
+              writable: true,
+              isArray: false,
+            },
+            {                
+              id: 8,
+              name: "NumberOfSlotsDailyRepeating",
+              type: "number",            
+              max: 255,
+              min: 0,
+              required: true,
+              reportRequired: false,
+              sceneRequired: false,
+              writable: true,
+              isArray: false,
+            }
+        ],
+        commands: [
+            {
+              id: 1,
+              name: "ScheduleEntryLockWeekDayReport",
+              required: true,
+              fields: [
+                  {
+                    name: "UserIdentifier",
+                    type: "number",
+                    isArray: false,
+                  },
+                  {
+                    name: "ScheduleSlotID",
+                    type: "number",
+                    isArray: false,
+                  },
+                  {
+                    name: "DayOfWeek",
+                    type: "number",
+                    isArray: false,
+                  },
+                  {
+                    name: "StartHour",
+                    type: "number",
+                    isArray: false,
+                  },
+                  {
+                    name: "StartMinute",
+                    type: "number",
+                    isArray: false,
+                  },
+                  {
+                    name: "StopHour",
+                    type: "number",
+                    isArray: false,
+                  },
+                  {
+                    name: "StopMinute",
+                    type: "number",
+                    isArray: false,
+                  }
+              ]              
+            },
+            {
+              id: 2,
+              name: "ScheduleEntryLockYearDayReport",
+              required: true,
+              fields: [
+                  {
+                    name: "SetAction",
+                    type: "number",
+                    isArray: false,
+                  },
+                  {
+                    name: "UserIdentifier",
+                    type: "number",
+                    isArray: false,
+                  },
+                  {
+                    name: "ScheduleSlotID",
+                    type: "number",
+                    isArray: false,
+                  },
+                  {
+                    name: "StartYear",
+                    type: "number",
+                    isArray: false,
+                  },
+                  {
+                    name: "StartDay",
+                    type: "number",
+                    isArray: false,
+                  },
+                  {
+                    name: "StartHour",
+                    type: "number",
+                    isArray: false,
+                  },
+                  {
+                    name: "StartMinute",
+                    type: "number",
+                    isArray: false,
+                  },
+                  {
+                    name: "StopYear",
+                    type: "number",
+                    isArray: false,
+                  },
+                  {
+                    name: "StopDay",
+                    type: "number",
+                    isArray: false,
+                  },
+                  {
+                    name: "StopHour",
+                    type: "number",
+                    isArray: false,
+                  },
+                  {
+                    name: "StopMinute",
+                    type: "number",
+                    isArray: false,
+                  }
+              ]              
+            },
+            {
+              id: 3,
+              name: "ScheduleEntryLockDailyRepeatingReport",
+              required: true,
+              fields: [
+                  {
+                    name: "SetAction",
+                    type: "number",
+                    isArray: false,
+                  },
+                  {
+                    name: "UserIdentifier",
+                    type: "number",
+                    isArray: false,
+                  },
+                  {
+                    name: "ScheduleSlotID",
+                    type: "number",
+                    isArray: false,
+                  },
+                  {
+                    name: "WeekDayBitmask",
+                    type: "number",
+                    isArray: false,
+                  },
+                  {
+                    name: "StartHour",
+                    type: "number",
+                    isArray: false,
+                  },
+                  {
+                    name: "StartMinute",
+                    type: "number",
+                    isArray: false,
+                  },
+                  {
+                    name: "DurationHour",
+                    type: "number",
+                    isArray: false,
+                  },
+                  {
+                    name: "DurationMinute",
+                    type: "number",
+                    isArray: false,
+                  }
+              ]              
+            }
+        ] 
+      }
+    },
 }
diff --git a/applications/dev_ui/dev_gui/zap-generated/src/cluster-types/cluster-types.ts b/applications/dev_ui/dev_gui/zap-generated/src/cluster-types/cluster-types.ts
index 192c0f68f9..b420ab28f5 100644
--- a/applications/dev_ui/dev_gui/zap-generated/src/cluster-types/cluster-types.ts
+++ b/applications/dev_ui/dev_gui/zap-generated/src/cluster-types/cluster-types.ts
@@ -29,6 +29,7 @@ export enum ClusterTypes {
 	SoilMoisture = "SoilMoisture", 
 	TemperatureMeasurement = "TemperatureMeasurement", 
 	Thermostat = "Thermostat", 
+	UnifyScheduleEntryLock = "UnifyScheduleEntryLock", 
 	WindSpeedMeasurement = "WindSpeedMeasurement", 
 	WindowCovering = "WindowCovering"
 }
diff --git a/applications/dev_ui/dev_gui/zap-generated/src/cluster-types/supported-clusters.js b/applications/dev_ui/dev_gui/zap-generated/src/cluster-types/supported-clusters.js
index e19a8e938b..3fdf6d4432 100644
--- a/applications/dev_ui/dev_gui/zap-generated/src/cluster-types/supported-clusters.js
+++ b/applications/dev_ui/dev_gui/zap-generated/src/cluster-types/supported-clusters.js
@@ -32,6 +32,7 @@ const SupportedClusters = {
 	SoilMoisture: "SoilMoisture", 
 	TemperatureMeasurement: "TemperatureMeasurement", 
 	Thermostat: "Thermostat", 
+	UnifyScheduleEntryLock: "UnifyScheduleEntryLock", 
 	WindSpeedMeasurement: "WindSpeedMeasurement", 
 	WindowCovering: "WindowCovering"
 }
diff --git a/applications/dev_ui/dev_gui/zap/addon-helper.js b/applications/dev_ui/dev_gui/zap/addon-helper.js
index aa013c9f1a..1af98954be 100644
--- a/applications/dev_ui/dev_gui/zap/addon-helper.js
+++ b/applications/dev_ui/dev_gui/zap/addon-helper.js
@@ -31,6 +31,7 @@ const supportedClusters = [
     "SystemMetrics",
     "TemperatureMeasurement",
     "Thermostat",
+    "UnifyScheduleEntryLock",
     "WindSpeedMeasurement",
     "WindowCovering"
 ];
@@ -272,4 +273,4 @@ exports.getClusterName = getClusterName
 exports.isStruct = isStruct
 exports.isArray = isArray
 exports.getEnum = getEnum
-exports.getBitmap = getBitmap
\ No newline at end of file
+exports.getBitmap = getBitmap
diff --git a/components/uic_dotdot/dotdot-xml/Unify_ScheduleEntryLock.xml b/components/uic_dotdot/dotdot-xml/Unify_ScheduleEntryLock.xml
index 8d37540615..8b9f0685d6 100644
--- a/components/uic_dotdot/dotdot-xml/Unify_ScheduleEntryLock.xml
+++ b/components/uic_dotdot/dotdot-xml/Unify_ScheduleEntryLock.xml
@@ -8,32 +8,29 @@
 <classification role="application" picsCode="USEL"/>
 
 <server>
-    <attributes>
-      <attribute id="0001" name="SlotsWeekDay" min="0" max="255" required="true" writable="true" type="uint8"/>
-      <attribute id="0002" name="SlotsYearDay" min="0" max="255" required="true" writable="true" type="uint8"/>
-      <attribute id="0003" name="SignTZO" required="true" writable="true" type="uint8"/>
-      <attribute id="0004" name="HourTZO" required="true" writable="true" type="uint8"/>
-      <attribute id="0005" name="MinuteTZO" required="true" writable="true" type="uint8"/>
-      <attribute id="0006" name="DSTOffsetSign" required="true" writable="true" type="uint8"/>
-      <attribute id="0007" name="DSTOffsetMinute" required="true" writable="true" type="uint8"/>
-      <attribute id="0008" name="NumberOfSlotsDailyRepeating" min="0" max="255" writable="true" required="true" type="uint8"/>
-    </attributes>
-</server>
-
-<server>
+  <attributes>
+    <attribute id="0001" name="SlotsWeekDay" min="0" max="255" required="true" writable="true" type="uint8"/>
+    <attribute id="0002" name="SlotsYearDay" min="0" max="255" required="true" writable="true" type="uint8"/>
+    <attribute id="0003" name="SignTZO" required="true" writable="true" type="uint8"/>
+    <attribute id="0004" name="HourTZO" required="true" writable="true" type="uint8"/>
+    <attribute id="0005" name="MinuteTZO" required="true" writable="true" type="uint8"/>
+    <attribute id="0006" name="DSTOffsetSign" required="true" writable="true" type="uint8"/>
+    <attribute id="0007" name="DSTOffsetMinute" required="true" writable="true" type="uint8"/>
+    <attribute id="0008" name="NumberOfSlotsDailyRepeating" min="0" max="255" writable="true" required="true" type="uint8"/>
+  </attributes>
   <commands>
-    <command id="01" name="ScheduleEntryLockEnableSet" required="true">
+    <command id="01" name="EnableSet" required="true">
       <fields>
         <field name="UserIdentifier" type="uint8" />
         <field name="Enabled" type="uint8" />
       </fields>
     </command>
-    <command id="02" name="ScheduleEntryLockEnableAllSet" required="true">
+    <command id="02" name="EnableAllSet" required="true">
       <fields>
         <field name="Enabled" type="uint8" />
       </fields>
     </command>
-    <command id="03" name="ScheduleEntryLockWeekDaySet" required="true">
+    <command id="03" name="WeekDaySet" required="true">
       <fields>
         <field name="SetAction" type="uint8" />
         <field name="UserIdentifier" type="uint8" />
@@ -65,13 +62,13 @@
           </restriction>
       </fields>
     </command>
-    <command id="04" name="ScheduleEntryLockWeekDayGet" required="true">
+    <command id="04" name="WeekDayGet" required="true">
       <fields>
         <field name="UserIdentifier" type="uint8" />
         <field name="ScheduleSlotID" type="uint8" />
       </fields>
     </command>
-    <command id="05" name="ScheduleEntryLockYearDaySet" required="true">
+    <command id="05" name="YearDaySet" required="true">
       <fields>
         <field name="SetAction" type="uint8" />
         <field name="UserIdentifier" type="uint8" />
@@ -118,13 +115,13 @@
           </restriction>
       </fields>
     </command>
-    <command id="06" name="ScheduleEntryLockYearDayGet" required="true">
+    <command id="06" name="YearDayGet" required="true">
       <fields>
         <field name="UserIdentifier" type="uint8" />
         <field name="ScheduleSlotID" type="uint8" />
       </fields>
     </command>
-    <command id="07" name="ScheduleEntryLockDailyRepeatingSet" required="true">
+    <command id="07" name="DailyRepeatingSet" required="true">
       <fields>
         <field name="SetAction" type="uint8" />
         <field name="UserIdentifier" type="uint8" />
@@ -156,7 +153,7 @@
           </restriction>
       </fields>
     </command>
-    <command id="08" name="ScheduleEntryDailyRepeatingGet" required="true">
+    <command id="08" name="DailyRepeatingGet" required="true">
       <fields>
         <field name="UserIdentifier" type="uint8" />
         <field name="ScheduleSlotID" type="uint8" />
@@ -167,7 +164,7 @@
 
 <client>
   <commands>
-      <command id="01" name="ScheduleEntryLockWeekDayReport" required="true">
+      <command id="01" name="WeekDayReport" required="true">
       <fields>
         <field name="UserIdentifier" type="uint8" />
         <field name="ScheduleSlotID" type="uint8" />
@@ -198,9 +195,8 @@
           </restriction>
       </fields>
     </command>
-    <command id="02" name="ScheduleEntryLockYearDayReport" required="true">
+    <command id="02" name="YearDayReport" required="true">
       <fields>
-        <field name="SetAction" type="uint8"/>
         <field name="UserIdentifier" type="uint8"/>
         <field name="ScheduleSlotID" type="uint8"/>
         <field name="StartYear" type="uint8" />
@@ -245,9 +241,8 @@
           </restriction>
       </fields>
     </command>
-    <command id="03" name="ScheduleEntryLockDailyRepeatingReport" required="true">
+    <command id="03" name="DailyRepeatingReport" required="true">
       <fields>
-        <field name="SetAction" type="uint8"/>
         <field name="UserIdentifier" type="uint8" />
         <field name="ScheduleSlotID" type="uint8" />
         <field name="WeekDayBitmask" type="uint8" />
diff --git a/components/uic_dotdot/dotdot-xml/library.xml b/components/uic_dotdot/dotdot-xml/library.xml
index deec70c822..2fdb5c5778 100644
--- a/components/uic_dotdot/dotdot-xml/library.xml
+++ b/components/uic_dotdot/dotdot-xml/library.xml
@@ -208,7 +208,7 @@ applicable to this document can be found in the LICENSE.md file.
   <!-- Collections -->
   <type:type id="50" short="set" name="Set" discrete="true" />
   <type:type id="51" short="bag" name="Bag" discrete="true" />
-  
+
   <!-- Time -->
   <type:type id="e0" short="ToD" name="Time of day">
     <restriction>
@@ -502,4 +502,5 @@ applicable to this document can be found in the LICENSE.md file.
   <xi:include href="Unify_Thermostat.xml" parse="xml"/>
   <xi:include href="Unify_FanControl.xml" parse="xml"/>
   <xi:include href="Unify_MultilevelSensor.xml" parse="xml"/>
-</zcl:library>
\ No newline at end of file
+  <xi:include href="Unify_ScheduleEntryLock.xml" parse="xml"/>  
+</zcl:library>
diff --git a/components/uic_dotdot_mqtt/zap-generated/include/dotdot_mqtt.h b/components/uic_dotdot_mqtt/zap-generated/include/dotdot_mqtt.h
index 7606ec4c85..0a57bcf5ad 100644
--- a/components/uic_dotdot_mqtt/zap-generated/include/dotdot_mqtt.h
+++ b/components/uic_dotdot_mqtt/zap-generated/include/dotdot_mqtt.h
@@ -40139,6 +40139,635 @@ void uic_mqtt_dotdot_unify_thermostat_publish_supported_commands(
 void uic_mqtt_dotdot_unify_thermostat_publish_empty_supported_commands(
   const dotdot_unid_t unid
   ,dotdot_endpoint_id_t endpoint);
+// Callback types used by the unify_schedule_entry_lock cluster
+typedef sl_status_t (*uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_week_day_report_callback_t)(
+    dotdot_unid_t unid,
+    dotdot_endpoint_id_t endpoint,
+    uic_mqtt_dotdot_callback_call_type_t call_type,
+    uint8_t user_identifier,
+
+    uint8_t schedule_slotid,
+
+    uint8_t day_of_week,
+
+    uint8_t start_hour,
+
+    uint8_t start_minute,
+
+    uint8_t stop_hour,
+
+    uint8_t stop_minute
+
+);
+typedef sl_status_t (*uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_year_day_report_callback_t)(
+    dotdot_unid_t unid,
+    dotdot_endpoint_id_t endpoint,
+    uic_mqtt_dotdot_callback_call_type_t call_type,
+    uint8_t set_action,
+
+    uint8_t user_identifier,
+
+    uint8_t schedule_slotid,
+
+    uint8_t start_year,
+
+    uint8_t start_day,
+
+    uint8_t start_hour,
+
+    uint8_t start_minute,
+
+    uint8_t stop_year,
+
+    uint8_t stop_day,
+
+    uint8_t stop_hour,
+
+    uint8_t stop_minute
+
+);
+typedef sl_status_t (*uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_daily_repeating_report_callback_t)(
+    dotdot_unid_t unid,
+    dotdot_endpoint_id_t endpoint,
+    uic_mqtt_dotdot_callback_call_type_t call_type,
+    uint8_t set_action,
+
+    uint8_t user_identifier,
+
+    uint8_t schedule_slotid,
+
+    uint8_t week_day_bitmask,
+
+    uint8_t start_hour,
+
+    uint8_t start_minute,
+
+    uint8_t duration_hour,
+
+    uint8_t duration_minute
+
+);
+
+typedef struct {
+  uint8_t slots_week_day;
+  uint8_t slots_year_day;
+  uint8_t signtzo;
+  uint8_t hourtzo;
+  uint8_t minutetzo;
+  uint8_t dst_offset_sign;
+  uint8_t dst_offset_minute;
+  uint8_t number_of_slots_daily_repeating;
+} uic_mqtt_dotdot_unify_schedule_entry_lock_state_t;
+
+typedef struct {
+  bool slots_week_day;
+  bool slots_year_day;
+  bool signtzo;
+  bool hourtzo;
+  bool minutetzo;
+  bool dst_offset_sign;
+  bool dst_offset_minute;
+  bool number_of_slots_daily_repeating;
+} uic_mqtt_dotdot_unify_schedule_entry_lock_updated_state_t;
+
+typedef sl_status_t (*uic_mqtt_dotdot_unify_schedule_entry_lock_write_attributes_callback_t)(
+    const dotdot_unid_t unid,
+    const dotdot_endpoint_id_t endpoint,
+    uic_mqtt_dotdot_callback_call_type_t call_type,
+    uic_mqtt_dotdot_unify_schedule_entry_lock_state_t,
+    uic_mqtt_dotdot_unify_schedule_entry_lock_updated_state_t
+);
+
+typedef sl_status_t (*uic_mqtt_dotdot_unify_schedule_entry_lock_force_read_attributes_callback_t)(
+    const dotdot_unid_t unid,
+    const dotdot_endpoint_id_t endpoint,
+    uic_mqtt_dotdot_callback_call_type_t call_type,
+    uic_mqtt_dotdot_unify_schedule_entry_lock_updated_state_t
+);
+
+
+/**
+ * @brief Command fields for UnifyScheduleEntryLock/ScheduleEntryLockWeekDayReport
+ */
+typedef struct {
+  uint8_t user_identifier;
+
+  uint8_t schedule_slotid;
+
+  uint8_t day_of_week;
+
+  uint8_t start_hour;
+
+  uint8_t start_minute;
+
+  uint8_t stop_hour;
+
+  uint8_t stop_minute;
+} uic_mqtt_dotdot_unify_schedule_entry_lock_command_schedule_entry_lock_week_day_report_fields_t;
+
+/**
+ * @brief Command fields for UnifyScheduleEntryLock/ScheduleEntryLockYearDayReport
+ */
+typedef struct {
+  uint8_t set_action;
+
+  uint8_t user_identifier;
+
+  uint8_t schedule_slotid;
+
+  uint8_t start_year;
+
+  uint8_t start_day;
+
+  uint8_t start_hour;
+
+  uint8_t start_minute;
+
+  uint8_t stop_year;
+
+  uint8_t stop_day;
+
+  uint8_t stop_hour;
+
+  uint8_t stop_minute;
+} uic_mqtt_dotdot_unify_schedule_entry_lock_command_schedule_entry_lock_year_day_report_fields_t;
+
+/**
+ * @brief Command fields for UnifyScheduleEntryLock/ScheduleEntryLockDailyRepeatingReport
+ */
+typedef struct {
+  uint8_t set_action;
+
+  uint8_t user_identifier;
+
+  uint8_t schedule_slotid;
+
+  uint8_t week_day_bitmask;
+
+  uint8_t start_hour;
+
+  uint8_t start_minute;
+
+  uint8_t duration_hour;
+
+  uint8_t duration_minute;
+} uic_mqtt_dotdot_unify_schedule_entry_lock_command_schedule_entry_lock_daily_repeating_report_fields_t;
+
+
+/**
+ * @brief Setup callback to be called when a
+ * UnifyScheduleEntryLock/Commands/schedule_entry_lock_week_day_report is received.
+ *
+ * Setting this callback will not overwrite the previous set callback
+ * @param callback      Function to be called on command reception
+ */
+void uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_week_day_report_callback_set(const uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_week_day_report_callback_t callback);
+/**
+ * @brief Unsets callback to be called when a
+ * UnifyScheduleEntryLock/Commands/schedule_entry_lock_week_day_report is received.
+ *
+ * @param callback      Function to be no longer called on command reception
+ */
+void uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_week_day_report_callback_unset(const uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_week_day_report_callback_t callback);
+/**
+ * @brief Clears all callbacks registered for when
+ * UnifyScheduleEntryLock/Commands/schedule_entry_lock_week_day_report is received.
+ */
+void uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_week_day_report_callback_clear();
+
+/**
+ * @brief Setup callback to be called when a
+ * +/UnifyScheduleEntryLock/GeneratedCommands/schedule_entry_lock_week_day_report is received.
+ *
+ * Setting this callback will not overwrite the previous set callback
+ * @param callback      Function to be called on command reception
+ */
+void uic_mqtt_dotdot_unify_schedule_entry_lock_generated_schedule_entry_lock_week_day_report_callback_set(const uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_week_day_report_callback_t callback);
+/**
+ * @brief Unsets callback to be called when a
+ * +/UnifyScheduleEntryLock/GeneratedCommands/schedule_entry_lock_week_day_report is received.
+ * @param callback      Function to be no longer called on command reception
+ */
+void uic_mqtt_dotdot_unify_schedule_entry_lock_generated_schedule_entry_lock_week_day_report_callback_unset(const uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_week_day_report_callback_t callback);
+/**
+ * @brief Clears all callbacks registered for when
+ * +/UnifyScheduleEntryLock/GeneratedCommands/schedule_entry_lock_week_day_report is received.
+ */
+void uic_mqtt_dotdot_unify_schedule_entry_lock_generated_schedule_entry_lock_week_day_report_callback_clear();
+/**
+ * @brief Setup callback to be called when a
+ * UnifyScheduleEntryLock/Commands/schedule_entry_lock_year_day_report is received.
+ *
+ * Setting this callback will not overwrite the previous set callback
+ * @param callback      Function to be called on command reception
+ */
+void uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_year_day_report_callback_set(const uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_year_day_report_callback_t callback);
+/**
+ * @brief Unsets callback to be called when a
+ * UnifyScheduleEntryLock/Commands/schedule_entry_lock_year_day_report is received.
+ *
+ * @param callback      Function to be no longer called on command reception
+ */
+void uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_year_day_report_callback_unset(const uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_year_day_report_callback_t callback);
+/**
+ * @brief Clears all callbacks registered for when
+ * UnifyScheduleEntryLock/Commands/schedule_entry_lock_year_day_report is received.
+ */
+void uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_year_day_report_callback_clear();
+
+/**
+ * @brief Setup callback to be called when a
+ * +/UnifyScheduleEntryLock/GeneratedCommands/schedule_entry_lock_year_day_report is received.
+ *
+ * Setting this callback will not overwrite the previous set callback
+ * @param callback      Function to be called on command reception
+ */
+void uic_mqtt_dotdot_unify_schedule_entry_lock_generated_schedule_entry_lock_year_day_report_callback_set(const uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_year_day_report_callback_t callback);
+/**
+ * @brief Unsets callback to be called when a
+ * +/UnifyScheduleEntryLock/GeneratedCommands/schedule_entry_lock_year_day_report is received.
+ * @param callback      Function to be no longer called on command reception
+ */
+void uic_mqtt_dotdot_unify_schedule_entry_lock_generated_schedule_entry_lock_year_day_report_callback_unset(const uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_year_day_report_callback_t callback);
+/**
+ * @brief Clears all callbacks registered for when
+ * +/UnifyScheduleEntryLock/GeneratedCommands/schedule_entry_lock_year_day_report is received.
+ */
+void uic_mqtt_dotdot_unify_schedule_entry_lock_generated_schedule_entry_lock_year_day_report_callback_clear();
+/**
+ * @brief Setup callback to be called when a
+ * UnifyScheduleEntryLock/Commands/schedule_entry_lock_daily_repeating_report is received.
+ *
+ * Setting this callback will not overwrite the previous set callback
+ * @param callback      Function to be called on command reception
+ */
+void uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_daily_repeating_report_callback_set(const uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_daily_repeating_report_callback_t callback);
+/**
+ * @brief Unsets callback to be called when a
+ * UnifyScheduleEntryLock/Commands/schedule_entry_lock_daily_repeating_report is received.
+ *
+ * @param callback      Function to be no longer called on command reception
+ */
+void uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_daily_repeating_report_callback_unset(const uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_daily_repeating_report_callback_t callback);
+/**
+ * @brief Clears all callbacks registered for when
+ * UnifyScheduleEntryLock/Commands/schedule_entry_lock_daily_repeating_report is received.
+ */
+void uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_daily_repeating_report_callback_clear();
+
+/**
+ * @brief Setup callback to be called when a
+ * +/UnifyScheduleEntryLock/GeneratedCommands/schedule_entry_lock_daily_repeating_report is received.
+ *
+ * Setting this callback will not overwrite the previous set callback
+ * @param callback      Function to be called on command reception
+ */
+void uic_mqtt_dotdot_unify_schedule_entry_lock_generated_schedule_entry_lock_daily_repeating_report_callback_set(const uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_daily_repeating_report_callback_t callback);
+/**
+ * @brief Unsets callback to be called when a
+ * +/UnifyScheduleEntryLock/GeneratedCommands/schedule_entry_lock_daily_repeating_report is received.
+ * @param callback      Function to be no longer called on command reception
+ */
+void uic_mqtt_dotdot_unify_schedule_entry_lock_generated_schedule_entry_lock_daily_repeating_report_callback_unset(const uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_daily_repeating_report_callback_t callback);
+/**
+ * @brief Clears all callbacks registered for when
+ * +/UnifyScheduleEntryLock/GeneratedCommands/schedule_entry_lock_daily_repeating_report is received.
+ */
+void uic_mqtt_dotdot_unify_schedule_entry_lock_generated_schedule_entry_lock_daily_repeating_report_callback_clear();
+
+/**
+ * @brief Setup a callback for WriteAttribute to be called when a
+ * +/unify_schedule_entry_lock/Commands/WriteAttributes is received.
+ *
+ * Setting this callback will not overwrite the previous set callback
+ * @param callback      Function to be called on command reception
+ */
+void uic_mqtt_dotdot_set_unify_schedule_entry_lock_write_attributes_callback(
+  const uic_mqtt_dotdot_unify_schedule_entry_lock_write_attributes_callback_t callback
+);
+/**
+ * @brief Unsets a callback for WriteAttribute to be called when a
+ * +/unify_schedule_entry_lock/Commands/WriteAttributes is received.
+ * @param callback      Function to be no longer called on command reception
+ */
+void uic_mqtt_dotdot_unset_unify_schedule_entry_lock_write_attributes_callback(
+  const uic_mqtt_dotdot_unify_schedule_entry_lock_write_attributes_callback_t callback
+);
+/**
+ * @brief Clears all callbacks registered for when
+ * +/unify_schedule_entry_lock/Commands/WriteAttributes is received.
+ */
+void uic_mqtt_dotdot_clear_unify_schedule_entry_lock_write_attributes_callbacks();
+
+/**
+ * @brief Setup a callback for ForceReadAttributes to be called when a
+ * +/unify_schedule_entry_lock/Commands/ForceReadAttributes is received.
+ *
+ * Setting this callback will not overwrite the previous set callback
+ * @param callback      Function to be called on command reception
+ */
+void uic_mqtt_dotdot_set_unify_schedule_entry_lock_force_read_attributes_callback(
+  const uic_mqtt_dotdot_unify_schedule_entry_lock_force_read_attributes_callback_t callback
+);
+/**
+ * @brief Unsets a callback for ForceReadAttributes to be called when a
+ * +/unify_schedule_entry_lock/Commands/ForceReadAttributes is received.
+ *
+ * @param callback      Function to be no longer called on command reception
+ */
+void uic_mqtt_dotdot_unset_unify_schedule_entry_lock_force_read_attributes_callback(
+  const uic_mqtt_dotdot_unify_schedule_entry_lock_force_read_attributes_callback_t callback
+);
+/**
+ * @brief Clears all callbacks registered for when
+ * +/unify_schedule_entry_lock/Commands/ForceReadAttributes is received.
+ */
+void uic_mqtt_dotdot_clear_unify_schedule_entry_lock_force_read_attributes_callbacks();
+
+/**
+ * @brief Publish the attribute; UnifyScheduleEntryLock/Attributes/SlotsWeekDay
+ *
+ * @param base_topic    topic prefix to publish, /slots_week_day
+ *                      will be appended
+ * @param value         Value to publish
+ * @param publish_type  Whether to publish as Desired, Reported, or Both.
+ *
+ * @returns SL_STATUS_OK on success
+ */
+sl_status_t uic_mqtt_dotdot_unify_schedule_entry_lock_slots_week_day_publish(
+  const char *base_topic,
+  uint8_t value,
+  uic_mqtt_dotdot_attribute_publish_type_t publish_type
+);
+
+/**
+ * @brief Unretains a published attribute; UnifyScheduleEntryLock/Attributes/SlotsWeekDay
+ *
+ * @param base_topic    topic prefix to publish, /slots_week_day
+ *                      will be appended
+ * @param publish_type  Whether to publish as Desired, Reported, or Both.
+ *
+ * @returns SL_STATUS_OK on success
+ */
+sl_status_t uic_mqtt_dotdot_unify_schedule_entry_lock_slots_week_day_unretain(
+  const char *base_topic,
+  uic_mqtt_dotdot_attribute_publish_type_t publish_type
+);
+
+/**
+ * @brief Publish the attribute; UnifyScheduleEntryLock/Attributes/SlotsYearDay
+ *
+ * @param base_topic    topic prefix to publish, /slots_year_day
+ *                      will be appended
+ * @param value         Value to publish
+ * @param publish_type  Whether to publish as Desired, Reported, or Both.
+ *
+ * @returns SL_STATUS_OK on success
+ */
+sl_status_t uic_mqtt_dotdot_unify_schedule_entry_lock_slots_year_day_publish(
+  const char *base_topic,
+  uint8_t value,
+  uic_mqtt_dotdot_attribute_publish_type_t publish_type
+);
+
+/**
+ * @brief Unretains a published attribute; UnifyScheduleEntryLock/Attributes/SlotsYearDay
+ *
+ * @param base_topic    topic prefix to publish, /slots_year_day
+ *                      will be appended
+ * @param publish_type  Whether to publish as Desired, Reported, or Both.
+ *
+ * @returns SL_STATUS_OK on success
+ */
+sl_status_t uic_mqtt_dotdot_unify_schedule_entry_lock_slots_year_day_unretain(
+  const char *base_topic,
+  uic_mqtt_dotdot_attribute_publish_type_t publish_type
+);
+
+/**
+ * @brief Publish the attribute; UnifyScheduleEntryLock/Attributes/SignTZO
+ *
+ * @param base_topic    topic prefix to publish, /signtzo
+ *                      will be appended
+ * @param value         Value to publish
+ * @param publish_type  Whether to publish as Desired, Reported, or Both.
+ *
+ * @returns SL_STATUS_OK on success
+ */
+sl_status_t uic_mqtt_dotdot_unify_schedule_entry_lock_signtzo_publish(
+  const char *base_topic,
+  uint8_t value,
+  uic_mqtt_dotdot_attribute_publish_type_t publish_type
+);
+
+/**
+ * @brief Unretains a published attribute; UnifyScheduleEntryLock/Attributes/SignTZO
+ *
+ * @param base_topic    topic prefix to publish, /signtzo
+ *                      will be appended
+ * @param publish_type  Whether to publish as Desired, Reported, or Both.
+ *
+ * @returns SL_STATUS_OK on success
+ */
+sl_status_t uic_mqtt_dotdot_unify_schedule_entry_lock_signtzo_unretain(
+  const char *base_topic,
+  uic_mqtt_dotdot_attribute_publish_type_t publish_type
+);
+
+/**
+ * @brief Publish the attribute; UnifyScheduleEntryLock/Attributes/HourTZO
+ *
+ * @param base_topic    topic prefix to publish, /hourtzo
+ *                      will be appended
+ * @param value         Value to publish
+ * @param publish_type  Whether to publish as Desired, Reported, or Both.
+ *
+ * @returns SL_STATUS_OK on success
+ */
+sl_status_t uic_mqtt_dotdot_unify_schedule_entry_lock_hourtzo_publish(
+  const char *base_topic,
+  uint8_t value,
+  uic_mqtt_dotdot_attribute_publish_type_t publish_type
+);
+
+/**
+ * @brief Unretains a published attribute; UnifyScheduleEntryLock/Attributes/HourTZO
+ *
+ * @param base_topic    topic prefix to publish, /hourtzo
+ *                      will be appended
+ * @param publish_type  Whether to publish as Desired, Reported, or Both.
+ *
+ * @returns SL_STATUS_OK on success
+ */
+sl_status_t uic_mqtt_dotdot_unify_schedule_entry_lock_hourtzo_unretain(
+  const char *base_topic,
+  uic_mqtt_dotdot_attribute_publish_type_t publish_type
+);
+
+/**
+ * @brief Publish the attribute; UnifyScheduleEntryLock/Attributes/MinuteTZO
+ *
+ * @param base_topic    topic prefix to publish, /minutetzo
+ *                      will be appended
+ * @param value         Value to publish
+ * @param publish_type  Whether to publish as Desired, Reported, or Both.
+ *
+ * @returns SL_STATUS_OK on success
+ */
+sl_status_t uic_mqtt_dotdot_unify_schedule_entry_lock_minutetzo_publish(
+  const char *base_topic,
+  uint8_t value,
+  uic_mqtt_dotdot_attribute_publish_type_t publish_type
+);
+
+/**
+ * @brief Unretains a published attribute; UnifyScheduleEntryLock/Attributes/MinuteTZO
+ *
+ * @param base_topic    topic prefix to publish, /minutetzo
+ *                      will be appended
+ * @param publish_type  Whether to publish as Desired, Reported, or Both.
+ *
+ * @returns SL_STATUS_OK on success
+ */
+sl_status_t uic_mqtt_dotdot_unify_schedule_entry_lock_minutetzo_unretain(
+  const char *base_topic,
+  uic_mqtt_dotdot_attribute_publish_type_t publish_type
+);
+
+/**
+ * @brief Publish the attribute; UnifyScheduleEntryLock/Attributes/DSTOffsetSign
+ *
+ * @param base_topic    topic prefix to publish, /dst_offset_sign
+ *                      will be appended
+ * @param value         Value to publish
+ * @param publish_type  Whether to publish as Desired, Reported, or Both.
+ *
+ * @returns SL_STATUS_OK on success
+ */
+sl_status_t uic_mqtt_dotdot_unify_schedule_entry_lock_dst_offset_sign_publish(
+  const char *base_topic,
+  uint8_t value,
+  uic_mqtt_dotdot_attribute_publish_type_t publish_type
+);
+
+/**
+ * @brief Unretains a published attribute; UnifyScheduleEntryLock/Attributes/DSTOffsetSign
+ *
+ * @param base_topic    topic prefix to publish, /dst_offset_sign
+ *                      will be appended
+ * @param publish_type  Whether to publish as Desired, Reported, or Both.
+ *
+ * @returns SL_STATUS_OK on success
+ */
+sl_status_t uic_mqtt_dotdot_unify_schedule_entry_lock_dst_offset_sign_unretain(
+  const char *base_topic,
+  uic_mqtt_dotdot_attribute_publish_type_t publish_type
+);
+
+/**
+ * @brief Publish the attribute; UnifyScheduleEntryLock/Attributes/DSTOffsetMinute
+ *
+ * @param base_topic    topic prefix to publish, /dst_offset_minute
+ *                      will be appended
+ * @param value         Value to publish
+ * @param publish_type  Whether to publish as Desired, Reported, or Both.
+ *
+ * @returns SL_STATUS_OK on success
+ */
+sl_status_t uic_mqtt_dotdot_unify_schedule_entry_lock_dst_offset_minute_publish(
+  const char *base_topic,
+  uint8_t value,
+  uic_mqtt_dotdot_attribute_publish_type_t publish_type
+);
+
+/**
+ * @brief Unretains a published attribute; UnifyScheduleEntryLock/Attributes/DSTOffsetMinute
+ *
+ * @param base_topic    topic prefix to publish, /dst_offset_minute
+ *                      will be appended
+ * @param publish_type  Whether to publish as Desired, Reported, or Both.
+ *
+ * @returns SL_STATUS_OK on success
+ */
+sl_status_t uic_mqtt_dotdot_unify_schedule_entry_lock_dst_offset_minute_unretain(
+  const char *base_topic,
+  uic_mqtt_dotdot_attribute_publish_type_t publish_type
+);
+
+/**
+ * @brief Publish the attribute; UnifyScheduleEntryLock/Attributes/NumberOfSlotsDailyRepeating
+ *
+ * @param base_topic    topic prefix to publish, /number_of_slots_daily_repeating
+ *                      will be appended
+ * @param value         Value to publish
+ * @param publish_type  Whether to publish as Desired, Reported, or Both.
+ *
+ * @returns SL_STATUS_OK on success
+ */
+sl_status_t uic_mqtt_dotdot_unify_schedule_entry_lock_number_of_slots_daily_repeating_publish(
+  const char *base_topic,
+  uint8_t value,
+  uic_mqtt_dotdot_attribute_publish_type_t publish_type
+);
+
+/**
+ * @brief Unretains a published attribute; UnifyScheduleEntryLock/Attributes/NumberOfSlotsDailyRepeating
+ *
+ * @param base_topic    topic prefix to publish, /number_of_slots_daily_repeating
+ *                      will be appended
+ * @param publish_type  Whether to publish as Desired, Reported, or Both.
+ *
+ * @returns SL_STATUS_OK on success
+ */
+sl_status_t uic_mqtt_dotdot_unify_schedule_entry_lock_number_of_slots_daily_repeating_unretain(
+  const char *base_topic,
+  uic_mqtt_dotdot_attribute_publish_type_t publish_type
+);
+
+
+/**
+ * @brief Publish the UnifyScheduleEntryLock/ClusterRevision attribute
+ *
+ * @param base_topic    topic prefix to publish, /UnifyScheduleEntryLock/Attributes/ClusterRevision
+ *                      will be appended.
+ * @param value         Value to publish.
+ */
+void uic_mqtt_dotdot_unify_schedule_entry_lock_publish_cluster_revision(const char* base_topic, uint16_t value);
+
+/**
+ * @brief Unretain a publication to UnifyScheduleEntryLock/ClusterRevision attribute
+ *
+ * @param base_topic    topic prefix to publish, /UnifyScheduleEntryLock/Attributes/ClusterRevision
+ *                      will be appended.
+ */
+void uic_mqtt_dotdot_unify_schedule_entry_lock_unretain_cluster_revision(const char* base_topic);
+
+/**
+ * @brief Publish the SupportedCommands for UNID/EndPoint for the UnifyScheduleEntryLock Cluster
+ *
+ * This function will iterate over all Commands in the UnifyScheduleEntryLock Cluster and
+ * call all registered callback functions with UNID/endpoint, and
+ * callback_type = UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK.
+ * All Cluster Command callback functions that return SL_STATUS_OK
+ * will be added to the list of supported commands and published.
+ *
+ * @param unid
+ * @param endpoint
+ */
+void uic_mqtt_dotdot_unify_schedule_entry_lock_publish_supported_commands(
+  const dotdot_unid_t unid,
+  dotdot_endpoint_id_t endpoint);
+
+/**
+ * @brief Publish an empty array of SupportedCommands for UNID/EndPoint for
+ * the UnifyScheduleEntryLock Cluster
+ *
+ * @param unid
+ * @param endpoint )
+ */
+void uic_mqtt_dotdot_unify_schedule_entry_lock_publish_empty_supported_commands(
+  const dotdot_unid_t unid
+  ,dotdot_endpoint_id_t endpoint);
 // Callback types used by the unify_humidity_control cluster
 typedef sl_status_t (*uic_mqtt_dotdot_unify_humidity_control_mode_set_callback_t)(
     dotdot_unid_t unid,
diff --git a/components/uic_dotdot_mqtt/zap-generated/include/dotdot_mqtt_attributes.h b/components/uic_dotdot_mqtt/zap-generated/include/dotdot_mqtt_attributes.h
index 003f75549d..e8d7b7b258 100644
--- a/components/uic_dotdot_mqtt/zap-generated/include/dotdot_mqtt_attributes.h
+++ b/components/uic_dotdot_mqtt/zap-generated/include/dotdot_mqtt_attributes.h
@@ -5054,6 +5054,63 @@ typedef sl_status_t (*uic_mqtt_dotdot_unify_thermostat_attribute_operating_state
   uic_mqtt_dotdot_attribute_update_type_t update_type,
   uint8_t operating_state
 );
+// Callback types used by the unify_schedule_entry_lock cluster
+typedef sl_status_t (*uic_mqtt_dotdot_unify_schedule_entry_lock_attribute_slots_week_day_callback_t)(
+  dotdot_unid_t unid,
+  dotdot_endpoint_id_t endpoint,
+  bool unretained,
+  uic_mqtt_dotdot_attribute_update_type_t update_type,
+  uint8_t slots_week_day
+);
+typedef sl_status_t (*uic_mqtt_dotdot_unify_schedule_entry_lock_attribute_slots_year_day_callback_t)(
+  dotdot_unid_t unid,
+  dotdot_endpoint_id_t endpoint,
+  bool unretained,
+  uic_mqtt_dotdot_attribute_update_type_t update_type,
+  uint8_t slots_year_day
+);
+typedef sl_status_t (*uic_mqtt_dotdot_unify_schedule_entry_lock_attribute_signtzo_callback_t)(
+  dotdot_unid_t unid,
+  dotdot_endpoint_id_t endpoint,
+  bool unretained,
+  uic_mqtt_dotdot_attribute_update_type_t update_type,
+  uint8_t signtzo
+);
+typedef sl_status_t (*uic_mqtt_dotdot_unify_schedule_entry_lock_attribute_hourtzo_callback_t)(
+  dotdot_unid_t unid,
+  dotdot_endpoint_id_t endpoint,
+  bool unretained,
+  uic_mqtt_dotdot_attribute_update_type_t update_type,
+  uint8_t hourtzo
+);
+typedef sl_status_t (*uic_mqtt_dotdot_unify_schedule_entry_lock_attribute_minutetzo_callback_t)(
+  dotdot_unid_t unid,
+  dotdot_endpoint_id_t endpoint,
+  bool unretained,
+  uic_mqtt_dotdot_attribute_update_type_t update_type,
+  uint8_t minutetzo
+);
+typedef sl_status_t (*uic_mqtt_dotdot_unify_schedule_entry_lock_attribute_dst_offset_sign_callback_t)(
+  dotdot_unid_t unid,
+  dotdot_endpoint_id_t endpoint,
+  bool unretained,
+  uic_mqtt_dotdot_attribute_update_type_t update_type,
+  uint8_t dst_offset_sign
+);
+typedef sl_status_t (*uic_mqtt_dotdot_unify_schedule_entry_lock_attribute_dst_offset_minute_callback_t)(
+  dotdot_unid_t unid,
+  dotdot_endpoint_id_t endpoint,
+  bool unretained,
+  uic_mqtt_dotdot_attribute_update_type_t update_type,
+  uint8_t dst_offset_minute
+);
+typedef sl_status_t (*uic_mqtt_dotdot_unify_schedule_entry_lock_attribute_number_of_slots_daily_repeating_callback_t)(
+  dotdot_unid_t unid,
+  dotdot_endpoint_id_t endpoint,
+  bool unretained,
+  uic_mqtt_dotdot_attribute_update_type_t update_type,
+  uint8_t number_of_slots_daily_repeating
+);
 // Callback types used by the unify_humidity_control cluster
 typedef sl_status_t (*uic_mqtt_dotdot_unify_humidity_control_attribute_reporting_mode_callback_t)(
   dotdot_unid_t unid,
@@ -9854,6 +9911,62 @@ void uic_mqtt_dotdot_unify_thermostat_attribute_supported_thermostat_mode_callba
 void uic_mqtt_dotdot_unify_thermostat_attribute_operating_state_callback_set(const uic_mqtt_dotdot_unify_thermostat_attribute_operating_state_callback_t callback);
 
 
+/**
+ *  Initializes the attributes features for the UnifyScheduleEntryLock cluster,
+ *  allowing to receive attribute updates from other UNIDs.
+ */
+sl_status_t uic_mqtt_dotdot_unify_schedule_entry_lock_attributes_init();
+
+/**
+ * Setup callback to be called when a
+ * UnifyScheduleEntryLock/Attributes/slots_week_day/# is received. Setting
+ * this callback will overwrite the previous set callback
+ */
+void uic_mqtt_dotdot_unify_schedule_entry_lock_attribute_slots_week_day_callback_set(const uic_mqtt_dotdot_unify_schedule_entry_lock_attribute_slots_week_day_callback_t callback);
+/**
+ * Setup callback to be called when a
+ * UnifyScheduleEntryLock/Attributes/slots_year_day/# is received. Setting
+ * this callback will overwrite the previous set callback
+ */
+void uic_mqtt_dotdot_unify_schedule_entry_lock_attribute_slots_year_day_callback_set(const uic_mqtt_dotdot_unify_schedule_entry_lock_attribute_slots_year_day_callback_t callback);
+/**
+ * Setup callback to be called when a
+ * UnifyScheduleEntryLock/Attributes/signtzo/# is received. Setting
+ * this callback will overwrite the previous set callback
+ */
+void uic_mqtt_dotdot_unify_schedule_entry_lock_attribute_signtzo_callback_set(const uic_mqtt_dotdot_unify_schedule_entry_lock_attribute_signtzo_callback_t callback);
+/**
+ * Setup callback to be called when a
+ * UnifyScheduleEntryLock/Attributes/hourtzo/# is received. Setting
+ * this callback will overwrite the previous set callback
+ */
+void uic_mqtt_dotdot_unify_schedule_entry_lock_attribute_hourtzo_callback_set(const uic_mqtt_dotdot_unify_schedule_entry_lock_attribute_hourtzo_callback_t callback);
+/**
+ * Setup callback to be called when a
+ * UnifyScheduleEntryLock/Attributes/minutetzo/# is received. Setting
+ * this callback will overwrite the previous set callback
+ */
+void uic_mqtt_dotdot_unify_schedule_entry_lock_attribute_minutetzo_callback_set(const uic_mqtt_dotdot_unify_schedule_entry_lock_attribute_minutetzo_callback_t callback);
+/**
+ * Setup callback to be called when a
+ * UnifyScheduleEntryLock/Attributes/dst_offset_sign/# is received. Setting
+ * this callback will overwrite the previous set callback
+ */
+void uic_mqtt_dotdot_unify_schedule_entry_lock_attribute_dst_offset_sign_callback_set(const uic_mqtt_dotdot_unify_schedule_entry_lock_attribute_dst_offset_sign_callback_t callback);
+/**
+ * Setup callback to be called when a
+ * UnifyScheduleEntryLock/Attributes/dst_offset_minute/# is received. Setting
+ * this callback will overwrite the previous set callback
+ */
+void uic_mqtt_dotdot_unify_schedule_entry_lock_attribute_dst_offset_minute_callback_set(const uic_mqtt_dotdot_unify_schedule_entry_lock_attribute_dst_offset_minute_callback_t callback);
+/**
+ * Setup callback to be called when a
+ * UnifyScheduleEntryLock/Attributes/number_of_slots_daily_repeating/# is received. Setting
+ * this callback will overwrite the previous set callback
+ */
+void uic_mqtt_dotdot_unify_schedule_entry_lock_attribute_number_of_slots_daily_repeating_callback_set(const uic_mqtt_dotdot_unify_schedule_entry_lock_attribute_number_of_slots_daily_repeating_callback_t callback);
+
+
 /**
  *  Initializes the attributes features for the UnifyHumidityControl cluster,
  *  allowing to receive attribute updates from other UNIDs.
diff --git a/components/uic_dotdot_mqtt/zap-generated/include/dotdot_mqtt_generated_commands.h b/components/uic_dotdot_mqtt/zap-generated/include/dotdot_mqtt_generated_commands.h
index aa8ac95998..04e8e6b1a2 100644
--- a/components/uic_dotdot_mqtt/zap-generated/include/dotdot_mqtt_generated_commands.h
+++ b/components/uic_dotdot_mqtt/zap-generated/include/dotdot_mqtt_generated_commands.h
@@ -4997,6 +4997,91 @@ void uic_mqtt_dotdot_unify_thermostat_publish_generated_write_attributes_command
   uic_mqtt_dotdot_unify_thermostat_updated_state_t attribute_list
 );
 
+/**
+ * @brief Publishes an incoming/generated ScheduleEntryLockWeekDayReport command for
+ * the UnifyScheduleEntryLock cluster.
+ *
+ * Publication will be made at the following topic
+ * ucl/by-unid/UNID/epID/UnifyScheduleEntryLock/GeneratedCommands/ScheduleEntryLockWeekDayReport
+ *
+ * @param unid      The UNID of the node that sent us the command.
+ * 
+ * @param endpoint  The Endpoint ID of the node that sent us the command.
+ * 
+ * 
+ * @param fields                Struct pointer with the fields value of the command
+ * 
+ */
+void uic_mqtt_dotdot_unify_schedule_entry_lock_publish_generated_schedule_entry_lock_week_day_report_command(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint,
+  const uic_mqtt_dotdot_unify_schedule_entry_lock_command_schedule_entry_lock_week_day_report_fields_t *fields
+  
+);
+/**
+ * @brief Publishes an incoming/generated ScheduleEntryLockYearDayReport command for
+ * the UnifyScheduleEntryLock cluster.
+ *
+ * Publication will be made at the following topic
+ * ucl/by-unid/UNID/epID/UnifyScheduleEntryLock/GeneratedCommands/ScheduleEntryLockYearDayReport
+ *
+ * @param unid      The UNID of the node that sent us the command.
+ * 
+ * @param endpoint  The Endpoint ID of the node that sent us the command.
+ * 
+ * 
+ * @param fields                Struct pointer with the fields value of the command
+ * 
+ */
+void uic_mqtt_dotdot_unify_schedule_entry_lock_publish_generated_schedule_entry_lock_year_day_report_command(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint,
+  const uic_mqtt_dotdot_unify_schedule_entry_lock_command_schedule_entry_lock_year_day_report_fields_t *fields
+  
+);
+/**
+ * @brief Publishes an incoming/generated ScheduleEntryLockDailyRepeatingReport command for
+ * the UnifyScheduleEntryLock cluster.
+ *
+ * Publication will be made at the following topic
+ * ucl/by-unid/UNID/epID/UnifyScheduleEntryLock/GeneratedCommands/ScheduleEntryLockDailyRepeatingReport
+ *
+ * @param unid      The UNID of the node that sent us the command.
+ * 
+ * @param endpoint  The Endpoint ID of the node that sent us the command.
+ * 
+ * 
+ * @param fields                Struct pointer with the fields value of the command
+ * 
+ */
+void uic_mqtt_dotdot_unify_schedule_entry_lock_publish_generated_schedule_entry_lock_daily_repeating_report_command(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint,
+  const uic_mqtt_dotdot_unify_schedule_entry_lock_command_schedule_entry_lock_daily_repeating_report_fields_t *fields
+  
+);
+
+/**
+ * @brief Publishes an incoming/generated WriteAttributes command for
+ * the UnifyScheduleEntryLock cluster.
+ *
+ * Publication will be made at the following topic
+ * ucl/by-unid/UNID/epID/UnifyScheduleEntryLock/GeneratedCommands/WriteAttributes
+ *
+ * @param unid      The UNID of the node that sent us the command.
+ * 
+ * @param endpoint  The Endpoint ID of the node that sent us the command.
+ * 
+ * @param attribute_values  Values to assign to the attributes
+ * @param attribute_list    List of attributes that are written
+ */
+void uic_mqtt_dotdot_unify_schedule_entry_lock_publish_generated_write_attributes_command(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint,
+  uic_mqtt_dotdot_unify_schedule_entry_lock_state_t attribute_values,
+  uic_mqtt_dotdot_unify_schedule_entry_lock_updated_state_t attribute_list
+);
+
 /**
  * @brief Publishes an incoming/generated ModeSet command for
  * the UnifyHumidityControl cluster.
diff --git a/components/uic_dotdot_mqtt/zap-generated/include/dotdot_mqtt_group_commands.h b/components/uic_dotdot_mqtt/zap-generated/include/dotdot_mqtt_group_commands.h
index caeee80ffa..7220d03d38 100644
--- a/components/uic_dotdot_mqtt/zap-generated/include/dotdot_mqtt_group_commands.h
+++ b/components/uic_dotdot_mqtt/zap-generated/include/dotdot_mqtt_group_commands.h
@@ -3709,6 +3709,71 @@ void uic_mqtt_dotdot_by_group_unify_thermostat_write_attributes_callback_set(
 
 
 
+/**
+ * @brief Callback signature for by-group UnifyScheduleEntryLock::ScheduleEntryLockWeekDayReport command.
+ */
+typedef void (*uic_mqtt_dotdot_by_group_unify_schedule_entry_lock_schedule_entry_lock_week_day_report_callback_t)(
+    const dotdot_group_id_t group_id,
+    const uic_mqtt_dotdot_unify_schedule_entry_lock_command_schedule_entry_lock_week_day_report_fields_t *fields
+);
+
+/**
+ * Setup handler to be called when a
+ * ucl/by-group/+/UnifyScheduleEntryLock/schedule_entry_lock_week_day_report is received.
+ * Setting this callback will overwrite the previous set callback.
+ *
+ */
+void uic_mqtt_dotdot_by_group_unify_schedule_entry_lock_schedule_entry_lock_week_day_report_callback_set(const uic_mqtt_dotdot_by_group_unify_schedule_entry_lock_schedule_entry_lock_week_day_report_callback_t callback);
+
+/**
+ * @brief Callback signature for by-group UnifyScheduleEntryLock::ScheduleEntryLockYearDayReport command.
+ */
+typedef void (*uic_mqtt_dotdot_by_group_unify_schedule_entry_lock_schedule_entry_lock_year_day_report_callback_t)(
+    const dotdot_group_id_t group_id,
+    const uic_mqtt_dotdot_unify_schedule_entry_lock_command_schedule_entry_lock_year_day_report_fields_t *fields
+);
+
+/**
+ * Setup handler to be called when a
+ * ucl/by-group/+/UnifyScheduleEntryLock/schedule_entry_lock_year_day_report is received.
+ * Setting this callback will overwrite the previous set callback.
+ *
+ */
+void uic_mqtt_dotdot_by_group_unify_schedule_entry_lock_schedule_entry_lock_year_day_report_callback_set(const uic_mqtt_dotdot_by_group_unify_schedule_entry_lock_schedule_entry_lock_year_day_report_callback_t callback);
+
+/**
+ * @brief Callback signature for by-group UnifyScheduleEntryLock::ScheduleEntryLockDailyRepeatingReport command.
+ */
+typedef void (*uic_mqtt_dotdot_by_group_unify_schedule_entry_lock_schedule_entry_lock_daily_repeating_report_callback_t)(
+    const dotdot_group_id_t group_id,
+    const uic_mqtt_dotdot_unify_schedule_entry_lock_command_schedule_entry_lock_daily_repeating_report_fields_t *fields
+);
+
+/**
+ * Setup handler to be called when a
+ * ucl/by-group/+/UnifyScheduleEntryLock/schedule_entry_lock_daily_repeating_report is received.
+ * Setting this callback will overwrite the previous set callback.
+ *
+ */
+void uic_mqtt_dotdot_by_group_unify_schedule_entry_lock_schedule_entry_lock_daily_repeating_report_callback_set(const uic_mqtt_dotdot_by_group_unify_schedule_entry_lock_schedule_entry_lock_daily_repeating_report_callback_t callback);
+
+typedef void (*uic_mqtt_dotdot_by_group_unify_schedule_entry_lock_write_attributes_callback_t)(
+    const dotdot_group_id_t group_id,
+    uic_mqtt_dotdot_unify_schedule_entry_lock_state_t,
+    uic_mqtt_dotdot_unify_schedule_entry_lock_updated_state_t
+);
+
+/**
+ * Setup a callback for WriteAttribute to be called when a
+ * ucl/by-group/+/unify_schedule_entry_lock/Commands/WriteAttributes is received.
+ * Setting this callback will overwrite any previously set callback.
+ */
+void uic_mqtt_dotdot_by_group_unify_schedule_entry_lock_write_attributes_callback_set(
+  const uic_mqtt_dotdot_by_group_unify_schedule_entry_lock_write_attributes_callback_t callback
+);
+
+
+
 /**
  * @brief Callback signature for by-group UnifyHumidityControl::ModeSet command.
  */
diff --git a/components/uic_dotdot_mqtt/zap-generated/include/dotdot_mqtt_send_commands.h b/components/uic_dotdot_mqtt/zap-generated/include/dotdot_mqtt_send_commands.h
index b49b9a5c1a..098475c6d2 100644
--- a/components/uic_dotdot_mqtt/zap-generated/include/dotdot_mqtt_send_commands.h
+++ b/components/uic_dotdot_mqtt/zap-generated/include/dotdot_mqtt_send_commands.h
@@ -7108,6 +7108,123 @@ void uic_mqtt_dotdot_unify_fan_control_publish_turn_off_command(
 void uic_mqtt_dotdot_unify_fan_control_publish_turn_off_command_to_group(
   uint16_t destination_group_id
 );
+/**
+ * @brief Sends/Publishes a ScheduleEntryLockWeekDayReport command for
+ * the UnifyScheduleEntryLock cluster to a destination.
+ *
+ * Publication will be made at the following topic
+ * ucl/by-unid/UNID/epID/UnifyScheduleEntryLock/Commands/ScheduleEntryLockWeekDayReport
+ *
+ * @param destination_unid      The UNID of the node that should receive the command.
+ * 
+ * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
+ * 
+ * 
+ * @param fields                Struct pointer with the fields value of the command
+ * 
+ */
+void uic_mqtt_dotdot_unify_schedule_entry_lock_publish_schedule_entry_lock_week_day_report_command(
+  const dotdot_unid_t destination_unid,
+  const dotdot_endpoint_id_t destination_endpoint,
+  const uic_mqtt_dotdot_unify_schedule_entry_lock_command_schedule_entry_lock_week_day_report_fields_t *fields
+  
+);
+
+/**
+ * @brief Sends/Publishes a ScheduleEntryLockWeekDayReport command for
+ * the UnifyScheduleEntryLock cluster to a group.
+ *
+ * Publication will be made at the following topic
+ * ucl/by-group/GroupID/UnifyScheduleEntryLock/Commands/ScheduleEntryLockWeekDayReport
+ *
+ * @param destination_group_id  The GroupID that should receive the command.
+ * 
+ * @param fields                Struct pointer with the fields value of the command
+ * 
+ */
+void uic_mqtt_dotdot_unify_schedule_entry_lock_publish_schedule_entry_lock_week_day_report_command_to_group(
+  uint16_t destination_group_id,
+  const uic_mqtt_dotdot_unify_schedule_entry_lock_command_schedule_entry_lock_week_day_report_fields_t *fields
+  
+);
+/**
+ * @brief Sends/Publishes a ScheduleEntryLockYearDayReport command for
+ * the UnifyScheduleEntryLock cluster to a destination.
+ *
+ * Publication will be made at the following topic
+ * ucl/by-unid/UNID/epID/UnifyScheduleEntryLock/Commands/ScheduleEntryLockYearDayReport
+ *
+ * @param destination_unid      The UNID of the node that should receive the command.
+ * 
+ * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
+ * 
+ * 
+ * @param fields                Struct pointer with the fields value of the command
+ * 
+ */
+void uic_mqtt_dotdot_unify_schedule_entry_lock_publish_schedule_entry_lock_year_day_report_command(
+  const dotdot_unid_t destination_unid,
+  const dotdot_endpoint_id_t destination_endpoint,
+  const uic_mqtt_dotdot_unify_schedule_entry_lock_command_schedule_entry_lock_year_day_report_fields_t *fields
+  
+);
+
+/**
+ * @brief Sends/Publishes a ScheduleEntryLockYearDayReport command for
+ * the UnifyScheduleEntryLock cluster to a group.
+ *
+ * Publication will be made at the following topic
+ * ucl/by-group/GroupID/UnifyScheduleEntryLock/Commands/ScheduleEntryLockYearDayReport
+ *
+ * @param destination_group_id  The GroupID that should receive the command.
+ * 
+ * @param fields                Struct pointer with the fields value of the command
+ * 
+ */
+void uic_mqtt_dotdot_unify_schedule_entry_lock_publish_schedule_entry_lock_year_day_report_command_to_group(
+  uint16_t destination_group_id,
+  const uic_mqtt_dotdot_unify_schedule_entry_lock_command_schedule_entry_lock_year_day_report_fields_t *fields
+  
+);
+/**
+ * @brief Sends/Publishes a ScheduleEntryLockDailyRepeatingReport command for
+ * the UnifyScheduleEntryLock cluster to a destination.
+ *
+ * Publication will be made at the following topic
+ * ucl/by-unid/UNID/epID/UnifyScheduleEntryLock/Commands/ScheduleEntryLockDailyRepeatingReport
+ *
+ * @param destination_unid      The UNID of the node that should receive the command.
+ * 
+ * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
+ * 
+ * 
+ * @param fields                Struct pointer with the fields value of the command
+ * 
+ */
+void uic_mqtt_dotdot_unify_schedule_entry_lock_publish_schedule_entry_lock_daily_repeating_report_command(
+  const dotdot_unid_t destination_unid,
+  const dotdot_endpoint_id_t destination_endpoint,
+  const uic_mqtt_dotdot_unify_schedule_entry_lock_command_schedule_entry_lock_daily_repeating_report_fields_t *fields
+  
+);
+
+/**
+ * @brief Sends/Publishes a ScheduleEntryLockDailyRepeatingReport command for
+ * the UnifyScheduleEntryLock cluster to a group.
+ *
+ * Publication will be made at the following topic
+ * ucl/by-group/GroupID/UnifyScheduleEntryLock/Commands/ScheduleEntryLockDailyRepeatingReport
+ *
+ * @param destination_group_id  The GroupID that should receive the command.
+ * 
+ * @param fields                Struct pointer with the fields value of the command
+ * 
+ */
+void uic_mqtt_dotdot_unify_schedule_entry_lock_publish_schedule_entry_lock_daily_repeating_report_command_to_group(
+  uint16_t destination_group_id,
+  const uic_mqtt_dotdot_unify_schedule_entry_lock_command_schedule_entry_lock_daily_repeating_report_fields_t *fields
+  
+);
 /**
  * @brief Sends/Publishes a ModeSet command for
  * the UnifyHumidityControl cluster to a destination.
diff --git a/components/uic_dotdot_mqtt/zap-generated/include/dotdot_mqtt_supported_generated_commands.h b/components/uic_dotdot_mqtt/zap-generated/include/dotdot_mqtt_supported_generated_commands.h
index 31b5b4443d..3778a1ec8c 100644
--- a/components/uic_dotdot_mqtt/zap-generated/include/dotdot_mqtt_supported_generated_commands.h
+++ b/components/uic_dotdot_mqtt/zap-generated/include/dotdot_mqtt_supported_generated_commands.h
@@ -1692,6 +1692,37 @@ void uic_mqtt_dotdot_unify_thermostat_publish_supported_generated_commands(
 );
 
 
+/**
+ * @brief Struct containing the list of commands for UnifyScheduleEntryLock
+ */
+typedef struct _uic_mqtt_dotdot_unify_schedule_entry_lock_supported_commands_ {
+  bool schedule_entry_lock_week_day_report;
+  bool schedule_entry_lock_year_day_report;
+  bool schedule_entry_lock_daily_repeating_report;
+  bool write_attributes;
+} uic_mqtt_dotdot_unify_schedule_entry_lock_supported_commands_t;
+
+/**
+ * @brief Sends/Publishes a the SupportedGenerated commands for
+ * the UnifyScheduleEntryLock cluster for a UNID/Endpoint
+ *
+ * Publication will be made at the following topic
+ * ucl/by-unid/UNID/epID/UnifyScheduleEntryLock/SupportedGeneratedCommands
+ *
+ * @param unid      The UNID of the node on behalf of which the advertisment is made
+ * 
+ * @param endpoint  The Endpoint ID of the node on behalf of which the advertisment is made
+ * 
+ * @param command_list      Struct pointer with the fields value indicating if
+ *                          individual commands can be generated.
+ */
+void uic_mqtt_dotdot_unify_schedule_entry_lock_publish_supported_generated_commands(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint,
+  const uic_mqtt_dotdot_unify_schedule_entry_lock_supported_commands_t *command_list
+);
+
+
 /**
  * @brief Struct containing the list of commands for UnifyHumidityControl
  */
diff --git a/components/uic_dotdot_mqtt/zap-generated/src/dotdot_mqtt.cpp b/components/uic_dotdot_mqtt/zap-generated/src/dotdot_mqtt.cpp
index fb910272aa..02a9105975 100644
--- a/components/uic_dotdot_mqtt/zap-generated/src/dotdot_mqtt.cpp
+++ b/components/uic_dotdot_mqtt/zap-generated/src/dotdot_mqtt.cpp
@@ -93961,6 +93961,1486 @@ sl_status_t uic_mqtt_dotdot_unify_thermostat_init()
   return SL_STATUS_OK;
 }
 
+// Callbacks pointers
+static std::set<uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_week_day_report_callback_t> uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_week_day_report_callback;
+static std::set<uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_week_day_report_callback_t> uic_mqtt_dotdot_unify_schedule_entry_lock_generated_schedule_entry_lock_week_day_report_callback;
+static std::set<uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_year_day_report_callback_t> uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_year_day_report_callback;
+static std::set<uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_year_day_report_callback_t> uic_mqtt_dotdot_unify_schedule_entry_lock_generated_schedule_entry_lock_year_day_report_callback;
+static std::set<uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_daily_repeating_report_callback_t> uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_daily_repeating_report_callback;
+static std::set<uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_daily_repeating_report_callback_t> uic_mqtt_dotdot_unify_schedule_entry_lock_generated_schedule_entry_lock_daily_repeating_report_callback;
+static std::set<uic_mqtt_dotdot_unify_schedule_entry_lock_write_attributes_callback_t> uic_mqtt_dotdot_unify_schedule_entry_lock_write_attributes_callback;
+static std::set<uic_mqtt_dotdot_unify_schedule_entry_lock_force_read_attributes_callback_t> uic_mqtt_dotdot_unify_schedule_entry_lock_force_read_attributes_callback;
+
+// Callbacks setters
+void uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_week_day_report_callback_set(const uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_week_day_report_callback_t callback)
+{
+  if (callback != nullptr) {
+    uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_week_day_report_callback.insert(callback);
+  }
+}
+void uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_week_day_report_callback_unset(const uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_week_day_report_callback_t callback)
+{
+  uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_week_day_report_callback.erase(callback);
+}
+void uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_week_day_report_callback_clear()
+{
+  uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_week_day_report_callback.clear();
+}
+std::set<uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_week_day_report_callback_t>& get_uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_week_day_report_callback()
+{
+  return uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_week_day_report_callback;
+}
+
+void uic_mqtt_dotdot_unify_schedule_entry_lock_generated_schedule_entry_lock_week_day_report_callback_set(const uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_week_day_report_callback_t callback)
+{
+  if (callback != nullptr) {
+    uic_mqtt_dotdot_unify_schedule_entry_lock_generated_schedule_entry_lock_week_day_report_callback.insert(callback);
+  }
+}
+void uic_mqtt_dotdot_unify_schedule_entry_lock_generated_schedule_entry_lock_week_day_report_callback_unset(const uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_week_day_report_callback_t callback)
+{
+  uic_mqtt_dotdot_unify_schedule_entry_lock_generated_schedule_entry_lock_week_day_report_callback.erase(callback);
+}
+void uic_mqtt_dotdot_unify_schedule_entry_lock_generated_schedule_entry_lock_week_day_report_callback_clear()
+{
+  uic_mqtt_dotdot_unify_schedule_entry_lock_generated_schedule_entry_lock_week_day_report_callback.clear();
+}
+void uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_year_day_report_callback_set(const uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_year_day_report_callback_t callback)
+{
+  if (callback != nullptr) {
+    uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_year_day_report_callback.insert(callback);
+  }
+}
+void uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_year_day_report_callback_unset(const uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_year_day_report_callback_t callback)
+{
+  uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_year_day_report_callback.erase(callback);
+}
+void uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_year_day_report_callback_clear()
+{
+  uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_year_day_report_callback.clear();
+}
+std::set<uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_year_day_report_callback_t>& get_uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_year_day_report_callback()
+{
+  return uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_year_day_report_callback;
+}
+
+void uic_mqtt_dotdot_unify_schedule_entry_lock_generated_schedule_entry_lock_year_day_report_callback_set(const uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_year_day_report_callback_t callback)
+{
+  if (callback != nullptr) {
+    uic_mqtt_dotdot_unify_schedule_entry_lock_generated_schedule_entry_lock_year_day_report_callback.insert(callback);
+  }
+}
+void uic_mqtt_dotdot_unify_schedule_entry_lock_generated_schedule_entry_lock_year_day_report_callback_unset(const uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_year_day_report_callback_t callback)
+{
+  uic_mqtt_dotdot_unify_schedule_entry_lock_generated_schedule_entry_lock_year_day_report_callback.erase(callback);
+}
+void uic_mqtt_dotdot_unify_schedule_entry_lock_generated_schedule_entry_lock_year_day_report_callback_clear()
+{
+  uic_mqtt_dotdot_unify_schedule_entry_lock_generated_schedule_entry_lock_year_day_report_callback.clear();
+}
+void uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_daily_repeating_report_callback_set(const uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_daily_repeating_report_callback_t callback)
+{
+  if (callback != nullptr) {
+    uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_daily_repeating_report_callback.insert(callback);
+  }
+}
+void uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_daily_repeating_report_callback_unset(const uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_daily_repeating_report_callback_t callback)
+{
+  uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_daily_repeating_report_callback.erase(callback);
+}
+void uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_daily_repeating_report_callback_clear()
+{
+  uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_daily_repeating_report_callback.clear();
+}
+std::set<uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_daily_repeating_report_callback_t>& get_uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_daily_repeating_report_callback()
+{
+  return uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_daily_repeating_report_callback;
+}
+
+void uic_mqtt_dotdot_unify_schedule_entry_lock_generated_schedule_entry_lock_daily_repeating_report_callback_set(const uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_daily_repeating_report_callback_t callback)
+{
+  if (callback != nullptr) {
+    uic_mqtt_dotdot_unify_schedule_entry_lock_generated_schedule_entry_lock_daily_repeating_report_callback.insert(callback);
+  }
+}
+void uic_mqtt_dotdot_unify_schedule_entry_lock_generated_schedule_entry_lock_daily_repeating_report_callback_unset(const uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_daily_repeating_report_callback_t callback)
+{
+  uic_mqtt_dotdot_unify_schedule_entry_lock_generated_schedule_entry_lock_daily_repeating_report_callback.erase(callback);
+}
+void uic_mqtt_dotdot_unify_schedule_entry_lock_generated_schedule_entry_lock_daily_repeating_report_callback_clear()
+{
+  uic_mqtt_dotdot_unify_schedule_entry_lock_generated_schedule_entry_lock_daily_repeating_report_callback.clear();
+}
+
+void uic_mqtt_dotdot_set_unify_schedule_entry_lock_write_attributes_callback(
+  const uic_mqtt_dotdot_unify_schedule_entry_lock_write_attributes_callback_t callback)
+{
+  if (callback != nullptr) {
+    uic_mqtt_dotdot_unify_schedule_entry_lock_write_attributes_callback.insert(callback);
+  }
+}
+void uic_mqtt_dotdot_unset_unify_schedule_entry_lock_write_attributes_callback(
+  const uic_mqtt_dotdot_unify_schedule_entry_lock_write_attributes_callback_t callback)
+{
+  uic_mqtt_dotdot_unify_schedule_entry_lock_write_attributes_callback.erase(callback);
+}
+void uic_mqtt_dotdot_clear_unify_schedule_entry_lock_write_attributes_callbacks()
+{
+  uic_mqtt_dotdot_unify_schedule_entry_lock_write_attributes_callback.clear();
+}
+std::set<uic_mqtt_dotdot_unify_schedule_entry_lock_write_attributes_callback_t>& get_uic_mqtt_dotdot_unify_schedule_entry_lock_write_attributes_callback()
+{
+  return uic_mqtt_dotdot_unify_schedule_entry_lock_write_attributes_callback;
+}
+
+void uic_mqtt_dotdot_set_unify_schedule_entry_lock_force_read_attributes_callback(
+  const uic_mqtt_dotdot_unify_schedule_entry_lock_force_read_attributes_callback_t callback)
+{
+  if (callback != nullptr) {
+    uic_mqtt_dotdot_unify_schedule_entry_lock_force_read_attributes_callback.insert(callback);
+  }
+}
+void uic_mqtt_dotdot_unset_unify_schedule_entry_lock_force_read_attributes_callback(
+  const uic_mqtt_dotdot_unify_schedule_entry_lock_force_read_attributes_callback_t callback)
+{
+  uic_mqtt_dotdot_unify_schedule_entry_lock_force_read_attributes_callback.erase(callback);
+}
+void uic_mqtt_dotdot_clear_unify_schedule_entry_lock_force_read_attributes_callbacks()
+{
+  uic_mqtt_dotdot_unify_schedule_entry_lock_force_read_attributes_callback.clear();
+}
+
+
+// Callback function for incoming publications on ucl/by-unid/+/+/UnifyScheduleEntryLock/Commands/ScheduleEntryLockWeekDayReport
+void uic_mqtt_dotdot_on_unify_schedule_entry_lock_schedule_entry_lock_week_day_report(
+  const char *topic,
+  const char *message,
+  const size_t message_length)
+{
+  if (message_length == 0 || (uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_week_day_report_callback.empty())) {
+    return;
+  }
+
+  std::string unid;
+  uint8_t endpoint = 0; // Default value for endpoint-less topics.
+  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
+    sl_log_debug(LOG_TAG,
+                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
+                topic);
+    return;
+  }
+
+  uint8_t user_identifier = {};
+  uint8_t schedule_slotid = {};
+  uint8_t day_of_week = {};
+  uint8_t start_hour = {};
+  uint8_t start_minute = {};
+  uint8_t stop_hour = {};
+  uint8_t stop_minute = {};
+
+
+  nlohmann::json jsn;
+  try {
+    jsn = nlohmann::json::parse(std::string(message));
+
+  
+    uic_mqtt_dotdot_parse_unify_schedule_entry_lock_schedule_entry_lock_week_day_report(
+      jsn,
+      user_identifier,
+
+      schedule_slotid,
+
+      day_of_week,
+
+      start_hour,
+
+      start_minute,
+
+      stop_hour,
+
+      stop_minute
+      );
+
+  } catch (const nlohmann::json::parse_error& e) {
+    // Catch JSON object field parsing errors
+    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "UnifyScheduleEntryLock", "ScheduleEntryLockWeekDayReport");
+    return;
+  } catch (const nlohmann::json::exception& e) {
+    // Catch JSON object field parsing errors
+    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "UnifyScheduleEntryLock", "ScheduleEntryLockWeekDayReport", e.what());
+    return;
+  } catch (const std::exception& e) {
+    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "UnifyScheduleEntryLock", "ScheduleEntryLockWeekDayReport", "");
+    return;
+  }
+
+
+
+  for (const auto& callback: uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_week_day_report_callback){
+    callback(
+      static_cast<dotdot_unid_t>(unid.c_str()),
+      endpoint,
+      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
+      user_identifier,
+  
+      schedule_slotid,
+  
+      day_of_week,
+  
+      start_hour,
+  
+      start_minute,
+  
+      stop_hour,
+  
+      stop_minute
+  
+    );
+  }
+
+}
+
+// Callback function for incoming publications on ucl/by-unid/+/+/UnifyScheduleEntryLock/GeneratedCommands/ScheduleEntryLockWeekDayReport
+static void uic_mqtt_dotdot_on_generated_unify_schedule_entry_lock_schedule_entry_lock_week_day_report(
+  const char *topic,
+  const char *message,
+  const size_t message_length)
+{
+  if (message_length == 0 || (uic_mqtt_dotdot_unify_schedule_entry_lock_generated_schedule_entry_lock_week_day_report_callback.empty())) {
+    return;
+  }
+
+  std::string unid;
+  uint8_t endpoint = 0; // Default value for endpoint-less topics.
+  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
+    sl_log_debug(LOG_TAG,
+                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
+                topic);
+    return;
+  }
+
+  uint8_t user_identifier = {};
+  uint8_t schedule_slotid = {};
+  uint8_t day_of_week = {};
+  uint8_t start_hour = {};
+  uint8_t start_minute = {};
+  uint8_t stop_hour = {};
+  uint8_t stop_minute = {};
+
+
+  nlohmann::json jsn;
+  try {
+    jsn = nlohmann::json::parse(std::string(message));
+
+  
+    uic_mqtt_dotdot_parse_unify_schedule_entry_lock_schedule_entry_lock_week_day_report(
+      jsn,
+      user_identifier,
+
+      schedule_slotid,
+
+      day_of_week,
+
+      start_hour,
+
+      start_minute,
+
+      stop_hour,
+
+      stop_minute
+      );
+
+  } catch (const nlohmann::json::parse_error& e) {
+    // Catch JSON object field parsing errors
+    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "UnifyScheduleEntryLock", "ScheduleEntryLockWeekDayReport");
+    return;
+  } catch (const nlohmann::json::exception& e) {
+    // Catch JSON object field parsing errors
+    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "UnifyScheduleEntryLock", "ScheduleEntryLockWeekDayReport", e.what());
+    return;
+  } catch (const std::exception& e) {
+    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "UnifyScheduleEntryLock", "ScheduleEntryLockWeekDayReport", "");
+    return;
+  }
+
+
+
+
+  for (const auto& callback: uic_mqtt_dotdot_unify_schedule_entry_lock_generated_schedule_entry_lock_week_day_report_callback){
+    callback(
+      static_cast<dotdot_unid_t>(unid.c_str()),
+      endpoint,
+      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
+      user_identifier,
+  
+      schedule_slotid,
+  
+      day_of_week,
+  
+      start_hour,
+  
+      start_minute,
+  
+      stop_hour,
+  
+      stop_minute
+  
+    );
+  }
+}
+
+
+// Callback function for incoming publications on ucl/by-unid/+/+/UnifyScheduleEntryLock/Commands/ScheduleEntryLockYearDayReport
+void uic_mqtt_dotdot_on_unify_schedule_entry_lock_schedule_entry_lock_year_day_report(
+  const char *topic,
+  const char *message,
+  const size_t message_length)
+{
+  if (message_length == 0 || (uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_year_day_report_callback.empty())) {
+    return;
+  }
+
+  std::string unid;
+  uint8_t endpoint = 0; // Default value for endpoint-less topics.
+  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
+    sl_log_debug(LOG_TAG,
+                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
+                topic);
+    return;
+  }
+
+  uint8_t set_action = {};
+  uint8_t user_identifier = {};
+  uint8_t schedule_slotid = {};
+  uint8_t start_year = {};
+  uint8_t start_day = {};
+  uint8_t start_hour = {};
+  uint8_t start_minute = {};
+  uint8_t stop_year = {};
+  uint8_t stop_day = {};
+  uint8_t stop_hour = {};
+  uint8_t stop_minute = {};
+
+
+  nlohmann::json jsn;
+  try {
+    jsn = nlohmann::json::parse(std::string(message));
+
+  
+    uic_mqtt_dotdot_parse_unify_schedule_entry_lock_schedule_entry_lock_year_day_report(
+      jsn,
+      set_action,
+
+      user_identifier,
+
+      schedule_slotid,
+
+      start_year,
+
+      start_day,
+
+      start_hour,
+
+      start_minute,
+
+      stop_year,
+
+      stop_day,
+
+      stop_hour,
+
+      stop_minute
+      );
+
+  } catch (const nlohmann::json::parse_error& e) {
+    // Catch JSON object field parsing errors
+    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "UnifyScheduleEntryLock", "ScheduleEntryLockYearDayReport");
+    return;
+  } catch (const nlohmann::json::exception& e) {
+    // Catch JSON object field parsing errors
+    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "UnifyScheduleEntryLock", "ScheduleEntryLockYearDayReport", e.what());
+    return;
+  } catch (const std::exception& e) {
+    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "UnifyScheduleEntryLock", "ScheduleEntryLockYearDayReport", "");
+    return;
+  }
+
+
+
+  for (const auto& callback: uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_year_day_report_callback){
+    callback(
+      static_cast<dotdot_unid_t>(unid.c_str()),
+      endpoint,
+      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
+      set_action,
+  
+      user_identifier,
+  
+      schedule_slotid,
+  
+      start_year,
+  
+      start_day,
+  
+      start_hour,
+  
+      start_minute,
+  
+      stop_year,
+  
+      stop_day,
+  
+      stop_hour,
+  
+      stop_minute
+  
+    );
+  }
+
+}
+
+// Callback function for incoming publications on ucl/by-unid/+/+/UnifyScheduleEntryLock/GeneratedCommands/ScheduleEntryLockYearDayReport
+static void uic_mqtt_dotdot_on_generated_unify_schedule_entry_lock_schedule_entry_lock_year_day_report(
+  const char *topic,
+  const char *message,
+  const size_t message_length)
+{
+  if (message_length == 0 || (uic_mqtt_dotdot_unify_schedule_entry_lock_generated_schedule_entry_lock_year_day_report_callback.empty())) {
+    return;
+  }
+
+  std::string unid;
+  uint8_t endpoint = 0; // Default value for endpoint-less topics.
+  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
+    sl_log_debug(LOG_TAG,
+                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
+                topic);
+    return;
+  }
+
+  uint8_t set_action = {};
+  uint8_t user_identifier = {};
+  uint8_t schedule_slotid = {};
+  uint8_t start_year = {};
+  uint8_t start_day = {};
+  uint8_t start_hour = {};
+  uint8_t start_minute = {};
+  uint8_t stop_year = {};
+  uint8_t stop_day = {};
+  uint8_t stop_hour = {};
+  uint8_t stop_minute = {};
+
+
+  nlohmann::json jsn;
+  try {
+    jsn = nlohmann::json::parse(std::string(message));
+
+  
+    uic_mqtt_dotdot_parse_unify_schedule_entry_lock_schedule_entry_lock_year_day_report(
+      jsn,
+      set_action,
+
+      user_identifier,
+
+      schedule_slotid,
+
+      start_year,
+
+      start_day,
+
+      start_hour,
+
+      start_minute,
+
+      stop_year,
+
+      stop_day,
+
+      stop_hour,
+
+      stop_minute
+      );
+
+  } catch (const nlohmann::json::parse_error& e) {
+    // Catch JSON object field parsing errors
+    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "UnifyScheduleEntryLock", "ScheduleEntryLockYearDayReport");
+    return;
+  } catch (const nlohmann::json::exception& e) {
+    // Catch JSON object field parsing errors
+    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "UnifyScheduleEntryLock", "ScheduleEntryLockYearDayReport", e.what());
+    return;
+  } catch (const std::exception& e) {
+    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "UnifyScheduleEntryLock", "ScheduleEntryLockYearDayReport", "");
+    return;
+  }
+
+
+
+
+  for (const auto& callback: uic_mqtt_dotdot_unify_schedule_entry_lock_generated_schedule_entry_lock_year_day_report_callback){
+    callback(
+      static_cast<dotdot_unid_t>(unid.c_str()),
+      endpoint,
+      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
+      set_action,
+  
+      user_identifier,
+  
+      schedule_slotid,
+  
+      start_year,
+  
+      start_day,
+  
+      start_hour,
+  
+      start_minute,
+  
+      stop_year,
+  
+      stop_day,
+  
+      stop_hour,
+  
+      stop_minute
+  
+    );
+  }
+}
+
+
+// Callback function for incoming publications on ucl/by-unid/+/+/UnifyScheduleEntryLock/Commands/ScheduleEntryLockDailyRepeatingReport
+void uic_mqtt_dotdot_on_unify_schedule_entry_lock_schedule_entry_lock_daily_repeating_report(
+  const char *topic,
+  const char *message,
+  const size_t message_length)
+{
+  if (message_length == 0 || (uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_daily_repeating_report_callback.empty())) {
+    return;
+  }
+
+  std::string unid;
+  uint8_t endpoint = 0; // Default value for endpoint-less topics.
+  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
+    sl_log_debug(LOG_TAG,
+                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
+                topic);
+    return;
+  }
+
+  uint8_t set_action = {};
+  uint8_t user_identifier = {};
+  uint8_t schedule_slotid = {};
+  uint8_t week_day_bitmask = {};
+  uint8_t start_hour = {};
+  uint8_t start_minute = {};
+  uint8_t duration_hour = {};
+  uint8_t duration_minute = {};
+
+
+  nlohmann::json jsn;
+  try {
+    jsn = nlohmann::json::parse(std::string(message));
+
+  
+    uic_mqtt_dotdot_parse_unify_schedule_entry_lock_schedule_entry_lock_daily_repeating_report(
+      jsn,
+      set_action,
+
+      user_identifier,
+
+      schedule_slotid,
+
+      week_day_bitmask,
+
+      start_hour,
+
+      start_minute,
+
+      duration_hour,
+
+      duration_minute
+      );
+
+  } catch (const nlohmann::json::parse_error& e) {
+    // Catch JSON object field parsing errors
+    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "UnifyScheduleEntryLock", "ScheduleEntryLockDailyRepeatingReport");
+    return;
+  } catch (const nlohmann::json::exception& e) {
+    // Catch JSON object field parsing errors
+    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "UnifyScheduleEntryLock", "ScheduleEntryLockDailyRepeatingReport", e.what());
+    return;
+  } catch (const std::exception& e) {
+    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "UnifyScheduleEntryLock", "ScheduleEntryLockDailyRepeatingReport", "");
+    return;
+  }
+
+
+
+  for (const auto& callback: uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_daily_repeating_report_callback){
+    callback(
+      static_cast<dotdot_unid_t>(unid.c_str()),
+      endpoint,
+      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
+      set_action,
+  
+      user_identifier,
+  
+      schedule_slotid,
+  
+      week_day_bitmask,
+  
+      start_hour,
+  
+      start_minute,
+  
+      duration_hour,
+  
+      duration_minute
+  
+    );
+  }
+
+}
+
+// Callback function for incoming publications on ucl/by-unid/+/+/UnifyScheduleEntryLock/GeneratedCommands/ScheduleEntryLockDailyRepeatingReport
+static void uic_mqtt_dotdot_on_generated_unify_schedule_entry_lock_schedule_entry_lock_daily_repeating_report(
+  const char *topic,
+  const char *message,
+  const size_t message_length)
+{
+  if (message_length == 0 || (uic_mqtt_dotdot_unify_schedule_entry_lock_generated_schedule_entry_lock_daily_repeating_report_callback.empty())) {
+    return;
+  }
+
+  std::string unid;
+  uint8_t endpoint = 0; // Default value for endpoint-less topics.
+  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
+    sl_log_debug(LOG_TAG,
+                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
+                topic);
+    return;
+  }
+
+  uint8_t set_action = {};
+  uint8_t user_identifier = {};
+  uint8_t schedule_slotid = {};
+  uint8_t week_day_bitmask = {};
+  uint8_t start_hour = {};
+  uint8_t start_minute = {};
+  uint8_t duration_hour = {};
+  uint8_t duration_minute = {};
+
+
+  nlohmann::json jsn;
+  try {
+    jsn = nlohmann::json::parse(std::string(message));
+
+  
+    uic_mqtt_dotdot_parse_unify_schedule_entry_lock_schedule_entry_lock_daily_repeating_report(
+      jsn,
+      set_action,
+
+      user_identifier,
+
+      schedule_slotid,
+
+      week_day_bitmask,
+
+      start_hour,
+
+      start_minute,
+
+      duration_hour,
+
+      duration_minute
+      );
+
+  } catch (const nlohmann::json::parse_error& e) {
+    // Catch JSON object field parsing errors
+    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "UnifyScheduleEntryLock", "ScheduleEntryLockDailyRepeatingReport");
+    return;
+  } catch (const nlohmann::json::exception& e) {
+    // Catch JSON object field parsing errors
+    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "UnifyScheduleEntryLock", "ScheduleEntryLockDailyRepeatingReport", e.what());
+    return;
+  } catch (const std::exception& e) {
+    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "UnifyScheduleEntryLock", "ScheduleEntryLockDailyRepeatingReport", "");
+    return;
+  }
+
+
+
+
+  for (const auto& callback: uic_mqtt_dotdot_unify_schedule_entry_lock_generated_schedule_entry_lock_daily_repeating_report_callback){
+    callback(
+      static_cast<dotdot_unid_t>(unid.c_str()),
+      endpoint,
+      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
+      set_action,
+  
+      user_identifier,
+  
+      schedule_slotid,
+  
+      week_day_bitmask,
+  
+      start_hour,
+  
+      start_minute,
+  
+      duration_hour,
+  
+      duration_minute
+  
+    );
+  }
+}
+
+
+// Callback function for incoming publications on ucl/by-unid/+/+/UnifyScheduleEntryLock/Commands/WriteAttributes
+void uic_mqtt_dotdot_on_unify_schedule_entry_lock_WriteAttributes(
+  const char *topic,
+  const char *message,
+  const size_t message_length)
+{
+  if (uic_mqtt_dotdot_unify_schedule_entry_lock_write_attributes_callback.empty()) {
+    return;
+  }
+
+  if (message_length == 0) {
+    return;
+  }
+
+  std::string unid;
+  uint8_t endpoint = 0; // Default value for endpoint-less topics.
+  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
+    sl_log_debug(LOG_TAG,
+                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
+                topic);
+    return;
+  }
+
+  uic_mqtt_dotdot_unify_schedule_entry_lock_state_t new_state = {};
+  uic_mqtt_dotdot_unify_schedule_entry_lock_updated_state_t new_updated_state = {};
+
+
+  nlohmann::json jsn;
+  try {
+    jsn = nlohmann::json::parse(std::string(message));
+
+    uic_mqtt_dotdot_parse_unify_schedule_entry_lock_write_attributes(
+      jsn,
+      new_state,
+      new_updated_state
+    );
+  } catch (const nlohmann::json::parse_error& e) {
+    // Catch JSON object field parsing errors
+    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "UnifyScheduleEntryLock", "WriteAttributes");
+    return;
+  } catch (const nlohmann::json::exception& e) {
+    // Catch JSON object field parsing errors
+    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "UnifyScheduleEntryLock", "WriteAttributes", e.what());
+    return;
+  } catch (const std::exception& e) {
+    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "UnifyScheduleEntryLock", "WriteAttributes", "");
+    return;
+  }
+
+  for (const auto& callback: uic_mqtt_dotdot_unify_schedule_entry_lock_write_attributes_callback){
+    callback(
+      static_cast<dotdot_unid_t>(unid.c_str()),
+      endpoint,
+      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
+      new_state,
+      new_updated_state
+    );
+  }
+
+}
+
+static void uic_mqtt_dotdot_on_unify_schedule_entry_lock_force_read_attributes(
+  const char *topic,
+  const char *message,
+  const size_t message_length)
+{
+  uint8_t endpoint = 0;
+  std::string unid;
+
+  if ((message_length == 0) || (uic_mqtt_dotdot_unify_schedule_entry_lock_force_read_attributes_callback.empty())) {
+    return;
+  }
+
+  if(! uic_dotdot_mqtt::parse_topic(topic, unid, endpoint)) {
+    sl_log_debug(LOG_TAG,
+                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
+                topic);
+    return;
+  }
+
+  try {
+    uic_mqtt_dotdot_unify_schedule_entry_lock_updated_state_t force_update = {0};
+    bool trigger_handler = false;
+
+    nlohmann::json jsn = nlohmann::json::parse(std::string(message));
+    std::vector<std::string> attributes = jsn["value"].get<std::vector<std::string>>();
+
+    // Assume all attributes to be read on empty array received
+    if (attributes.size() == 0) {
+      force_update.slots_week_day = true;
+      force_update.slots_year_day = true;
+      force_update.signtzo = true;
+      force_update.hourtzo = true;
+      force_update.minutetzo = true;
+      force_update.dst_offset_sign = true;
+      force_update.dst_offset_minute = true;
+      force_update.number_of_slots_daily_repeating = true;
+      trigger_handler = true;
+    } else {
+      std::unordered_map<std::string, bool *> supported_attrs = {
+        {"SlotsWeekDay", &force_update.slots_week_day },
+        {"SlotsYearDay", &force_update.slots_year_day },
+        {"SignTZO", &force_update.signtzo },
+        {"HourTZO", &force_update.hourtzo },
+        {"MinuteTZO", &force_update.minutetzo },
+        {"DSTOffsetSign", &force_update.dst_offset_sign },
+        {"DSTOffsetMinute", &force_update.dst_offset_minute },
+        {"NumberOfSlotsDailyRepeating", &force_update.number_of_slots_daily_repeating },
+      };
+
+      for (auto& attribute : attributes) {
+        auto found_attr = supported_attrs.find(attribute);
+        if (found_attr != supported_attrs.end()) {
+          *(found_attr->second) = true;
+          trigger_handler = true;
+        }
+      }
+    }
+
+    if (trigger_handler == true) {
+      for (const auto& callback: uic_mqtt_dotdot_unify_schedule_entry_lock_force_read_attributes_callback) {
+        callback(
+          static_cast<dotdot_unid_t>(unid.c_str()),
+          endpoint,
+          UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
+          force_update
+        );
+      }
+    }
+  } catch (...) {
+    sl_log_debug(LOG_TAG, "UnifyScheduleEntryLock/Commands/ForceReadAttributes: Unable to parse JSON payload");
+    return;
+  }
+}
+
+sl_status_t uic_mqtt_dotdot_unify_schedule_entry_lock_slots_week_day_publish(
+  const char *base_topic,
+  uint8_t value,
+  uic_mqtt_dotdot_attribute_publish_type_t publish_type
+)
+{
+  nlohmann::json jsn;
+
+  // This is a single value
+
+  if (true == uic_dotdot_has_attribute_value_a_name(64801,1,value)) {
+    jsn["value"] = uic_dotdot_get_attribute_value_name(64801,1,value);
+  }else{
+    jsn["value"] = value;
+  }
+
+
+  std::string payload_str;
+  try {
+    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
+    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
+  } catch (const nlohmann::json::exception& e) {
+    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "UnifyScheduleEntryLock/Attributes/SlotsWeekDay", e.what());
+    return SL_STATUS_OK;
+  }
+
+
+  std::string topic = std::string(base_topic) + "/UnifyScheduleEntryLock/Attributes/SlotsWeekDay";
+  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
+  {
+    std::string topic_desired = topic + "/Desired";
+    uic_mqtt_publish(topic_desired.c_str(),
+              payload_str.c_str(),
+              payload_str.length(),
+              true);
+  }
+  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
+  {
+    std::string topic_reported = topic + "/Reported";
+    uic_mqtt_publish(topic_reported.c_str(),
+              payload_str.c_str(),
+              payload_str.length(),
+              true);
+  }
+  return SL_STATUS_OK;
+}
+
+sl_status_t uic_mqtt_dotdot_unify_schedule_entry_lock_slots_week_day_unretain(
+  const char *base_topic,
+  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
+{
+  // clang-format on
+  std::string topic
+    = std::string(base_topic)
+      + "/UnifyScheduleEntryLock/Attributes/SlotsWeekDay";
+
+  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
+      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
+    std::string topic_desired = topic + "/Desired";
+    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
+  }
+  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
+      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
+    std::string topic_reported = topic + "/Reported";
+    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
+  }
+  return SL_STATUS_OK;
+}
+// clang-format off
+
+sl_status_t uic_mqtt_dotdot_unify_schedule_entry_lock_slots_year_day_publish(
+  const char *base_topic,
+  uint8_t value,
+  uic_mqtt_dotdot_attribute_publish_type_t publish_type
+)
+{
+  nlohmann::json jsn;
+
+  // This is a single value
+
+  if (true == uic_dotdot_has_attribute_value_a_name(64801,2,value)) {
+    jsn["value"] = uic_dotdot_get_attribute_value_name(64801,2,value);
+  }else{
+    jsn["value"] = value;
+  }
+
+
+  std::string payload_str;
+  try {
+    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
+    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
+  } catch (const nlohmann::json::exception& e) {
+    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "UnifyScheduleEntryLock/Attributes/SlotsYearDay", e.what());
+    return SL_STATUS_OK;
+  }
+
+
+  std::string topic = std::string(base_topic) + "/UnifyScheduleEntryLock/Attributes/SlotsYearDay";
+  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
+  {
+    std::string topic_desired = topic + "/Desired";
+    uic_mqtt_publish(topic_desired.c_str(),
+              payload_str.c_str(),
+              payload_str.length(),
+              true);
+  }
+  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
+  {
+    std::string topic_reported = topic + "/Reported";
+    uic_mqtt_publish(topic_reported.c_str(),
+              payload_str.c_str(),
+              payload_str.length(),
+              true);
+  }
+  return SL_STATUS_OK;
+}
+
+sl_status_t uic_mqtt_dotdot_unify_schedule_entry_lock_slots_year_day_unretain(
+  const char *base_topic,
+  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
+{
+  // clang-format on
+  std::string topic
+    = std::string(base_topic)
+      + "/UnifyScheduleEntryLock/Attributes/SlotsYearDay";
+
+  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
+      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
+    std::string topic_desired = topic + "/Desired";
+    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
+  }
+  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
+      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
+    std::string topic_reported = topic + "/Reported";
+    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
+  }
+  return SL_STATUS_OK;
+}
+// clang-format off
+
+sl_status_t uic_mqtt_dotdot_unify_schedule_entry_lock_signtzo_publish(
+  const char *base_topic,
+  uint8_t value,
+  uic_mqtt_dotdot_attribute_publish_type_t publish_type
+)
+{
+  nlohmann::json jsn;
+
+  // This is a single value
+
+  if (true == uic_dotdot_has_attribute_value_a_name(64801,3,value)) {
+    jsn["value"] = uic_dotdot_get_attribute_value_name(64801,3,value);
+  }else{
+    jsn["value"] = value;
+  }
+
+
+  std::string payload_str;
+  try {
+    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
+    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
+  } catch (const nlohmann::json::exception& e) {
+    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "UnifyScheduleEntryLock/Attributes/SignTZO", e.what());
+    return SL_STATUS_OK;
+  }
+
+
+  std::string topic = std::string(base_topic) + "/UnifyScheduleEntryLock/Attributes/SignTZO";
+  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
+  {
+    std::string topic_desired = topic + "/Desired";
+    uic_mqtt_publish(topic_desired.c_str(),
+              payload_str.c_str(),
+              payload_str.length(),
+              true);
+  }
+  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
+  {
+    std::string topic_reported = topic + "/Reported";
+    uic_mqtt_publish(topic_reported.c_str(),
+              payload_str.c_str(),
+              payload_str.length(),
+              true);
+  }
+  return SL_STATUS_OK;
+}
+
+sl_status_t uic_mqtt_dotdot_unify_schedule_entry_lock_signtzo_unretain(
+  const char *base_topic,
+  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
+{
+  // clang-format on
+  std::string topic
+    = std::string(base_topic)
+      + "/UnifyScheduleEntryLock/Attributes/SignTZO";
+
+  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
+      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
+    std::string topic_desired = topic + "/Desired";
+    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
+  }
+  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
+      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
+    std::string topic_reported = topic + "/Reported";
+    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
+  }
+  return SL_STATUS_OK;
+}
+// clang-format off
+
+sl_status_t uic_mqtt_dotdot_unify_schedule_entry_lock_hourtzo_publish(
+  const char *base_topic,
+  uint8_t value,
+  uic_mqtt_dotdot_attribute_publish_type_t publish_type
+)
+{
+  nlohmann::json jsn;
+
+  // This is a single value
+
+  if (true == uic_dotdot_has_attribute_value_a_name(64801,4,value)) {
+    jsn["value"] = uic_dotdot_get_attribute_value_name(64801,4,value);
+  }else{
+    jsn["value"] = value;
+  }
+
+
+  std::string payload_str;
+  try {
+    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
+    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
+  } catch (const nlohmann::json::exception& e) {
+    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "UnifyScheduleEntryLock/Attributes/HourTZO", e.what());
+    return SL_STATUS_OK;
+  }
+
+
+  std::string topic = std::string(base_topic) + "/UnifyScheduleEntryLock/Attributes/HourTZO";
+  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
+  {
+    std::string topic_desired = topic + "/Desired";
+    uic_mqtt_publish(topic_desired.c_str(),
+              payload_str.c_str(),
+              payload_str.length(),
+              true);
+  }
+  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
+  {
+    std::string topic_reported = topic + "/Reported";
+    uic_mqtt_publish(topic_reported.c_str(),
+              payload_str.c_str(),
+              payload_str.length(),
+              true);
+  }
+  return SL_STATUS_OK;
+}
+
+sl_status_t uic_mqtt_dotdot_unify_schedule_entry_lock_hourtzo_unretain(
+  const char *base_topic,
+  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
+{
+  // clang-format on
+  std::string topic
+    = std::string(base_topic)
+      + "/UnifyScheduleEntryLock/Attributes/HourTZO";
+
+  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
+      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
+    std::string topic_desired = topic + "/Desired";
+    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
+  }
+  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
+      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
+    std::string topic_reported = topic + "/Reported";
+    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
+  }
+  return SL_STATUS_OK;
+}
+// clang-format off
+
+sl_status_t uic_mqtt_dotdot_unify_schedule_entry_lock_minutetzo_publish(
+  const char *base_topic,
+  uint8_t value,
+  uic_mqtt_dotdot_attribute_publish_type_t publish_type
+)
+{
+  nlohmann::json jsn;
+
+  // This is a single value
+
+  if (true == uic_dotdot_has_attribute_value_a_name(64801,5,value)) {
+    jsn["value"] = uic_dotdot_get_attribute_value_name(64801,5,value);
+  }else{
+    jsn["value"] = value;
+  }
+
+
+  std::string payload_str;
+  try {
+    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
+    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
+  } catch (const nlohmann::json::exception& e) {
+    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "UnifyScheduleEntryLock/Attributes/MinuteTZO", e.what());
+    return SL_STATUS_OK;
+  }
+
+
+  std::string topic = std::string(base_topic) + "/UnifyScheduleEntryLock/Attributes/MinuteTZO";
+  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
+  {
+    std::string topic_desired = topic + "/Desired";
+    uic_mqtt_publish(topic_desired.c_str(),
+              payload_str.c_str(),
+              payload_str.length(),
+              true);
+  }
+  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
+  {
+    std::string topic_reported = topic + "/Reported";
+    uic_mqtt_publish(topic_reported.c_str(),
+              payload_str.c_str(),
+              payload_str.length(),
+              true);
+  }
+  return SL_STATUS_OK;
+}
+
+sl_status_t uic_mqtt_dotdot_unify_schedule_entry_lock_minutetzo_unretain(
+  const char *base_topic,
+  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
+{
+  // clang-format on
+  std::string topic
+    = std::string(base_topic)
+      + "/UnifyScheduleEntryLock/Attributes/MinuteTZO";
+
+  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
+      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
+    std::string topic_desired = topic + "/Desired";
+    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
+  }
+  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
+      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
+    std::string topic_reported = topic + "/Reported";
+    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
+  }
+  return SL_STATUS_OK;
+}
+// clang-format off
+
+sl_status_t uic_mqtt_dotdot_unify_schedule_entry_lock_dst_offset_sign_publish(
+  const char *base_topic,
+  uint8_t value,
+  uic_mqtt_dotdot_attribute_publish_type_t publish_type
+)
+{
+  nlohmann::json jsn;
+
+  // This is a single value
+
+  if (true == uic_dotdot_has_attribute_value_a_name(64801,6,value)) {
+    jsn["value"] = uic_dotdot_get_attribute_value_name(64801,6,value);
+  }else{
+    jsn["value"] = value;
+  }
+
+
+  std::string payload_str;
+  try {
+    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
+    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
+  } catch (const nlohmann::json::exception& e) {
+    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "UnifyScheduleEntryLock/Attributes/DSTOffsetSign", e.what());
+    return SL_STATUS_OK;
+  }
+
+
+  std::string topic = std::string(base_topic) + "/UnifyScheduleEntryLock/Attributes/DSTOffsetSign";
+  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
+  {
+    std::string topic_desired = topic + "/Desired";
+    uic_mqtt_publish(topic_desired.c_str(),
+              payload_str.c_str(),
+              payload_str.length(),
+              true);
+  }
+  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
+  {
+    std::string topic_reported = topic + "/Reported";
+    uic_mqtt_publish(topic_reported.c_str(),
+              payload_str.c_str(),
+              payload_str.length(),
+              true);
+  }
+  return SL_STATUS_OK;
+}
+
+sl_status_t uic_mqtt_dotdot_unify_schedule_entry_lock_dst_offset_sign_unretain(
+  const char *base_topic,
+  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
+{
+  // clang-format on
+  std::string topic
+    = std::string(base_topic)
+      + "/UnifyScheduleEntryLock/Attributes/DSTOffsetSign";
+
+  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
+      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
+    std::string topic_desired = topic + "/Desired";
+    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
+  }
+  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
+      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
+    std::string topic_reported = topic + "/Reported";
+    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
+  }
+  return SL_STATUS_OK;
+}
+// clang-format off
+
+sl_status_t uic_mqtt_dotdot_unify_schedule_entry_lock_dst_offset_minute_publish(
+  const char *base_topic,
+  uint8_t value,
+  uic_mqtt_dotdot_attribute_publish_type_t publish_type
+)
+{
+  nlohmann::json jsn;
+
+  // This is a single value
+
+  if (true == uic_dotdot_has_attribute_value_a_name(64801,7,value)) {
+    jsn["value"] = uic_dotdot_get_attribute_value_name(64801,7,value);
+  }else{
+    jsn["value"] = value;
+  }
+
+
+  std::string payload_str;
+  try {
+    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
+    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
+  } catch (const nlohmann::json::exception& e) {
+    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "UnifyScheduleEntryLock/Attributes/DSTOffsetMinute", e.what());
+    return SL_STATUS_OK;
+  }
+
+
+  std::string topic = std::string(base_topic) + "/UnifyScheduleEntryLock/Attributes/DSTOffsetMinute";
+  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
+  {
+    std::string topic_desired = topic + "/Desired";
+    uic_mqtt_publish(topic_desired.c_str(),
+              payload_str.c_str(),
+              payload_str.length(),
+              true);
+  }
+  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
+  {
+    std::string topic_reported = topic + "/Reported";
+    uic_mqtt_publish(topic_reported.c_str(),
+              payload_str.c_str(),
+              payload_str.length(),
+              true);
+  }
+  return SL_STATUS_OK;
+}
+
+sl_status_t uic_mqtt_dotdot_unify_schedule_entry_lock_dst_offset_minute_unretain(
+  const char *base_topic,
+  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
+{
+  // clang-format on
+  std::string topic
+    = std::string(base_topic)
+      + "/UnifyScheduleEntryLock/Attributes/DSTOffsetMinute";
+
+  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
+      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
+    std::string topic_desired = topic + "/Desired";
+    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
+  }
+  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
+      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
+    std::string topic_reported = topic + "/Reported";
+    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
+  }
+  return SL_STATUS_OK;
+}
+// clang-format off
+
+sl_status_t uic_mqtt_dotdot_unify_schedule_entry_lock_number_of_slots_daily_repeating_publish(
+  const char *base_topic,
+  uint8_t value,
+  uic_mqtt_dotdot_attribute_publish_type_t publish_type
+)
+{
+  nlohmann::json jsn;
+
+  // This is a single value
+
+  if (true == uic_dotdot_has_attribute_value_a_name(64801,8,value)) {
+    jsn["value"] = uic_dotdot_get_attribute_value_name(64801,8,value);
+  }else{
+    jsn["value"] = value;
+  }
+
+
+  std::string payload_str;
+  try {
+    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
+    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
+  } catch (const nlohmann::json::exception& e) {
+    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "UnifyScheduleEntryLock/Attributes/NumberOfSlotsDailyRepeating", e.what());
+    return SL_STATUS_OK;
+  }
+
+
+  std::string topic = std::string(base_topic) + "/UnifyScheduleEntryLock/Attributes/NumberOfSlotsDailyRepeating";
+  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
+  {
+    std::string topic_desired = topic + "/Desired";
+    uic_mqtt_publish(topic_desired.c_str(),
+              payload_str.c_str(),
+              payload_str.length(),
+              true);
+  }
+  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
+  {
+    std::string topic_reported = topic + "/Reported";
+    uic_mqtt_publish(topic_reported.c_str(),
+              payload_str.c_str(),
+              payload_str.length(),
+              true);
+  }
+  return SL_STATUS_OK;
+}
+
+sl_status_t uic_mqtt_dotdot_unify_schedule_entry_lock_number_of_slots_daily_repeating_unretain(
+  const char *base_topic,
+  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
+{
+  // clang-format on
+  std::string topic
+    = std::string(base_topic)
+      + "/UnifyScheduleEntryLock/Attributes/NumberOfSlotsDailyRepeating";
+
+  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
+      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
+    std::string topic_desired = topic + "/Desired";
+    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
+  }
+  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
+      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
+    std::string topic_reported = topic + "/Reported";
+    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
+  }
+  return SL_STATUS_OK;
+}
+// clang-format off
+
+
+sl_status_t uic_mqtt_dotdot_unify_schedule_entry_lock_init()
+{
+  std::string base_topic = "ucl/by-unid/+/+/";
+
+  std::string subscription_topic;
+  if(!uic_mqtt_dotdot_unify_schedule_entry_lock_write_attributes_callback.empty()) {
+    subscription_topic = base_topic + "UnifyScheduleEntryLock/Commands/WriteAttributes";
+    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_unify_schedule_entry_lock_WriteAttributes);
+  }
+
+  if(!uic_mqtt_dotdot_unify_schedule_entry_lock_force_read_attributes_callback.empty()) {
+    subscription_topic = base_topic + "UnifyScheduleEntryLock/Commands/ForceReadAttributes";
+    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_unify_schedule_entry_lock_force_read_attributes);
+  }
+  if (!uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_week_day_report_callback.empty()) {
+    subscription_topic = base_topic + "UnifyScheduleEntryLock/Commands/ScheduleEntryLockWeekDayReport";
+    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_unify_schedule_entry_lock_schedule_entry_lock_week_day_report);
+  }
+  if (!uic_mqtt_dotdot_unify_schedule_entry_lock_generated_schedule_entry_lock_week_day_report_callback.empty()) {
+    subscription_topic = base_topic + "UnifyScheduleEntryLock/GeneratedCommands/ScheduleEntryLockWeekDayReport";
+    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_unify_schedule_entry_lock_schedule_entry_lock_week_day_report);
+  }
+  if (!uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_year_day_report_callback.empty()) {
+    subscription_topic = base_topic + "UnifyScheduleEntryLock/Commands/ScheduleEntryLockYearDayReport";
+    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_unify_schedule_entry_lock_schedule_entry_lock_year_day_report);
+  }
+  if (!uic_mqtt_dotdot_unify_schedule_entry_lock_generated_schedule_entry_lock_year_day_report_callback.empty()) {
+    subscription_topic = base_topic + "UnifyScheduleEntryLock/GeneratedCommands/ScheduleEntryLockYearDayReport";
+    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_unify_schedule_entry_lock_schedule_entry_lock_year_day_report);
+  }
+  if (!uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_daily_repeating_report_callback.empty()) {
+    subscription_topic = base_topic + "UnifyScheduleEntryLock/Commands/ScheduleEntryLockDailyRepeatingReport";
+    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_unify_schedule_entry_lock_schedule_entry_lock_daily_repeating_report);
+  }
+  if (!uic_mqtt_dotdot_unify_schedule_entry_lock_generated_schedule_entry_lock_daily_repeating_report_callback.empty()) {
+    subscription_topic = base_topic + "UnifyScheduleEntryLock/GeneratedCommands/ScheduleEntryLockDailyRepeatingReport";
+    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_unify_schedule_entry_lock_schedule_entry_lock_daily_repeating_report);
+  }
+
+  // Init the attributes for that cluster
+  uic_mqtt_dotdot_unify_schedule_entry_lock_attributes_init();
+
+  uic_mqtt_dotdot_by_group_unify_schedule_entry_lock_init();
+
+  return SL_STATUS_OK;
+}
+
 // Callbacks pointers
 static std::set<uic_mqtt_dotdot_unify_humidity_control_mode_set_callback_t> uic_mqtt_dotdot_unify_humidity_control_mode_set_callback;
 static std::set<uic_mqtt_dotdot_unify_humidity_control_mode_set_callback_t> uic_mqtt_dotdot_unify_humidity_control_generated_mode_set_callback;
@@ -96101,6 +97581,10 @@ sl_status_t uic_mqtt_dotdot_init() {
     status_flag = uic_mqtt_dotdot_unify_thermostat_init();
   }
 
+  if (status_flag == SL_STATUS_OK) {
+    status_flag = uic_mqtt_dotdot_unify_schedule_entry_lock_init();
+  }
+
   if (status_flag == SL_STATUS_OK) {
     status_flag = uic_mqtt_dotdot_unify_humidity_control_init();
   }
@@ -96167,6 +97651,7 @@ void uic_mqtt_dotdot_publish_supported_commands(
   uic_mqtt_dotdot_descriptor_publish_supported_commands(unid, endpoint_id);
   uic_mqtt_dotdot_unify_fan_control_publish_supported_commands(unid, endpoint_id);
   uic_mqtt_dotdot_unify_thermostat_publish_supported_commands(unid, endpoint_id);
+  uic_mqtt_dotdot_unify_schedule_entry_lock_publish_supported_commands(unid, endpoint_id);
   uic_mqtt_dotdot_unify_humidity_control_publish_supported_commands(unid, endpoint_id);
 }
 
@@ -96227,6 +97712,7 @@ void uic_mqtt_dotdot_publish_empty_supported_commands(
   uic_mqtt_dotdot_descriptor_publish_empty_supported_commands(unid, endpoint_id);
   uic_mqtt_dotdot_unify_fan_control_publish_empty_supported_commands(unid, endpoint_id);
   uic_mqtt_dotdot_unify_thermostat_publish_empty_supported_commands(unid, endpoint_id);
+  uic_mqtt_dotdot_unify_schedule_entry_lock_publish_empty_supported_commands(unid, endpoint_id);
   uic_mqtt_dotdot_unify_humidity_control_publish_empty_supported_commands(unid, endpoint_id);
 }
 
@@ -109531,8 +111017,170 @@ static inline bool uic_mqtt_dotdot_unify_fan_control_write_attributes_is_support
           unid,
           endpoint_id,
           UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
-          unify_fan_control_new_state,
-          unify_fan_control_new_updated_state
+          unify_fan_control_new_state,
+          unify_fan_control_new_updated_state
+      ) == SL_STATUS_OK) {
+      return true;
+    }
+  }
+  return false;
+}
+
+static inline bool uic_mqtt_dotdot_unify_fan_control_force_read_attributes_is_supported(
+  const dotdot_unid_t unid,
+  dotdot_endpoint_id_t endpoint_id)
+{
+  for (const auto& callback: uic_mqtt_dotdot_unify_fan_control_force_read_attributes_callback) {
+    uic_mqtt_dotdot_unify_fan_control_updated_state_t unify_fan_control_force_update = {0};
+    if (callback(
+          unid,
+          endpoint_id,
+          UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
+          unify_fan_control_force_update
+      ) == SL_STATUS_OK) {
+      return true;
+    }
+  }
+  return false;
+}
+
+// Publishing Supported Commands for UnifyFanControl Cluster
+void uic_mqtt_dotdot_unify_fan_control_publish_supported_commands(
+  const dotdot_unid_t unid,
+  dotdot_endpoint_id_t endpoint_id)
+{
+  std::stringstream ss;
+  bool first_command = true;
+  ss.str("");
+
+  // check if there is callback for each command
+  if (uic_mqtt_dotdot_unify_fan_control_set_fan_mode_is_supported(unid, endpoint_id)) {
+    if (first_command == false) {
+      ss << ", ";
+    }
+    first_command = false;
+    ss << R"("SetFanMode")";
+  }
+  if (uic_mqtt_dotdot_unify_fan_control_turn_off_is_supported(unid, endpoint_id)) {
+    if (first_command == false) {
+      ss << ", ";
+    }
+    first_command = false;
+    ss << R"("TurnOff")";
+  }
+
+  // Check for a WriteAttributes Callback
+  if(uic_mqtt_dotdot_unify_fan_control_write_attributes_is_supported(unid, endpoint_id)) {
+    if (first_command == false) {
+      ss << ", ";
+    }
+    first_command = false;
+    ss << R"("WriteAttributes")";
+  }
+
+  // Check for a ForceReadAttributes Callback
+  if (uic_mqtt_dotdot_unify_fan_control_force_read_attributes_is_supported(unid, endpoint_id)) {
+    if (first_command == false) {
+      ss << ", ";
+    }
+    first_command = false;
+    ss << R"("ForceReadAttributes")";
+  }
+
+  // Publish supported commands
+  std::string topic = "ucl/by-unid/" + std::string(unid);
+  topic +=  "/ep"+ std::to_string(endpoint_id);
+  topic +=  "/UnifyFanControl/SupportedCommands";
+  std::string payload_str("{\"value\": [" + ss.str() + "]" + "}");
+  if (first_command == false) {
+    uic_mqtt_publish(topic.c_str(),
+                      payload_str.c_str(),
+                      payload_str.length(),
+                      true);
+  } else if (uic_mqtt_count_topics(topic.c_str()) == 0) {
+    // There are no supported commands, but make sure we publish some
+    // SupportedCommands = [] if any attribute has been published for a cluster.
+    std::string attributes_topic = "ucl/by-unid/" + std::string(unid);
+    attributes_topic +=  "/ep"+ std::to_string(endpoint_id);
+    attributes_topic += "/UnifyFanControl/Attributes";
+
+    if (uic_mqtt_count_topics(attributes_topic.c_str()) > 0) {
+      uic_mqtt_publish(topic.c_str(),
+                      EMPTY_VALUE_ARRAY,
+                      strlen(EMPTY_VALUE_ARRAY),
+                      true);
+    }
+  }
+}
+
+// Publishing empty/no Supported Commands for UnifyFanControl Cluster
+void uic_mqtt_dotdot_unify_fan_control_publish_empty_supported_commands(
+  const dotdot_unid_t unid
+  , dotdot_endpoint_id_t endpoint_id)
+{
+  std::string topic = "ucl/by-unid/" + std::string(unid);
+  topic +=  "/ep"+ std::to_string(endpoint_id);
+  topic +=  "/UnifyFanControl/SupportedCommands";
+
+  if (uic_mqtt_count_topics(topic.c_str()) > 0) {
+    uic_mqtt_publish(topic.c_str(),
+                     EMPTY_VALUE_ARRAY,
+                     strlen(EMPTY_VALUE_ARRAY),
+                     true);
+  }
+}
+
+// Publishing Cluster Revision for UnifyThermostat Cluster
+void uic_mqtt_dotdot_unify_thermostat_publish_cluster_revision(const char* base_topic, uint16_t value)
+{
+  std::string cluster_topic = std::string(base_topic) + "/UnifyThermostat/Attributes/ClusterRevision";
+  // Publish Desired
+  std::string pub_topic_des = cluster_topic + "/Desired";
+  std::string payload = std::string(R"({"value": )")
+    + std::to_string(value) + std::string("}");
+  uic_mqtt_publish(pub_topic_des.c_str(),
+                    payload.c_str(),
+                    payload.size(),
+                    true);
+  // Publish Reported
+  std::string pub_topic_rep = cluster_topic + "/Reported";
+  uic_mqtt_publish(pub_topic_rep.c_str(),
+                    payload.c_str(),
+                    payload.size(),
+                    true);
+}
+
+// Unretain Cluster Revision for UnifyThermostat Cluster
+void uic_mqtt_dotdot_unify_thermostat_unretain_cluster_revision(const char* base_topic)
+{
+  // clang-format on
+  std::string cluster_topic
+    = std::string(base_topic)
+      + "/UnifyThermostat/Attributes/ClusterRevision";
+  // Publish Desired
+  std::string desired_topic = cluster_topic + "/Desired";
+  uic_mqtt_publish(desired_topic.c_str(), NULL, 0, true);
+  // Publish Reported
+  std::string reported_topic = cluster_topic + "/Reported";
+  uic_mqtt_publish(reported_topic.c_str(), NULL, 0, true);
+  // clang-format off
+}
+
+
+static inline bool uic_mqtt_dotdot_unify_thermostat_write_attributes_is_supported(
+  const dotdot_unid_t unid,
+  dotdot_endpoint_id_t endpoint_id)
+{
+  for (const auto& callback: uic_mqtt_dotdot_unify_thermostat_write_attributes_callback) {
+    uic_mqtt_dotdot_unify_thermostat_state_t unify_thermostat_new_state = {};
+    uic_mqtt_dotdot_unify_thermostat_updated_state_t unify_thermostat_new_updated_state = {};
+
+    if (callback(
+          unid,
+          endpoint_id,
+          UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
+          unify_thermostat_new_state,
+          unify_thermostat_new_updated_state
       ) == SL_STATUS_OK) {
       return true;
     }
@@ -109540,17 +111188,17 @@ static inline bool uic_mqtt_dotdot_unify_fan_control_write_attributes_is_support
   return false;
 }
 
-static inline bool uic_mqtt_dotdot_unify_fan_control_force_read_attributes_is_supported(
+static inline bool uic_mqtt_dotdot_unify_thermostat_force_read_attributes_is_supported(
   const dotdot_unid_t unid,
   dotdot_endpoint_id_t endpoint_id)
 {
-  for (const auto& callback: uic_mqtt_dotdot_unify_fan_control_force_read_attributes_callback) {
-    uic_mqtt_dotdot_unify_fan_control_updated_state_t unify_fan_control_force_update = {0};
+  for (const auto& callback: uic_mqtt_dotdot_unify_thermostat_force_read_attributes_callback) {
+    uic_mqtt_dotdot_unify_thermostat_updated_state_t unify_thermostat_force_update = {0};
     if (callback(
           unid,
           endpoint_id,
           UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
-          unify_fan_control_force_update
+          unify_thermostat_force_update
       ) == SL_STATUS_OK) {
       return true;
     }
@@ -109558,8 +111206,8 @@ static inline bool uic_mqtt_dotdot_unify_fan_control_force_read_attributes_is_su
   return false;
 }
 
-// Publishing Supported Commands for UnifyFanControl Cluster
-void uic_mqtt_dotdot_unify_fan_control_publish_supported_commands(
+// Publishing Supported Commands for UnifyThermostat Cluster
+void uic_mqtt_dotdot_unify_thermostat_publish_supported_commands(
   const dotdot_unid_t unid,
   dotdot_endpoint_id_t endpoint_id)
 {
@@ -109568,23 +111216,9 @@ void uic_mqtt_dotdot_unify_fan_control_publish_supported_commands(
   ss.str("");
 
   // check if there is callback for each command
-  if (uic_mqtt_dotdot_unify_fan_control_set_fan_mode_is_supported(unid, endpoint_id)) {
-    if (first_command == false) {
-      ss << ", ";
-    }
-    first_command = false;
-    ss << R"("SetFanMode")";
-  }
-  if (uic_mqtt_dotdot_unify_fan_control_turn_off_is_supported(unid, endpoint_id)) {
-    if (first_command == false) {
-      ss << ", ";
-    }
-    first_command = false;
-    ss << R"("TurnOff")";
-  }
 
   // Check for a WriteAttributes Callback
-  if(uic_mqtt_dotdot_unify_fan_control_write_attributes_is_supported(unid, endpoint_id)) {
+  if(uic_mqtt_dotdot_unify_thermostat_write_attributes_is_supported(unid, endpoint_id)) {
     if (first_command == false) {
       ss << ", ";
     }
@@ -109593,7 +111227,7 @@ void uic_mqtt_dotdot_unify_fan_control_publish_supported_commands(
   }
 
   // Check for a ForceReadAttributes Callback
-  if (uic_mqtt_dotdot_unify_fan_control_force_read_attributes_is_supported(unid, endpoint_id)) {
+  if (uic_mqtt_dotdot_unify_thermostat_force_read_attributes_is_supported(unid, endpoint_id)) {
     if (first_command == false) {
       ss << ", ";
     }
@@ -109604,7 +111238,7 @@ void uic_mqtt_dotdot_unify_fan_control_publish_supported_commands(
   // Publish supported commands
   std::string topic = "ucl/by-unid/" + std::string(unid);
   topic +=  "/ep"+ std::to_string(endpoint_id);
-  topic +=  "/UnifyFanControl/SupportedCommands";
+  topic +=  "/UnifyThermostat/SupportedCommands";
   std::string payload_str("{\"value\": [" + ss.str() + "]" + "}");
   if (first_command == false) {
     uic_mqtt_publish(topic.c_str(),
@@ -109616,7 +111250,7 @@ void uic_mqtt_dotdot_unify_fan_control_publish_supported_commands(
     // SupportedCommands = [] if any attribute has been published for a cluster.
     std::string attributes_topic = "ucl/by-unid/" + std::string(unid);
     attributes_topic +=  "/ep"+ std::to_string(endpoint_id);
-    attributes_topic += "/UnifyFanControl/Attributes";
+    attributes_topic += "/UnifyThermostat/Attributes";
 
     if (uic_mqtt_count_topics(attributes_topic.c_str()) > 0) {
       uic_mqtt_publish(topic.c_str(),
@@ -109627,14 +111261,14 @@ void uic_mqtt_dotdot_unify_fan_control_publish_supported_commands(
   }
 }
 
-// Publishing empty/no Supported Commands for UnifyFanControl Cluster
-void uic_mqtt_dotdot_unify_fan_control_publish_empty_supported_commands(
+// Publishing empty/no Supported Commands for UnifyThermostat Cluster
+void uic_mqtt_dotdot_unify_thermostat_publish_empty_supported_commands(
   const dotdot_unid_t unid
   , dotdot_endpoint_id_t endpoint_id)
 {
   std::string topic = "ucl/by-unid/" + std::string(unid);
   topic +=  "/ep"+ std::to_string(endpoint_id);
-  topic +=  "/UnifyFanControl/SupportedCommands";
+  topic +=  "/UnifyThermostat/SupportedCommands";
 
   if (uic_mqtt_count_topics(topic.c_str()) > 0) {
     uic_mqtt_publish(topic.c_str(),
@@ -109644,10 +111278,10 @@ void uic_mqtt_dotdot_unify_fan_control_publish_empty_supported_commands(
   }
 }
 
-// Publishing Cluster Revision for UnifyThermostat Cluster
-void uic_mqtt_dotdot_unify_thermostat_publish_cluster_revision(const char* base_topic, uint16_t value)
+// Publishing Cluster Revision for UnifyScheduleEntryLock Cluster
+void uic_mqtt_dotdot_unify_schedule_entry_lock_publish_cluster_revision(const char* base_topic, uint16_t value)
 {
-  std::string cluster_topic = std::string(base_topic) + "/UnifyThermostat/Attributes/ClusterRevision";
+  std::string cluster_topic = std::string(base_topic) + "/UnifyScheduleEntryLock/Attributes/ClusterRevision";
   // Publish Desired
   std::string pub_topic_des = cluster_topic + "/Desired";
   std::string payload = std::string(R"({"value": )")
@@ -109664,13 +111298,13 @@ void uic_mqtt_dotdot_unify_thermostat_publish_cluster_revision(const char* base_
                     true);
 }
 
-// Unretain Cluster Revision for UnifyThermostat Cluster
-void uic_mqtt_dotdot_unify_thermostat_unretain_cluster_revision(const char* base_topic)
+// Unretain Cluster Revision for UnifyScheduleEntryLock Cluster
+void uic_mqtt_dotdot_unify_schedule_entry_lock_unretain_cluster_revision(const char* base_topic)
 {
   // clang-format on
   std::string cluster_topic
     = std::string(base_topic)
-      + "/UnifyThermostat/Attributes/ClusterRevision";
+      + "/UnifyScheduleEntryLock/Attributes/ClusterRevision";
   // Publish Desired
   std::string desired_topic = cluster_topic + "/Desired";
   uic_mqtt_publish(desired_topic.c_str(), NULL, 0, true);
@@ -109680,21 +111314,167 @@ void uic_mqtt_dotdot_unify_thermostat_unretain_cluster_revision(const char* base
   // clang-format off
 }
 
+static inline bool uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_week_day_report_is_supported(
+  const dotdot_unid_t unid,
+  dotdot_endpoint_id_t endpoint_id)
+{
+    uint8_t user_identifier_value;
+    memset(&user_identifier_value, 0x00, sizeof(user_identifier_value));
+    uint8_t schedule_slotid_value;
+    memset(&schedule_slotid_value, 0x00, sizeof(schedule_slotid_value));
+    uint8_t day_of_week_value;
+    memset(&day_of_week_value, 0x00, sizeof(day_of_week_value));
+    uint8_t start_hour_value;
+    memset(&start_hour_value, 0x00, sizeof(start_hour_value));
+    uint8_t start_minute_value;
+    memset(&start_minute_value, 0x00, sizeof(start_minute_value));
+    uint8_t stop_hour_value;
+    memset(&stop_hour_value, 0x00, sizeof(stop_hour_value));
+    uint8_t stop_minute_value;
+    memset(&stop_minute_value, 0x00, sizeof(stop_minute_value));
+    for (const auto& callback: uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_week_day_report_callback) {
+      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
+    ,
+        user_identifier_value,
+    
+        schedule_slotid_value,
+    
+        day_of_week_value,
+    
+        start_hour_value,
+    
+        start_minute_value,
+    
+        stop_hour_value,
+    
+        stop_minute_value
+    
+        ) == SL_STATUS_OK) {
+      return true;
+    }
+  }
+
+  return false;
+}
+static inline bool uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_year_day_report_is_supported(
+  const dotdot_unid_t unid,
+  dotdot_endpoint_id_t endpoint_id)
+{
+    uint8_t set_action_value;
+    memset(&set_action_value, 0x00, sizeof(set_action_value));
+    uint8_t user_identifier_value;
+    memset(&user_identifier_value, 0x00, sizeof(user_identifier_value));
+    uint8_t schedule_slotid_value;
+    memset(&schedule_slotid_value, 0x00, sizeof(schedule_slotid_value));
+    uint8_t start_year_value;
+    memset(&start_year_value, 0x00, sizeof(start_year_value));
+    uint8_t start_day_value;
+    memset(&start_day_value, 0x00, sizeof(start_day_value));
+    uint8_t start_hour_value;
+    memset(&start_hour_value, 0x00, sizeof(start_hour_value));
+    uint8_t start_minute_value;
+    memset(&start_minute_value, 0x00, sizeof(start_minute_value));
+    uint8_t stop_year_value;
+    memset(&stop_year_value, 0x00, sizeof(stop_year_value));
+    uint8_t stop_day_value;
+    memset(&stop_day_value, 0x00, sizeof(stop_day_value));
+    uint8_t stop_hour_value;
+    memset(&stop_hour_value, 0x00, sizeof(stop_hour_value));
+    uint8_t stop_minute_value;
+    memset(&stop_minute_value, 0x00, sizeof(stop_minute_value));
+    for (const auto& callback: uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_year_day_report_callback) {
+      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
+    ,
+        set_action_value,
+    
+        user_identifier_value,
+    
+        schedule_slotid_value,
+    
+        start_year_value,
+    
+        start_day_value,
+    
+        start_hour_value,
+    
+        start_minute_value,
+    
+        stop_year_value,
+    
+        stop_day_value,
+    
+        stop_hour_value,
+    
+        stop_minute_value
+    
+        ) == SL_STATUS_OK) {
+      return true;
+    }
+  }
 
-static inline bool uic_mqtt_dotdot_unify_thermostat_write_attributes_is_supported(
+  return false;
+}
+static inline bool uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_daily_repeating_report_is_supported(
   const dotdot_unid_t unid,
   dotdot_endpoint_id_t endpoint_id)
 {
-  for (const auto& callback: uic_mqtt_dotdot_unify_thermostat_write_attributes_callback) {
-    uic_mqtt_dotdot_unify_thermostat_state_t unify_thermostat_new_state = {};
-    uic_mqtt_dotdot_unify_thermostat_updated_state_t unify_thermostat_new_updated_state = {};
+    uint8_t set_action_value;
+    memset(&set_action_value, 0x00, sizeof(set_action_value));
+    uint8_t user_identifier_value;
+    memset(&user_identifier_value, 0x00, sizeof(user_identifier_value));
+    uint8_t schedule_slotid_value;
+    memset(&schedule_slotid_value, 0x00, sizeof(schedule_slotid_value));
+    uint8_t week_day_bitmask_value;
+    memset(&week_day_bitmask_value, 0x00, sizeof(week_day_bitmask_value));
+    uint8_t start_hour_value;
+    memset(&start_hour_value, 0x00, sizeof(start_hour_value));
+    uint8_t start_minute_value;
+    memset(&start_minute_value, 0x00, sizeof(start_minute_value));
+    uint8_t duration_hour_value;
+    memset(&duration_hour_value, 0x00, sizeof(duration_hour_value));
+    uint8_t duration_minute_value;
+    memset(&duration_minute_value, 0x00, sizeof(duration_minute_value));
+    for (const auto& callback: uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_daily_repeating_report_callback) {
+      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
+    ,
+        set_action_value,
+    
+        user_identifier_value,
+    
+        schedule_slotid_value,
+    
+        week_day_bitmask_value,
+    
+        start_hour_value,
+    
+        start_minute_value,
+    
+        duration_hour_value,
+    
+        duration_minute_value
+    
+        ) == SL_STATUS_OK) {
+      return true;
+    }
+  }
+
+  return false;
+}
+
+static inline bool uic_mqtt_dotdot_unify_schedule_entry_lock_write_attributes_is_supported(
+  const dotdot_unid_t unid,
+  dotdot_endpoint_id_t endpoint_id)
+{
+  for (const auto& callback: uic_mqtt_dotdot_unify_schedule_entry_lock_write_attributes_callback) {
+    uic_mqtt_dotdot_unify_schedule_entry_lock_state_t unify_schedule_entry_lock_new_state = {};
+    uic_mqtt_dotdot_unify_schedule_entry_lock_updated_state_t unify_schedule_entry_lock_new_updated_state = {};
 
     if (callback(
           unid,
           endpoint_id,
           UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
-          unify_thermostat_new_state,
-          unify_thermostat_new_updated_state
+          unify_schedule_entry_lock_new_state,
+          unify_schedule_entry_lock_new_updated_state
       ) == SL_STATUS_OK) {
       return true;
     }
@@ -109702,17 +111482,17 @@ static inline bool uic_mqtt_dotdot_unify_thermostat_write_attributes_is_supporte
   return false;
 }
 
-static inline bool uic_mqtt_dotdot_unify_thermostat_force_read_attributes_is_supported(
+static inline bool uic_mqtt_dotdot_unify_schedule_entry_lock_force_read_attributes_is_supported(
   const dotdot_unid_t unid,
   dotdot_endpoint_id_t endpoint_id)
 {
-  for (const auto& callback: uic_mqtt_dotdot_unify_thermostat_force_read_attributes_callback) {
-    uic_mqtt_dotdot_unify_thermostat_updated_state_t unify_thermostat_force_update = {0};
+  for (const auto& callback: uic_mqtt_dotdot_unify_schedule_entry_lock_force_read_attributes_callback) {
+    uic_mqtt_dotdot_unify_schedule_entry_lock_updated_state_t unify_schedule_entry_lock_force_update = {0};
     if (callback(
           unid,
           endpoint_id,
           UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
-          unify_thermostat_force_update
+          unify_schedule_entry_lock_force_update
       ) == SL_STATUS_OK) {
       return true;
     }
@@ -109720,8 +111500,8 @@ static inline bool uic_mqtt_dotdot_unify_thermostat_force_read_attributes_is_sup
   return false;
 }
 
-// Publishing Supported Commands for UnifyThermostat Cluster
-void uic_mqtt_dotdot_unify_thermostat_publish_supported_commands(
+// Publishing Supported Commands for UnifyScheduleEntryLock Cluster
+void uic_mqtt_dotdot_unify_schedule_entry_lock_publish_supported_commands(
   const dotdot_unid_t unid,
   dotdot_endpoint_id_t endpoint_id)
 {
@@ -109730,9 +111510,30 @@ void uic_mqtt_dotdot_unify_thermostat_publish_supported_commands(
   ss.str("");
 
   // check if there is callback for each command
+  if (uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_week_day_report_is_supported(unid, endpoint_id)) {
+    if (first_command == false) {
+      ss << ", ";
+    }
+    first_command = false;
+    ss << R"("ScheduleEntryLockWeekDayReport")";
+  }
+  if (uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_year_day_report_is_supported(unid, endpoint_id)) {
+    if (first_command == false) {
+      ss << ", ";
+    }
+    first_command = false;
+    ss << R"("ScheduleEntryLockYearDayReport")";
+  }
+  if (uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_daily_repeating_report_is_supported(unid, endpoint_id)) {
+    if (first_command == false) {
+      ss << ", ";
+    }
+    first_command = false;
+    ss << R"("ScheduleEntryLockDailyRepeatingReport")";
+  }
 
   // Check for a WriteAttributes Callback
-  if(uic_mqtt_dotdot_unify_thermostat_write_attributes_is_supported(unid, endpoint_id)) {
+  if(uic_mqtt_dotdot_unify_schedule_entry_lock_write_attributes_is_supported(unid, endpoint_id)) {
     if (first_command == false) {
       ss << ", ";
     }
@@ -109741,7 +111542,7 @@ void uic_mqtt_dotdot_unify_thermostat_publish_supported_commands(
   }
 
   // Check for a ForceReadAttributes Callback
-  if (uic_mqtt_dotdot_unify_thermostat_force_read_attributes_is_supported(unid, endpoint_id)) {
+  if (uic_mqtt_dotdot_unify_schedule_entry_lock_force_read_attributes_is_supported(unid, endpoint_id)) {
     if (first_command == false) {
       ss << ", ";
     }
@@ -109752,7 +111553,7 @@ void uic_mqtt_dotdot_unify_thermostat_publish_supported_commands(
   // Publish supported commands
   std::string topic = "ucl/by-unid/" + std::string(unid);
   topic +=  "/ep"+ std::to_string(endpoint_id);
-  topic +=  "/UnifyThermostat/SupportedCommands";
+  topic +=  "/UnifyScheduleEntryLock/SupportedCommands";
   std::string payload_str("{\"value\": [" + ss.str() + "]" + "}");
   if (first_command == false) {
     uic_mqtt_publish(topic.c_str(),
@@ -109764,7 +111565,7 @@ void uic_mqtt_dotdot_unify_thermostat_publish_supported_commands(
     // SupportedCommands = [] if any attribute has been published for a cluster.
     std::string attributes_topic = "ucl/by-unid/" + std::string(unid);
     attributes_topic +=  "/ep"+ std::to_string(endpoint_id);
-    attributes_topic += "/UnifyThermostat/Attributes";
+    attributes_topic += "/UnifyScheduleEntryLock/Attributes";
 
     if (uic_mqtt_count_topics(attributes_topic.c_str()) > 0) {
       uic_mqtt_publish(topic.c_str(),
@@ -109775,14 +111576,14 @@ void uic_mqtt_dotdot_unify_thermostat_publish_supported_commands(
   }
 }
 
-// Publishing empty/no Supported Commands for UnifyThermostat Cluster
-void uic_mqtt_dotdot_unify_thermostat_publish_empty_supported_commands(
+// Publishing empty/no Supported Commands for UnifyScheduleEntryLock Cluster
+void uic_mqtt_dotdot_unify_schedule_entry_lock_publish_empty_supported_commands(
   const dotdot_unid_t unid
   , dotdot_endpoint_id_t endpoint_id)
 {
   std::string topic = "ucl/by-unid/" + std::string(unid);
   topic +=  "/ep"+ std::to_string(endpoint_id);
-  topic +=  "/UnifyThermostat/SupportedCommands";
+  topic +=  "/UnifyScheduleEntryLock/SupportedCommands";
 
   if (uic_mqtt_count_topics(topic.c_str()) > 0) {
     uic_mqtt_publish(topic.c_str(),
@@ -116638,6 +118439,114 @@ void uic_mqtt_dotdot_unify_fan_control_publish_generated_turn_off_command(
                     payload.size(),
                     false);
 }
+/**
+ * @brief Publishes an incoming/generated ScheduleEntryLockWeekDayReport command for
+ * the UnifyScheduleEntryLock cluster.
+ *
+ * Publication will be made at the following topic
+ * ucl/by-unid/UNID/epID/UnifyScheduleEntryLock/GeneratedCommands/ScheduleEntryLockWeekDayReport
+ *
+ * @param unid      The UNID of the node that sent us the command.
+ * 
+ * @param endpoint  The Endpoint ID of the node that sent us the command.
+ * 
+ * 
+ * @param fields                Struct pointer with the fields value of the command
+ * 
+ */
+void uic_mqtt_dotdot_unify_schedule_entry_lock_publish_generated_schedule_entry_lock_week_day_report_command(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint,
+  const uic_mqtt_dotdot_unify_schedule_entry_lock_command_schedule_entry_lock_week_day_report_fields_t *fields
+  
+) {
+  // Create the topic
+  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
+                      std::to_string(endpoint) + "/";
+  topic += "UnifyScheduleEntryLock/GeneratedCommands/ScheduleEntryLockWeekDayReport";
+
+  std::string payload =
+    get_json_payload_for_unify_schedule_entry_lock_schedule_entry_lock_week_day_report_command(
+    fields);
+
+  // Publish our command
+  uic_mqtt_publish(topic.c_str(),
+                    payload.c_str(),
+                    payload.size(),
+                    false);
+}
+/**
+ * @brief Publishes an incoming/generated ScheduleEntryLockYearDayReport command for
+ * the UnifyScheduleEntryLock cluster.
+ *
+ * Publication will be made at the following topic
+ * ucl/by-unid/UNID/epID/UnifyScheduleEntryLock/GeneratedCommands/ScheduleEntryLockYearDayReport
+ *
+ * @param unid      The UNID of the node that sent us the command.
+ * 
+ * @param endpoint  The Endpoint ID of the node that sent us the command.
+ * 
+ * 
+ * @param fields                Struct pointer with the fields value of the command
+ * 
+ */
+void uic_mqtt_dotdot_unify_schedule_entry_lock_publish_generated_schedule_entry_lock_year_day_report_command(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint,
+  const uic_mqtt_dotdot_unify_schedule_entry_lock_command_schedule_entry_lock_year_day_report_fields_t *fields
+  
+) {
+  // Create the topic
+  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
+                      std::to_string(endpoint) + "/";
+  topic += "UnifyScheduleEntryLock/GeneratedCommands/ScheduleEntryLockYearDayReport";
+
+  std::string payload =
+    get_json_payload_for_unify_schedule_entry_lock_schedule_entry_lock_year_day_report_command(
+    fields);
+
+  // Publish our command
+  uic_mqtt_publish(topic.c_str(),
+                    payload.c_str(),
+                    payload.size(),
+                    false);
+}
+/**
+ * @brief Publishes an incoming/generated ScheduleEntryLockDailyRepeatingReport command for
+ * the UnifyScheduleEntryLock cluster.
+ *
+ * Publication will be made at the following topic
+ * ucl/by-unid/UNID/epID/UnifyScheduleEntryLock/GeneratedCommands/ScheduleEntryLockDailyRepeatingReport
+ *
+ * @param unid      The UNID of the node that sent us the command.
+ * 
+ * @param endpoint  The Endpoint ID of the node that sent us the command.
+ * 
+ * 
+ * @param fields                Struct pointer with the fields value of the command
+ * 
+ */
+void uic_mqtt_dotdot_unify_schedule_entry_lock_publish_generated_schedule_entry_lock_daily_repeating_report_command(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint,
+  const uic_mqtt_dotdot_unify_schedule_entry_lock_command_schedule_entry_lock_daily_repeating_report_fields_t *fields
+  
+) {
+  // Create the topic
+  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
+                      std::to_string(endpoint) + "/";
+  topic += "UnifyScheduleEntryLock/GeneratedCommands/ScheduleEntryLockDailyRepeatingReport";
+
+  std::string payload =
+    get_json_payload_for_unify_schedule_entry_lock_schedule_entry_lock_daily_repeating_report_command(
+    fields);
+
+  // Publish our command
+  uic_mqtt_publish(topic.c_str(),
+                    payload.c_str(),
+                    payload.size(),
+                    false);
+}
 /**
  * @brief Publishes an incoming/generated ModeSet command for
  * the UnifyHumidityControl cluster.
diff --git a/components/uic_dotdot_mqtt/zap-generated/src/dotdot_mqtt.hpp b/components/uic_dotdot_mqtt/zap-generated/src/dotdot_mqtt.hpp
index 9fbbc1ede6..bb5785ac9c 100644
--- a/components/uic_dotdot_mqtt/zap-generated/src/dotdot_mqtt.hpp
+++ b/components/uic_dotdot_mqtt/zap-generated/src/dotdot_mqtt.hpp
@@ -371,6 +371,13 @@ sl_status_t uic_mqtt_dotdot_by_group_unify_fan_control_init();
  */
 sl_status_t uic_mqtt_dotdot_by_group_unify_thermostat_init();
 
+/**
+ * @brief Initialize UnifyScheduleEntryLock dotdot bygroup command handlers
+ *
+ * @returns SL_STATUS_OK on success, error otherwise.
+ */
+sl_status_t uic_mqtt_dotdot_by_group_unify_schedule_entry_lock_init();
+
 /**
  * @brief Initialize UnifyHumidityControl dotdot bygroup command handlers
  *
@@ -5063,6 +5070,84 @@ void uic_mqtt_dotdot_on_unify_fan_control_WriteAttributes(
   const size_t message_length);
 
 
+// clang-format on
+
+/**
+ * @brief Retrieves the container with callbacks pointer for
+ * by-unid UnifyScheduleEntryLock/Commands/ScheduleEntryLockWeekDayReport messages
+ *
+ * @returns std::set of callbacks.
+ */
+std::set<uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_week_day_report_callback_t> &get_uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_week_day_report_callback();
+
+/**
+ * @brief MQTT Subscribe handler for incoming publications on:
+ * ucl/by-unid/+/+/UnifyScheduleEntryLock/Commands/ScheduleEntryLockWeekDayReport
+ */
+// clang-format off
+void uic_mqtt_dotdot_on_unify_schedule_entry_lock_schedule_entry_lock_week_day_report(
+  const char *topic,
+  const char *message,
+  const size_t message_length);
+// clang-format on
+
+/**
+ * @brief Retrieves the container with callbacks pointer for
+ * by-unid UnifyScheduleEntryLock/Commands/ScheduleEntryLockYearDayReport messages
+ *
+ * @returns std::set of callbacks.
+ */
+std::set<uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_year_day_report_callback_t> &get_uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_year_day_report_callback();
+
+/**
+ * @brief MQTT Subscribe handler for incoming publications on:
+ * ucl/by-unid/+/+/UnifyScheduleEntryLock/Commands/ScheduleEntryLockYearDayReport
+ */
+// clang-format off
+void uic_mqtt_dotdot_on_unify_schedule_entry_lock_schedule_entry_lock_year_day_report(
+  const char *topic,
+  const char *message,
+  const size_t message_length);
+// clang-format on
+
+/**
+ * @brief Retrieves the container with callbacks pointer for
+ * by-unid UnifyScheduleEntryLock/Commands/ScheduleEntryLockDailyRepeatingReport messages
+ *
+ * @returns std::set of callbacks.
+ */
+std::set<uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_daily_repeating_report_callback_t> &get_uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_daily_repeating_report_callback();
+
+/**
+ * @brief MQTT Subscribe handler for incoming publications on:
+ * ucl/by-unid/+/+/UnifyScheduleEntryLock/Commands/ScheduleEntryLockDailyRepeatingReport
+ */
+// clang-format off
+void uic_mqtt_dotdot_on_unify_schedule_entry_lock_schedule_entry_lock_daily_repeating_report(
+  const char *topic,
+  const char *message,
+  const size_t message_length);
+// clang-format on
+
+/**
+ * @brief Retrieves the container with callback pointers for by-unid
+ * /Commands/WriteAttributes messages
+ *
+ * @returns std::set of callbacks.
+ */
+std::set<uic_mqtt_dotdot_unify_schedule_entry_lock_write_attributes_callback_t> & get_uic_mqtt_dotdot_unify_schedule_entry_lock_write_attributes_callback();
+
+/**
+ * @brief MQTT Subscribe handler for incoming publications on:
+ * ucl/by-unid/+/+/UnifyScheduleEntryLock/Commands/WriteAttributes
+ */
+// clang-format off
+void uic_mqtt_dotdot_on_unify_schedule_entry_lock_WriteAttributes(
+  const char *topic,
+  const char *message,
+  const size_t message_length);
+
+
 // clang-format on
 
 /**
diff --git a/components/uic_dotdot_mqtt/zap-generated/src/dotdot_mqtt_attributes.cpp b/components/uic_dotdot_mqtt/zap-generated/src/dotdot_mqtt_attributes.cpp
index 25ce61e26a..d83f8e50ea 100644
--- a/components/uic_dotdot_mqtt/zap-generated/src/dotdot_mqtt_attributes.cpp
+++ b/components/uic_dotdot_mqtt/zap-generated/src/dotdot_mqtt_attributes.cpp
@@ -62164,6 +62164,713 @@ void uic_mqtt_dotdot_unify_thermostat_attribute_operating_state_callback_set(con
 
 // End of supported cluster.
 
+///////////////////////////////////////////////////////////////////////////////
+// Callback pointers for UnifyScheduleEntryLock
+///////////////////////////////////////////////////////////////////////////////
+static uic_mqtt_dotdot_unify_schedule_entry_lock_attribute_slots_week_day_callback_t uic_mqtt_dotdot_unify_schedule_entry_lock_attribute_slots_week_day_callback = nullptr;
+static uic_mqtt_dotdot_unify_schedule_entry_lock_attribute_slots_year_day_callback_t uic_mqtt_dotdot_unify_schedule_entry_lock_attribute_slots_year_day_callback = nullptr;
+static uic_mqtt_dotdot_unify_schedule_entry_lock_attribute_signtzo_callback_t uic_mqtt_dotdot_unify_schedule_entry_lock_attribute_signtzo_callback = nullptr;
+static uic_mqtt_dotdot_unify_schedule_entry_lock_attribute_hourtzo_callback_t uic_mqtt_dotdot_unify_schedule_entry_lock_attribute_hourtzo_callback = nullptr;
+static uic_mqtt_dotdot_unify_schedule_entry_lock_attribute_minutetzo_callback_t uic_mqtt_dotdot_unify_schedule_entry_lock_attribute_minutetzo_callback = nullptr;
+static uic_mqtt_dotdot_unify_schedule_entry_lock_attribute_dst_offset_sign_callback_t uic_mqtt_dotdot_unify_schedule_entry_lock_attribute_dst_offset_sign_callback = nullptr;
+static uic_mqtt_dotdot_unify_schedule_entry_lock_attribute_dst_offset_minute_callback_t uic_mqtt_dotdot_unify_schedule_entry_lock_attribute_dst_offset_minute_callback = nullptr;
+static uic_mqtt_dotdot_unify_schedule_entry_lock_attribute_number_of_slots_daily_repeating_callback_t uic_mqtt_dotdot_unify_schedule_entry_lock_attribute_number_of_slots_daily_repeating_callback = nullptr;
+
+///////////////////////////////////////////////////////////////////////////////
+// Attribute update handlers for UnifyScheduleEntryLock
+///////////////////////////////////////////////////////////////////////////////
+static void uic_mqtt_dotdot_on_unify_schedule_entry_lock_slots_week_day_attribute_update(
+  const char *topic,
+  const char *message,
+  const size_t message_length) {
+  if (uic_mqtt_dotdot_unify_schedule_entry_lock_attribute_slots_week_day_callback == nullptr) {
+    return;
+  }
+
+  std::string unid;
+  uint8_t endpoint = 0; // Default value for endpoint-less topics.
+  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
+    sl_log_debug(LOG_TAG,
+                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
+                topic);
+    return;
+  }
+
+  std::string last_item;
+  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
+    sl_log_debug(LOG_TAG,
+                "Error parsing last item from topic %s. Ignoring",
+                topic);
+    return;
+  }
+
+  uic_mqtt_dotdot_attribute_update_type_t update_type;
+  if (last_item == "Reported") {
+    update_type = UCL_REPORTED_UPDATED;
+  } else if (last_item == "Desired") {
+    update_type = UCL_DESIRED_UPDATED;
+  } else {
+    sl_log_debug(LOG_TAG,
+                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
+                topic);
+    return;
+  }
+
+  // Empty message means unretained value.
+  bool unretained = false;
+  if (message_length == 0) {
+    unretained = true;
+  }
+
+
+  uint8_t slots_week_day = {};
+
+  nlohmann::json json_payload;
+  try {
+
+    if (unretained == false) {
+      json_payload = nlohmann::json::parse(std::string(message));
+
+      if (json_payload.find("value") == json_payload.end()) {
+        sl_log_debug(LOG_TAG, "UnifyScheduleEntryLock::SlotsWeekDay: Missing attribute element: 'value'\n");
+        return;
+      }
+// Start parsing value
+      slots_week_day = json_payload.at("value").get<uint8_t>();
+    
+    // End parsing value
+    }
+
+  } catch (const std::exception& e) {
+    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
+    return;
+  }
+
+  uic_mqtt_dotdot_unify_schedule_entry_lock_attribute_slots_week_day_callback(
+    static_cast<dotdot_unid_t>(unid.c_str()),
+    endpoint,
+    unretained,
+    update_type,
+    slots_week_day
+  );
+
+}
+static void uic_mqtt_dotdot_on_unify_schedule_entry_lock_slots_year_day_attribute_update(
+  const char *topic,
+  const char *message,
+  const size_t message_length) {
+  if (uic_mqtt_dotdot_unify_schedule_entry_lock_attribute_slots_year_day_callback == nullptr) {
+    return;
+  }
+
+  std::string unid;
+  uint8_t endpoint = 0; // Default value for endpoint-less topics.
+  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
+    sl_log_debug(LOG_TAG,
+                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
+                topic);
+    return;
+  }
+
+  std::string last_item;
+  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
+    sl_log_debug(LOG_TAG,
+                "Error parsing last item from topic %s. Ignoring",
+                topic);
+    return;
+  }
+
+  uic_mqtt_dotdot_attribute_update_type_t update_type;
+  if (last_item == "Reported") {
+    update_type = UCL_REPORTED_UPDATED;
+  } else if (last_item == "Desired") {
+    update_type = UCL_DESIRED_UPDATED;
+  } else {
+    sl_log_debug(LOG_TAG,
+                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
+                topic);
+    return;
+  }
+
+  // Empty message means unretained value.
+  bool unretained = false;
+  if (message_length == 0) {
+    unretained = true;
+  }
+
+
+  uint8_t slots_year_day = {};
+
+  nlohmann::json json_payload;
+  try {
+
+    if (unretained == false) {
+      json_payload = nlohmann::json::parse(std::string(message));
+
+      if (json_payload.find("value") == json_payload.end()) {
+        sl_log_debug(LOG_TAG, "UnifyScheduleEntryLock::SlotsYearDay: Missing attribute element: 'value'\n");
+        return;
+      }
+// Start parsing value
+      slots_year_day = json_payload.at("value").get<uint8_t>();
+    
+    // End parsing value
+    }
+
+  } catch (const std::exception& e) {
+    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
+    return;
+  }
+
+  uic_mqtt_dotdot_unify_schedule_entry_lock_attribute_slots_year_day_callback(
+    static_cast<dotdot_unid_t>(unid.c_str()),
+    endpoint,
+    unretained,
+    update_type,
+    slots_year_day
+  );
+
+}
+static void uic_mqtt_dotdot_on_unify_schedule_entry_lock_signtzo_attribute_update(
+  const char *topic,
+  const char *message,
+  const size_t message_length) {
+  if (uic_mqtt_dotdot_unify_schedule_entry_lock_attribute_signtzo_callback == nullptr) {
+    return;
+  }
+
+  std::string unid;
+  uint8_t endpoint = 0; // Default value for endpoint-less topics.
+  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
+    sl_log_debug(LOG_TAG,
+                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
+                topic);
+    return;
+  }
+
+  std::string last_item;
+  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
+    sl_log_debug(LOG_TAG,
+                "Error parsing last item from topic %s. Ignoring",
+                topic);
+    return;
+  }
+
+  uic_mqtt_dotdot_attribute_update_type_t update_type;
+  if (last_item == "Reported") {
+    update_type = UCL_REPORTED_UPDATED;
+  } else if (last_item == "Desired") {
+    update_type = UCL_DESIRED_UPDATED;
+  } else {
+    sl_log_debug(LOG_TAG,
+                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
+                topic);
+    return;
+  }
+
+  // Empty message means unretained value.
+  bool unretained = false;
+  if (message_length == 0) {
+    unretained = true;
+  }
+
+
+  uint8_t signtzo = {};
+
+  nlohmann::json json_payload;
+  try {
+
+    if (unretained == false) {
+      json_payload = nlohmann::json::parse(std::string(message));
+
+      if (json_payload.find("value") == json_payload.end()) {
+        sl_log_debug(LOG_TAG, "UnifyScheduleEntryLock::SignTZO: Missing attribute element: 'value'\n");
+        return;
+      }
+// Start parsing value
+      signtzo = json_payload.at("value").get<uint8_t>();
+    
+    // End parsing value
+    }
+
+  } catch (const std::exception& e) {
+    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
+    return;
+  }
+
+  uic_mqtt_dotdot_unify_schedule_entry_lock_attribute_signtzo_callback(
+    static_cast<dotdot_unid_t>(unid.c_str()),
+    endpoint,
+    unretained,
+    update_type,
+    signtzo
+  );
+
+}
+static void uic_mqtt_dotdot_on_unify_schedule_entry_lock_hourtzo_attribute_update(
+  const char *topic,
+  const char *message,
+  const size_t message_length) {
+  if (uic_mqtt_dotdot_unify_schedule_entry_lock_attribute_hourtzo_callback == nullptr) {
+    return;
+  }
+
+  std::string unid;
+  uint8_t endpoint = 0; // Default value for endpoint-less topics.
+  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
+    sl_log_debug(LOG_TAG,
+                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
+                topic);
+    return;
+  }
+
+  std::string last_item;
+  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
+    sl_log_debug(LOG_TAG,
+                "Error parsing last item from topic %s. Ignoring",
+                topic);
+    return;
+  }
+
+  uic_mqtt_dotdot_attribute_update_type_t update_type;
+  if (last_item == "Reported") {
+    update_type = UCL_REPORTED_UPDATED;
+  } else if (last_item == "Desired") {
+    update_type = UCL_DESIRED_UPDATED;
+  } else {
+    sl_log_debug(LOG_TAG,
+                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
+                topic);
+    return;
+  }
+
+  // Empty message means unretained value.
+  bool unretained = false;
+  if (message_length == 0) {
+    unretained = true;
+  }
+
+
+  uint8_t hourtzo = {};
+
+  nlohmann::json json_payload;
+  try {
+
+    if (unretained == false) {
+      json_payload = nlohmann::json::parse(std::string(message));
+
+      if (json_payload.find("value") == json_payload.end()) {
+        sl_log_debug(LOG_TAG, "UnifyScheduleEntryLock::HourTZO: Missing attribute element: 'value'\n");
+        return;
+      }
+// Start parsing value
+      hourtzo = json_payload.at("value").get<uint8_t>();
+    
+    // End parsing value
+    }
+
+  } catch (const std::exception& e) {
+    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
+    return;
+  }
+
+  uic_mqtt_dotdot_unify_schedule_entry_lock_attribute_hourtzo_callback(
+    static_cast<dotdot_unid_t>(unid.c_str()),
+    endpoint,
+    unretained,
+    update_type,
+    hourtzo
+  );
+
+}
+static void uic_mqtt_dotdot_on_unify_schedule_entry_lock_minutetzo_attribute_update(
+  const char *topic,
+  const char *message,
+  const size_t message_length) {
+  if (uic_mqtt_dotdot_unify_schedule_entry_lock_attribute_minutetzo_callback == nullptr) {
+    return;
+  }
+
+  std::string unid;
+  uint8_t endpoint = 0; // Default value for endpoint-less topics.
+  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
+    sl_log_debug(LOG_TAG,
+                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
+                topic);
+    return;
+  }
+
+  std::string last_item;
+  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
+    sl_log_debug(LOG_TAG,
+                "Error parsing last item from topic %s. Ignoring",
+                topic);
+    return;
+  }
+
+  uic_mqtt_dotdot_attribute_update_type_t update_type;
+  if (last_item == "Reported") {
+    update_type = UCL_REPORTED_UPDATED;
+  } else if (last_item == "Desired") {
+    update_type = UCL_DESIRED_UPDATED;
+  } else {
+    sl_log_debug(LOG_TAG,
+                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
+                topic);
+    return;
+  }
+
+  // Empty message means unretained value.
+  bool unretained = false;
+  if (message_length == 0) {
+    unretained = true;
+  }
+
+
+  uint8_t minutetzo = {};
+
+  nlohmann::json json_payload;
+  try {
+
+    if (unretained == false) {
+      json_payload = nlohmann::json::parse(std::string(message));
+
+      if (json_payload.find("value") == json_payload.end()) {
+        sl_log_debug(LOG_TAG, "UnifyScheduleEntryLock::MinuteTZO: Missing attribute element: 'value'\n");
+        return;
+      }
+// Start parsing value
+      minutetzo = json_payload.at("value").get<uint8_t>();
+    
+    // End parsing value
+    }
+
+  } catch (const std::exception& e) {
+    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
+    return;
+  }
+
+  uic_mqtt_dotdot_unify_schedule_entry_lock_attribute_minutetzo_callback(
+    static_cast<dotdot_unid_t>(unid.c_str()),
+    endpoint,
+    unretained,
+    update_type,
+    minutetzo
+  );
+
+}
+static void uic_mqtt_dotdot_on_unify_schedule_entry_lock_dst_offset_sign_attribute_update(
+  const char *topic,
+  const char *message,
+  const size_t message_length) {
+  if (uic_mqtt_dotdot_unify_schedule_entry_lock_attribute_dst_offset_sign_callback == nullptr) {
+    return;
+  }
+
+  std::string unid;
+  uint8_t endpoint = 0; // Default value for endpoint-less topics.
+  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
+    sl_log_debug(LOG_TAG,
+                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
+                topic);
+    return;
+  }
+
+  std::string last_item;
+  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
+    sl_log_debug(LOG_TAG,
+                "Error parsing last item from topic %s. Ignoring",
+                topic);
+    return;
+  }
+
+  uic_mqtt_dotdot_attribute_update_type_t update_type;
+  if (last_item == "Reported") {
+    update_type = UCL_REPORTED_UPDATED;
+  } else if (last_item == "Desired") {
+    update_type = UCL_DESIRED_UPDATED;
+  } else {
+    sl_log_debug(LOG_TAG,
+                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
+                topic);
+    return;
+  }
+
+  // Empty message means unretained value.
+  bool unretained = false;
+  if (message_length == 0) {
+    unretained = true;
+  }
+
+
+  uint8_t dst_offset_sign = {};
+
+  nlohmann::json json_payload;
+  try {
+
+    if (unretained == false) {
+      json_payload = nlohmann::json::parse(std::string(message));
+
+      if (json_payload.find("value") == json_payload.end()) {
+        sl_log_debug(LOG_TAG, "UnifyScheduleEntryLock::DSTOffsetSign: Missing attribute element: 'value'\n");
+        return;
+      }
+// Start parsing value
+      dst_offset_sign = json_payload.at("value").get<uint8_t>();
+    
+    // End parsing value
+    }
+
+  } catch (const std::exception& e) {
+    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
+    return;
+  }
+
+  uic_mqtt_dotdot_unify_schedule_entry_lock_attribute_dst_offset_sign_callback(
+    static_cast<dotdot_unid_t>(unid.c_str()),
+    endpoint,
+    unretained,
+    update_type,
+    dst_offset_sign
+  );
+
+}
+static void uic_mqtt_dotdot_on_unify_schedule_entry_lock_dst_offset_minute_attribute_update(
+  const char *topic,
+  const char *message,
+  const size_t message_length) {
+  if (uic_mqtt_dotdot_unify_schedule_entry_lock_attribute_dst_offset_minute_callback == nullptr) {
+    return;
+  }
+
+  std::string unid;
+  uint8_t endpoint = 0; // Default value for endpoint-less topics.
+  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
+    sl_log_debug(LOG_TAG,
+                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
+                topic);
+    return;
+  }
+
+  std::string last_item;
+  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
+    sl_log_debug(LOG_TAG,
+                "Error parsing last item from topic %s. Ignoring",
+                topic);
+    return;
+  }
+
+  uic_mqtt_dotdot_attribute_update_type_t update_type;
+  if (last_item == "Reported") {
+    update_type = UCL_REPORTED_UPDATED;
+  } else if (last_item == "Desired") {
+    update_type = UCL_DESIRED_UPDATED;
+  } else {
+    sl_log_debug(LOG_TAG,
+                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
+                topic);
+    return;
+  }
+
+  // Empty message means unretained value.
+  bool unretained = false;
+  if (message_length == 0) {
+    unretained = true;
+  }
+
+
+  uint8_t dst_offset_minute = {};
+
+  nlohmann::json json_payload;
+  try {
+
+    if (unretained == false) {
+      json_payload = nlohmann::json::parse(std::string(message));
+
+      if (json_payload.find("value") == json_payload.end()) {
+        sl_log_debug(LOG_TAG, "UnifyScheduleEntryLock::DSTOffsetMinute: Missing attribute element: 'value'\n");
+        return;
+      }
+// Start parsing value
+      dst_offset_minute = json_payload.at("value").get<uint8_t>();
+    
+    // End parsing value
+    }
+
+  } catch (const std::exception& e) {
+    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
+    return;
+  }
+
+  uic_mqtt_dotdot_unify_schedule_entry_lock_attribute_dst_offset_minute_callback(
+    static_cast<dotdot_unid_t>(unid.c_str()),
+    endpoint,
+    unretained,
+    update_type,
+    dst_offset_minute
+  );
+
+}
+static void uic_mqtt_dotdot_on_unify_schedule_entry_lock_number_of_slots_daily_repeating_attribute_update(
+  const char *topic,
+  const char *message,
+  const size_t message_length) {
+  if (uic_mqtt_dotdot_unify_schedule_entry_lock_attribute_number_of_slots_daily_repeating_callback == nullptr) {
+    return;
+  }
+
+  std::string unid;
+  uint8_t endpoint = 0; // Default value for endpoint-less topics.
+  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
+    sl_log_debug(LOG_TAG,
+                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
+                topic);
+    return;
+  }
+
+  std::string last_item;
+  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
+    sl_log_debug(LOG_TAG,
+                "Error parsing last item from topic %s. Ignoring",
+                topic);
+    return;
+  }
+
+  uic_mqtt_dotdot_attribute_update_type_t update_type;
+  if (last_item == "Reported") {
+    update_type = UCL_REPORTED_UPDATED;
+  } else if (last_item == "Desired") {
+    update_type = UCL_DESIRED_UPDATED;
+  } else {
+    sl_log_debug(LOG_TAG,
+                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
+                topic);
+    return;
+  }
+
+  // Empty message means unretained value.
+  bool unretained = false;
+  if (message_length == 0) {
+    unretained = true;
+  }
+
+
+  uint8_t number_of_slots_daily_repeating = {};
+
+  nlohmann::json json_payload;
+  try {
+
+    if (unretained == false) {
+      json_payload = nlohmann::json::parse(std::string(message));
+
+      if (json_payload.find("value") == json_payload.end()) {
+        sl_log_debug(LOG_TAG, "UnifyScheduleEntryLock::NumberOfSlotsDailyRepeating: Missing attribute element: 'value'\n");
+        return;
+      }
+// Start parsing value
+      number_of_slots_daily_repeating = json_payload.at("value").get<uint8_t>();
+    
+    // End parsing value
+    }
+
+  } catch (const std::exception& e) {
+    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
+    return;
+  }
+
+  uic_mqtt_dotdot_unify_schedule_entry_lock_attribute_number_of_slots_daily_repeating_callback(
+    static_cast<dotdot_unid_t>(unid.c_str()),
+    endpoint,
+    unretained,
+    update_type,
+    number_of_slots_daily_repeating
+  );
+
+}
+
+///////////////////////////////////////////////////////////////////////////////
+// Attribute init functions for UnifyScheduleEntryLock
+///////////////////////////////////////////////////////////////////////////////
+sl_status_t uic_mqtt_dotdot_unify_schedule_entry_lock_attributes_init()
+{
+  std::string base_topic = "ucl/by-unid/+/+/";
+
+  std::string subscription_topic;
+  if(uic_mqtt_dotdot_unify_schedule_entry_lock_attribute_slots_week_day_callback) {
+    subscription_topic = base_topic + "UnifyScheduleEntryLock/Attributes/SlotsWeekDay/#";
+    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_unify_schedule_entry_lock_slots_week_day_attribute_update);
+  }
+  if(uic_mqtt_dotdot_unify_schedule_entry_lock_attribute_slots_year_day_callback) {
+    subscription_topic = base_topic + "UnifyScheduleEntryLock/Attributes/SlotsYearDay/#";
+    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_unify_schedule_entry_lock_slots_year_day_attribute_update);
+  }
+  if(uic_mqtt_dotdot_unify_schedule_entry_lock_attribute_signtzo_callback) {
+    subscription_topic = base_topic + "UnifyScheduleEntryLock/Attributes/SignTZO/#";
+    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_unify_schedule_entry_lock_signtzo_attribute_update);
+  }
+  if(uic_mqtt_dotdot_unify_schedule_entry_lock_attribute_hourtzo_callback) {
+    subscription_topic = base_topic + "UnifyScheduleEntryLock/Attributes/HourTZO/#";
+    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_unify_schedule_entry_lock_hourtzo_attribute_update);
+  }
+  if(uic_mqtt_dotdot_unify_schedule_entry_lock_attribute_minutetzo_callback) {
+    subscription_topic = base_topic + "UnifyScheduleEntryLock/Attributes/MinuteTZO/#";
+    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_unify_schedule_entry_lock_minutetzo_attribute_update);
+  }
+  if(uic_mqtt_dotdot_unify_schedule_entry_lock_attribute_dst_offset_sign_callback) {
+    subscription_topic = base_topic + "UnifyScheduleEntryLock/Attributes/DSTOffsetSign/#";
+    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_unify_schedule_entry_lock_dst_offset_sign_attribute_update);
+  }
+  if(uic_mqtt_dotdot_unify_schedule_entry_lock_attribute_dst_offset_minute_callback) {
+    subscription_topic = base_topic + "UnifyScheduleEntryLock/Attributes/DSTOffsetMinute/#";
+    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_unify_schedule_entry_lock_dst_offset_minute_attribute_update);
+  }
+  if(uic_mqtt_dotdot_unify_schedule_entry_lock_attribute_number_of_slots_daily_repeating_callback) {
+    subscription_topic = base_topic + "UnifyScheduleEntryLock/Attributes/NumberOfSlotsDailyRepeating/#";
+    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_unify_schedule_entry_lock_number_of_slots_daily_repeating_attribute_update);
+  }
+
+  return SL_STATUS_OK;
+}
+
+
+///////////////////////////////////////////////////////////////////////////////
+// Callback setters and getters for UnifyScheduleEntryLock
+///////////////////////////////////////////////////////////////////////////////
+void uic_mqtt_dotdot_unify_schedule_entry_lock_attribute_slots_week_day_callback_set(const uic_mqtt_dotdot_unify_schedule_entry_lock_attribute_slots_week_day_callback_t callback)
+{
+  uic_mqtt_dotdot_unify_schedule_entry_lock_attribute_slots_week_day_callback = callback;
+}
+void uic_mqtt_dotdot_unify_schedule_entry_lock_attribute_slots_year_day_callback_set(const uic_mqtt_dotdot_unify_schedule_entry_lock_attribute_slots_year_day_callback_t callback)
+{
+  uic_mqtt_dotdot_unify_schedule_entry_lock_attribute_slots_year_day_callback = callback;
+}
+void uic_mqtt_dotdot_unify_schedule_entry_lock_attribute_signtzo_callback_set(const uic_mqtt_dotdot_unify_schedule_entry_lock_attribute_signtzo_callback_t callback)
+{
+  uic_mqtt_dotdot_unify_schedule_entry_lock_attribute_signtzo_callback = callback;
+}
+void uic_mqtt_dotdot_unify_schedule_entry_lock_attribute_hourtzo_callback_set(const uic_mqtt_dotdot_unify_schedule_entry_lock_attribute_hourtzo_callback_t callback)
+{
+  uic_mqtt_dotdot_unify_schedule_entry_lock_attribute_hourtzo_callback = callback;
+}
+void uic_mqtt_dotdot_unify_schedule_entry_lock_attribute_minutetzo_callback_set(const uic_mqtt_dotdot_unify_schedule_entry_lock_attribute_minutetzo_callback_t callback)
+{
+  uic_mqtt_dotdot_unify_schedule_entry_lock_attribute_minutetzo_callback = callback;
+}
+void uic_mqtt_dotdot_unify_schedule_entry_lock_attribute_dst_offset_sign_callback_set(const uic_mqtt_dotdot_unify_schedule_entry_lock_attribute_dst_offset_sign_callback_t callback)
+{
+  uic_mqtt_dotdot_unify_schedule_entry_lock_attribute_dst_offset_sign_callback = callback;
+}
+void uic_mqtt_dotdot_unify_schedule_entry_lock_attribute_dst_offset_minute_callback_set(const uic_mqtt_dotdot_unify_schedule_entry_lock_attribute_dst_offset_minute_callback_t callback)
+{
+  uic_mqtt_dotdot_unify_schedule_entry_lock_attribute_dst_offset_minute_callback = callback;
+}
+void uic_mqtt_dotdot_unify_schedule_entry_lock_attribute_number_of_slots_daily_repeating_callback_set(const uic_mqtt_dotdot_unify_schedule_entry_lock_attribute_number_of_slots_daily_repeating_callback_t callback)
+{
+  uic_mqtt_dotdot_unify_schedule_entry_lock_attribute_number_of_slots_daily_repeating_callback = callback;
+}
+
+// End of supported cluster.
+
 ///////////////////////////////////////////////////////////////////////////////
 // Callback pointers for UnifyHumidityControl
 ///////////////////////////////////////////////////////////////////////////////
diff --git a/components/uic_dotdot_mqtt/zap-generated/src/dotdot_mqtt_command_helpers.cpp b/components/uic_dotdot_mqtt/zap-generated/src/dotdot_mqtt_command_helpers.cpp
index 25c2c2aced..0c1e90c9d9 100644
--- a/components/uic_dotdot_mqtt/zap-generated/src/dotdot_mqtt_command_helpers.cpp
+++ b/components/uic_dotdot_mqtt/zap-generated/src/dotdot_mqtt_command_helpers.cpp
@@ -14523,6 +14523,468 @@ void uic_mqtt_dotdot_parse_unify_thermostat_write_attributes(
 }
 
 
+std::string get_json_payload_for_unify_schedule_entry_lock_schedule_entry_lock_week_day_report_command(
+  
+  const uic_mqtt_dotdot_unify_schedule_entry_lock_command_schedule_entry_lock_week_day_report_fields_t *fields
+  
+){
+  bool command_with_no_fields = true;
+
+  // Create a JSON payload from all the parameters
+  nlohmann::json json_payload;
+  command_with_no_fields = false;
+  // Single Value
+  // Non-enum and non-bitmask (struct, string or scalar)
+  json_payload["UserIdentifier"] = nlohmann::json(fields->user_identifier);
+  command_with_no_fields = false;
+  // Single Value
+  // Non-enum and non-bitmask (struct, string or scalar)
+  json_payload["ScheduleSlotID"] = nlohmann::json(fields->schedule_slotid);
+  command_with_no_fields = false;
+  // Single Value
+  // Non-enum and non-bitmask (struct, string or scalar)
+  json_payload["DayOfWeek"] = nlohmann::json(fields->day_of_week);
+  command_with_no_fields = false;
+  // Single Value
+  // Non-enum and non-bitmask (struct, string or scalar)
+  json_payload["StartHour"] = nlohmann::json(fields->start_hour);
+  command_with_no_fields = false;
+  // Single Value
+  // Non-enum and non-bitmask (struct, string or scalar)
+  json_payload["StartMinute"] = nlohmann::json(fields->start_minute);
+  command_with_no_fields = false;
+  // Single Value
+  // Non-enum and non-bitmask (struct, string or scalar)
+  json_payload["StopHour"] = nlohmann::json(fields->stop_hour);
+  command_with_no_fields = false;
+  // Single Value
+  // Non-enum and non-bitmask (struct, string or scalar)
+  json_payload["StopMinute"] = nlohmann::json(fields->stop_minute);
+
+  // Get the string
+  if (command_with_no_fields == true) {
+    return std::string("{}");
+  }
+  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
+  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
+}
+
+
+void uic_mqtt_dotdot_parse_unify_schedule_entry_lock_schedule_entry_lock_week_day_report(
+  nlohmann::json &jsn,
+  uint8_t &user_identifier,
+  
+  uint8_t &schedule_slotid,
+  
+  uint8_t &day_of_week,
+  
+  uint8_t &start_hour,
+  
+  uint8_t &start_minute,
+  
+  uint8_t &stop_hour,
+  
+  uint8_t &stop_minute
+  
+) {
+
+  if (jsn.at("UserIdentifier").is_null()) {
+    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
+    return;
+  }
+        
+  user_identifier = jsn.at("UserIdentifier").get< uint8_t >();
+      if (jsn.at("ScheduleSlotID").is_null()) {
+    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
+    return;
+  }
+        
+  schedule_slotid = jsn.at("ScheduleSlotID").get< uint8_t >();
+      if (jsn.at("DayOfWeek").is_null()) {
+    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
+    return;
+  }
+        
+  day_of_week = jsn.at("DayOfWeek").get< uint8_t >();
+      if (jsn.at("StartHour").is_null()) {
+    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
+    return;
+  }
+        
+  start_hour = jsn.at("StartHour").get< uint8_t >();
+      if (jsn.at("StartMinute").is_null()) {
+    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
+    return;
+  }
+        
+  start_minute = jsn.at("StartMinute").get< uint8_t >();
+      if (jsn.at("StopHour").is_null()) {
+    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
+    return;
+  }
+        
+  stop_hour = jsn.at("StopHour").get< uint8_t >();
+      if (jsn.at("StopMinute").is_null()) {
+    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
+    return;
+  }
+        
+  stop_minute = jsn.at("StopMinute").get< uint8_t >();
+    }
+
+
+std::string get_json_payload_for_unify_schedule_entry_lock_schedule_entry_lock_year_day_report_command(
+  
+  const uic_mqtt_dotdot_unify_schedule_entry_lock_command_schedule_entry_lock_year_day_report_fields_t *fields
+  
+){
+  bool command_with_no_fields = true;
+
+  // Create a JSON payload from all the parameters
+  nlohmann::json json_payload;
+  command_with_no_fields = false;
+  // Single Value
+  // Non-enum and non-bitmask (struct, string or scalar)
+  json_payload["SetAction"] = nlohmann::json(fields->set_action);
+  command_with_no_fields = false;
+  // Single Value
+  // Non-enum and non-bitmask (struct, string or scalar)
+  json_payload["UserIdentifier"] = nlohmann::json(fields->user_identifier);
+  command_with_no_fields = false;
+  // Single Value
+  // Non-enum and non-bitmask (struct, string or scalar)
+  json_payload["ScheduleSlotID"] = nlohmann::json(fields->schedule_slotid);
+  command_with_no_fields = false;
+  // Single Value
+  // Non-enum and non-bitmask (struct, string or scalar)
+  json_payload["StartYear"] = nlohmann::json(fields->start_year);
+  command_with_no_fields = false;
+  // Single Value
+  // Non-enum and non-bitmask (struct, string or scalar)
+  json_payload["StartDay"] = nlohmann::json(fields->start_day);
+  command_with_no_fields = false;
+  // Single Value
+  // Non-enum and non-bitmask (struct, string or scalar)
+  json_payload["StartHour"] = nlohmann::json(fields->start_hour);
+  command_with_no_fields = false;
+  // Single Value
+  // Non-enum and non-bitmask (struct, string or scalar)
+  json_payload["StartMinute"] = nlohmann::json(fields->start_minute);
+  command_with_no_fields = false;
+  // Single Value
+  // Non-enum and non-bitmask (struct, string or scalar)
+  json_payload["StopYear"] = nlohmann::json(fields->stop_year);
+  command_with_no_fields = false;
+  // Single Value
+  // Non-enum and non-bitmask (struct, string or scalar)
+  json_payload["StopDay"] = nlohmann::json(fields->stop_day);
+  command_with_no_fields = false;
+  // Single Value
+  // Non-enum and non-bitmask (struct, string or scalar)
+  json_payload["StopHour"] = nlohmann::json(fields->stop_hour);
+  command_with_no_fields = false;
+  // Single Value
+  // Non-enum and non-bitmask (struct, string or scalar)
+  json_payload["StopMinute"] = nlohmann::json(fields->stop_minute);
+
+  // Get the string
+  if (command_with_no_fields == true) {
+    return std::string("{}");
+  }
+  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
+  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
+}
+
+
+void uic_mqtt_dotdot_parse_unify_schedule_entry_lock_schedule_entry_lock_year_day_report(
+  nlohmann::json &jsn,
+  uint8_t &set_action,
+  
+  uint8_t &user_identifier,
+  
+  uint8_t &schedule_slotid,
+  
+  uint8_t &start_year,
+  
+  uint8_t &start_day,
+  
+  uint8_t &start_hour,
+  
+  uint8_t &start_minute,
+  
+  uint8_t &stop_year,
+  
+  uint8_t &stop_day,
+  
+  uint8_t &stop_hour,
+  
+  uint8_t &stop_minute
+  
+) {
+
+  if (jsn.at("SetAction").is_null()) {
+    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
+    return;
+  }
+        
+  set_action = jsn.at("SetAction").get< uint8_t >();
+      if (jsn.at("UserIdentifier").is_null()) {
+    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
+    return;
+  }
+        
+  user_identifier = jsn.at("UserIdentifier").get< uint8_t >();
+      if (jsn.at("ScheduleSlotID").is_null()) {
+    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
+    return;
+  }
+        
+  schedule_slotid = jsn.at("ScheduleSlotID").get< uint8_t >();
+      if (jsn.at("StartYear").is_null()) {
+    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
+    return;
+  }
+        
+  start_year = jsn.at("StartYear").get< uint8_t >();
+      if (jsn.at("StartDay").is_null()) {
+    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
+    return;
+  }
+        
+  start_day = jsn.at("StartDay").get< uint8_t >();
+      if (jsn.at("StartHour").is_null()) {
+    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
+    return;
+  }
+        
+  start_hour = jsn.at("StartHour").get< uint8_t >();
+      if (jsn.at("StartMinute").is_null()) {
+    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
+    return;
+  }
+        
+  start_minute = jsn.at("StartMinute").get< uint8_t >();
+      if (jsn.at("StopYear").is_null()) {
+    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
+    return;
+  }
+        
+  stop_year = jsn.at("StopYear").get< uint8_t >();
+      if (jsn.at("StopDay").is_null()) {
+    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
+    return;
+  }
+        
+  stop_day = jsn.at("StopDay").get< uint8_t >();
+      if (jsn.at("StopHour").is_null()) {
+    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
+    return;
+  }
+        
+  stop_hour = jsn.at("StopHour").get< uint8_t >();
+      if (jsn.at("StopMinute").is_null()) {
+    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
+    return;
+  }
+        
+  stop_minute = jsn.at("StopMinute").get< uint8_t >();
+    }
+
+
+std::string get_json_payload_for_unify_schedule_entry_lock_schedule_entry_lock_daily_repeating_report_command(
+  
+  const uic_mqtt_dotdot_unify_schedule_entry_lock_command_schedule_entry_lock_daily_repeating_report_fields_t *fields
+  
+){
+  bool command_with_no_fields = true;
+
+  // Create a JSON payload from all the parameters
+  nlohmann::json json_payload;
+  command_with_no_fields = false;
+  // Single Value
+  // Non-enum and non-bitmask (struct, string or scalar)
+  json_payload["SetAction"] = nlohmann::json(fields->set_action);
+  command_with_no_fields = false;
+  // Single Value
+  // Non-enum and non-bitmask (struct, string or scalar)
+  json_payload["UserIdentifier"] = nlohmann::json(fields->user_identifier);
+  command_with_no_fields = false;
+  // Single Value
+  // Non-enum and non-bitmask (struct, string or scalar)
+  json_payload["ScheduleSlotID"] = nlohmann::json(fields->schedule_slotid);
+  command_with_no_fields = false;
+  // Single Value
+  // Non-enum and non-bitmask (struct, string or scalar)
+  json_payload["WeekDayBitmask"] = nlohmann::json(fields->week_day_bitmask);
+  command_with_no_fields = false;
+  // Single Value
+  // Non-enum and non-bitmask (struct, string or scalar)
+  json_payload["StartHour"] = nlohmann::json(fields->start_hour);
+  command_with_no_fields = false;
+  // Single Value
+  // Non-enum and non-bitmask (struct, string or scalar)
+  json_payload["StartMinute"] = nlohmann::json(fields->start_minute);
+  command_with_no_fields = false;
+  // Single Value
+  // Non-enum and non-bitmask (struct, string or scalar)
+  json_payload["DurationHour"] = nlohmann::json(fields->duration_hour);
+  command_with_no_fields = false;
+  // Single Value
+  // Non-enum and non-bitmask (struct, string or scalar)
+  json_payload["DurationMinute"] = nlohmann::json(fields->duration_minute);
+
+  // Get the string
+  if (command_with_no_fields == true) {
+    return std::string("{}");
+  }
+  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
+  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
+}
+
+
+void uic_mqtt_dotdot_parse_unify_schedule_entry_lock_schedule_entry_lock_daily_repeating_report(
+  nlohmann::json &jsn,
+  uint8_t &set_action,
+  
+  uint8_t &user_identifier,
+  
+  uint8_t &schedule_slotid,
+  
+  uint8_t &week_day_bitmask,
+  
+  uint8_t &start_hour,
+  
+  uint8_t &start_minute,
+  
+  uint8_t &duration_hour,
+  
+  uint8_t &duration_minute
+  
+) {
+
+  if (jsn.at("SetAction").is_null()) {
+    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
+    return;
+  }
+        
+  set_action = jsn.at("SetAction").get< uint8_t >();
+      if (jsn.at("UserIdentifier").is_null()) {
+    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
+    return;
+  }
+        
+  user_identifier = jsn.at("UserIdentifier").get< uint8_t >();
+      if (jsn.at("ScheduleSlotID").is_null()) {
+    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
+    return;
+  }
+        
+  schedule_slotid = jsn.at("ScheduleSlotID").get< uint8_t >();
+      if (jsn.at("WeekDayBitmask").is_null()) {
+    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
+    return;
+  }
+        
+  week_day_bitmask = jsn.at("WeekDayBitmask").get< uint8_t >();
+      if (jsn.at("StartHour").is_null()) {
+    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
+    return;
+  }
+        
+  start_hour = jsn.at("StartHour").get< uint8_t >();
+      if (jsn.at("StartMinute").is_null()) {
+    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
+    return;
+  }
+        
+  start_minute = jsn.at("StartMinute").get< uint8_t >();
+      if (jsn.at("DurationHour").is_null()) {
+    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
+    return;
+  }
+        
+  duration_hour = jsn.at("DurationHour").get< uint8_t >();
+      if (jsn.at("DurationMinute").is_null()) {
+    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
+    return;
+  }
+        
+  duration_minute = jsn.at("DurationMinute").get< uint8_t >();
+    }
+
+
+/**
+ * @brief JSON parser for ::WriteAttributes command arguments.
+ *
+ * Parse incoming JSON object to populate command arguments passed in by reference.
+ */
+void uic_mqtt_dotdot_parse_unify_schedule_entry_lock_write_attributes(
+  nlohmann::json &jsn,
+  uic_mqtt_dotdot_unify_schedule_entry_lock_state_t &new_state,
+  uic_mqtt_dotdot_unify_schedule_entry_lock_updated_state_t &new_updated_state
+) {
+
+
+  if (jsn.find("SlotsWeekDay") != jsn.end()) {
+
+    new_state.slots_week_day = jsn.at("SlotsWeekDay").get<uint8_t>();
+        
+    new_updated_state.slots_week_day = true;
+  }
+
+  if (jsn.find("SlotsYearDay") != jsn.end()) {
+
+    new_state.slots_year_day = jsn.at("SlotsYearDay").get<uint8_t>();
+        
+    new_updated_state.slots_year_day = true;
+  }
+
+  if (jsn.find("SignTZO") != jsn.end()) {
+
+    new_state.signtzo = jsn.at("SignTZO").get<uint8_t>();
+        
+    new_updated_state.signtzo = true;
+  }
+
+  if (jsn.find("HourTZO") != jsn.end()) {
+
+    new_state.hourtzo = jsn.at("HourTZO").get<uint8_t>();
+        
+    new_updated_state.hourtzo = true;
+  }
+
+  if (jsn.find("MinuteTZO") != jsn.end()) {
+
+    new_state.minutetzo = jsn.at("MinuteTZO").get<uint8_t>();
+        
+    new_updated_state.minutetzo = true;
+  }
+
+  if (jsn.find("DSTOffsetSign") != jsn.end()) {
+
+    new_state.dst_offset_sign = jsn.at("DSTOffsetSign").get<uint8_t>();
+        
+    new_updated_state.dst_offset_sign = true;
+  }
+
+  if (jsn.find("DSTOffsetMinute") != jsn.end()) {
+
+    new_state.dst_offset_minute = jsn.at("DSTOffsetMinute").get<uint8_t>();
+        
+    new_updated_state.dst_offset_minute = true;
+  }
+
+  if (jsn.find("NumberOfSlotsDailyRepeating") != jsn.end()) {
+
+    new_state.number_of_slots_daily_repeating = jsn.at("NumberOfSlotsDailyRepeating").get<uint8_t>();
+        
+    new_updated_state.number_of_slots_daily_repeating = true;
+  }
+
+
+}
+
+
 std::string get_json_payload_for_unify_humidity_control_mode_set_command(
   
   const uic_mqtt_dotdot_unify_humidity_control_command_mode_set_fields_t *fields
diff --git a/components/uic_dotdot_mqtt/zap-generated/src/dotdot_mqtt_command_helpers.hpp b/components/uic_dotdot_mqtt/zap-generated/src/dotdot_mqtt_command_helpers.hpp
index 4bb5c71735..1082c43494 100644
--- a/components/uic_dotdot_mqtt/zap-generated/src/dotdot_mqtt_command_helpers.hpp
+++ b/components/uic_dotdot_mqtt/zap-generated/src/dotdot_mqtt_command_helpers.hpp
@@ -6029,6 +6029,148 @@ void uic_mqtt_dotdot_parse_unify_thermostat_write_attributes(
 );
 
 
+/**
+ * @brief Private helper function that will create a JSON string based on the
+ * fields of a UnifyScheduleEntryLock ScheduleEntryLockWeekDayReport command
+ * 
+ * @param fields       Struct pointer with the list of fields for the command
+ * 
+ * @returns std::string that contains JSON payload
+ */
+std::string get_json_payload_for_unify_schedule_entry_lock_schedule_entry_lock_week_day_report_command(
+  
+  const uic_mqtt_dotdot_unify_schedule_entry_lock_command_schedule_entry_lock_week_day_report_fields_t *fields
+  
+);
+
+
+/**
+ * @brief JSON parser for UnifyScheduleEntryLock ScheduleEntryLockWeekDayReport command arguments.
+ *
+ * Parse incoming JSON object to populate command arguments passed in by reference.
+ */
+void uic_mqtt_dotdot_parse_unify_schedule_entry_lock_schedule_entry_lock_week_day_report(
+  nlohmann::json &jsn,
+  uint8_t &user_identifier,
+
+  uint8_t &schedule_slotid,
+
+  uint8_t &day_of_week,
+
+  uint8_t &start_hour,
+
+  uint8_t &start_minute,
+
+  uint8_t &stop_hour,
+
+  uint8_t &stop_minute
+
+);
+
+
+
+/**
+ * @brief Private helper function that will create a JSON string based on the
+ * fields of a UnifyScheduleEntryLock ScheduleEntryLockYearDayReport command
+ * 
+ * @param fields       Struct pointer with the list of fields for the command
+ * 
+ * @returns std::string that contains JSON payload
+ */
+std::string get_json_payload_for_unify_schedule_entry_lock_schedule_entry_lock_year_day_report_command(
+  
+  const uic_mqtt_dotdot_unify_schedule_entry_lock_command_schedule_entry_lock_year_day_report_fields_t *fields
+  
+);
+
+
+/**
+ * @brief JSON parser for UnifyScheduleEntryLock ScheduleEntryLockYearDayReport command arguments.
+ *
+ * Parse incoming JSON object to populate command arguments passed in by reference.
+ */
+void uic_mqtt_dotdot_parse_unify_schedule_entry_lock_schedule_entry_lock_year_day_report(
+  nlohmann::json &jsn,
+  uint8_t &set_action,
+
+  uint8_t &user_identifier,
+
+  uint8_t &schedule_slotid,
+
+  uint8_t &start_year,
+
+  uint8_t &start_day,
+
+  uint8_t &start_hour,
+
+  uint8_t &start_minute,
+
+  uint8_t &stop_year,
+
+  uint8_t &stop_day,
+
+  uint8_t &stop_hour,
+
+  uint8_t &stop_minute
+
+);
+
+
+
+/**
+ * @brief Private helper function that will create a JSON string based on the
+ * fields of a UnifyScheduleEntryLock ScheduleEntryLockDailyRepeatingReport command
+ * 
+ * @param fields       Struct pointer with the list of fields for the command
+ * 
+ * @returns std::string that contains JSON payload
+ */
+std::string get_json_payload_for_unify_schedule_entry_lock_schedule_entry_lock_daily_repeating_report_command(
+  
+  const uic_mqtt_dotdot_unify_schedule_entry_lock_command_schedule_entry_lock_daily_repeating_report_fields_t *fields
+  
+);
+
+
+/**
+ * @brief JSON parser for UnifyScheduleEntryLock ScheduleEntryLockDailyRepeatingReport command arguments.
+ *
+ * Parse incoming JSON object to populate command arguments passed in by reference.
+ */
+void uic_mqtt_dotdot_parse_unify_schedule_entry_lock_schedule_entry_lock_daily_repeating_report(
+  nlohmann::json &jsn,
+  uint8_t &set_action,
+
+  uint8_t &user_identifier,
+
+  uint8_t &schedule_slotid,
+
+  uint8_t &week_day_bitmask,
+
+  uint8_t &start_hour,
+
+  uint8_t &start_minute,
+
+  uint8_t &duration_hour,
+
+  uint8_t &duration_minute
+
+);
+
+
+
+/**
+ * @brief JSON parser for UnifyScheduleEntryLock WriteAttributes command arguments.
+ *
+ * Parse incoming JSON object to populate command arguments passed in by reference.
+ */
+void uic_mqtt_dotdot_parse_unify_schedule_entry_lock_write_attributes(
+  nlohmann::json &jsn,
+  uic_mqtt_dotdot_unify_schedule_entry_lock_state_t &new_state,
+  uic_mqtt_dotdot_unify_schedule_entry_lock_updated_state_t &new_updated_state
+);
+
+
 /**
  * @brief Private helper function that will create a JSON string based on the
  * fields of a UnifyHumidityControl ModeSet command
diff --git a/components/uic_dotdot_mqtt/zap-generated/src/dotdot_mqtt_generated_commands.cpp b/components/uic_dotdot_mqtt/zap-generated/src/dotdot_mqtt_generated_commands.cpp
index 9c5b838ded..03c7efb978 100644
--- a/components/uic_dotdot_mqtt/zap-generated/src/dotdot_mqtt_generated_commands.cpp
+++ b/components/uic_dotdot_mqtt/zap-generated/src/dotdot_mqtt_generated_commands.cpp
@@ -11235,6 +11235,234 @@ void uic_mqtt_dotdot_unify_thermostat_publish_generated_write_attributes_command
                    false);
 }
 
+/**
+ * @brief Publishes an incoming/generated ScheduleEntryLockWeekDayReport command for
+ * the UnifyScheduleEntryLock cluster.
+ *
+ * Publication will be made at the following topic
+ * ucl/by-unid/UNID/epID/UnifyScheduleEntryLock/GeneratedCommands/ScheduleEntryLockWeekDayReport
+ *
+ * @param unid      The UNID of the node that sent us the command.
+ * 
+ * @param endpoint  The Endpoint ID of the node that sent us the command.
+ * 
+ * 
+ * @param fields                Struct pointer with the fields value of the command
+ * 
+ */
+void uic_mqtt_dotdot_unify_schedule_entry_lock_publish_generated_schedule_entry_lock_week_day_report_command(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint,
+  const uic_mqtt_dotdot_unify_schedule_entry_lock_command_schedule_entry_lock_week_day_report_fields_t *fields
+  
+) {
+  // Create the topic
+  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
+                      std::to_string(endpoint) + "/";
+  topic += "UnifyScheduleEntryLock/GeneratedCommands/ScheduleEntryLockWeekDayReport";
+
+  std::string payload =
+    get_json_payload_for_unify_schedule_entry_lock_schedule_entry_lock_week_day_report_command(
+    fields);
+
+  // Publish our command
+  uic_mqtt_publish(topic.c_str(),
+                    payload.c_str(),
+                    payload.size(),
+                    false);
+}
+/**
+ * @brief Publishes an incoming/generated ScheduleEntryLockYearDayReport command for
+ * the UnifyScheduleEntryLock cluster.
+ *
+ * Publication will be made at the following topic
+ * ucl/by-unid/UNID/epID/UnifyScheduleEntryLock/GeneratedCommands/ScheduleEntryLockYearDayReport
+ *
+ * @param unid      The UNID of the node that sent us the command.
+ * 
+ * @param endpoint  The Endpoint ID of the node that sent us the command.
+ * 
+ * 
+ * @param fields                Struct pointer with the fields value of the command
+ * 
+ */
+void uic_mqtt_dotdot_unify_schedule_entry_lock_publish_generated_schedule_entry_lock_year_day_report_command(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint,
+  const uic_mqtt_dotdot_unify_schedule_entry_lock_command_schedule_entry_lock_year_day_report_fields_t *fields
+  
+) {
+  // Create the topic
+  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
+                      std::to_string(endpoint) + "/";
+  topic += "UnifyScheduleEntryLock/GeneratedCommands/ScheduleEntryLockYearDayReport";
+
+  std::string payload =
+    get_json_payload_for_unify_schedule_entry_lock_schedule_entry_lock_year_day_report_command(
+    fields);
+
+  // Publish our command
+  uic_mqtt_publish(topic.c_str(),
+                    payload.c_str(),
+                    payload.size(),
+                    false);
+}
+/**
+ * @brief Publishes an incoming/generated ScheduleEntryLockDailyRepeatingReport command for
+ * the UnifyScheduleEntryLock cluster.
+ *
+ * Publication will be made at the following topic
+ * ucl/by-unid/UNID/epID/UnifyScheduleEntryLock/GeneratedCommands/ScheduleEntryLockDailyRepeatingReport
+ *
+ * @param unid      The UNID of the node that sent us the command.
+ * 
+ * @param endpoint  The Endpoint ID of the node that sent us the command.
+ * 
+ * 
+ * @param fields                Struct pointer with the fields value of the command
+ * 
+ */
+void uic_mqtt_dotdot_unify_schedule_entry_lock_publish_generated_schedule_entry_lock_daily_repeating_report_command(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint,
+  const uic_mqtt_dotdot_unify_schedule_entry_lock_command_schedule_entry_lock_daily_repeating_report_fields_t *fields
+  
+) {
+  // Create the topic
+  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
+                      std::to_string(endpoint) + "/";
+  topic += "UnifyScheduleEntryLock/GeneratedCommands/ScheduleEntryLockDailyRepeatingReport";
+
+  std::string payload =
+    get_json_payload_for_unify_schedule_entry_lock_schedule_entry_lock_daily_repeating_report_command(
+    fields);
+
+  // Publish our command
+  uic_mqtt_publish(topic.c_str(),
+                    payload.c_str(),
+                    payload.size(),
+                    false);
+}
+
+
+/**
+ * @brief Publishes an incoming/generated WriteAttributes command for
+ * the UnifyScheduleEntryLock cluster.
+ *
+ * Publication will be made at the following topic
+ * ucl/by-unid/UNID/epID/UnifyScheduleEntryLock/GeneratedCommands/WriteAttributes
+ *
+ * @param unid      The UNID of the node that sent us the command.
+ * 
+ * @param endpoint  The Endpoint ID of the node that sent us the command.
+ * 
+ * @param attribute_values  Values to assign to the attributes
+ * @param attribute_list    List of attributes that are written
+ */
+void uic_mqtt_dotdot_unify_schedule_entry_lock_publish_generated_write_attributes_command(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint,
+  uic_mqtt_dotdot_unify_schedule_entry_lock_state_t attribute_values,
+  uic_mqtt_dotdot_unify_schedule_entry_lock_updated_state_t attribute_list
+){
+  // Create the topic
+  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
+                      std::to_string(endpoint) + "/";
+  topic += "UnifyScheduleEntryLock/GeneratedCommands/WriteAttributes";
+
+  nlohmann::json json_object = nlohmann::json::object();
+
+
+  if (attribute_list.slots_week_day == true) {
+
+  // This is a single value
+
+  json_object["SlotsWeekDay"] = attribute_values.slots_week_day;
+
+
+  }
+
+
+  if (attribute_list.slots_year_day == true) {
+
+  // This is a single value
+
+  json_object["SlotsYearDay"] = attribute_values.slots_year_day;
+
+
+  }
+
+
+  if (attribute_list.signtzo == true) {
+
+  // This is a single value
+
+  json_object["SignTZO"] = attribute_values.signtzo;
+
+
+  }
+
+
+  if (attribute_list.hourtzo == true) {
+
+  // This is a single value
+
+  json_object["HourTZO"] = attribute_values.hourtzo;
+
+
+  }
+
+
+  if (attribute_list.minutetzo == true) {
+
+  // This is a single value
+
+  json_object["MinuteTZO"] = attribute_values.minutetzo;
+
+
+  }
+
+
+  if (attribute_list.dst_offset_sign == true) {
+
+  // This is a single value
+
+  json_object["DSTOffsetSign"] = attribute_values.dst_offset_sign;
+
+
+  }
+
+
+  if (attribute_list.dst_offset_minute == true) {
+
+  // This is a single value
+
+  json_object["DSTOffsetMinute"] = attribute_values.dst_offset_minute;
+
+
+  }
+
+
+  if (attribute_list.number_of_slots_daily_repeating == true) {
+
+  // This is a single value
+
+  json_object["NumberOfSlotsDailyRepeating"] = attribute_values.number_of_slots_daily_repeating;
+
+
+  }
+
+
+  // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
+  std::string payload = json_object.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
+
+  // Publish our command
+  uic_mqtt_publish(topic.c_str(),
+                   payload.c_str(),
+                   payload.size(),
+                   false);
+}
+
 /**
  * @brief Publishes an incoming/generated ModeSet command for
  * the UnifyHumidityControl cluster.
diff --git a/components/uic_dotdot_mqtt/zap-generated/src/dotdot_mqtt_group_commands.cpp b/components/uic_dotdot_mqtt/zap-generated/src/dotdot_mqtt_group_commands.cpp
index 36023fc2e7..c63dd2a685 100644
--- a/components/uic_dotdot_mqtt/zap-generated/src/dotdot_mqtt_group_commands.cpp
+++ b/components/uic_dotdot_mqtt/zap-generated/src/dotdot_mqtt_group_commands.cpp
@@ -368,6 +368,12 @@ static uic_mqtt_dotdot_by_group_unify_fan_control_write_attributes_callback_t ui
 static uic_mqtt_dotdot_by_group_unify_thermostat_write_attributes_callback_t uic_mqtt_dotdot_by_group_unify_thermostat_write_attributes_callback = nullptr;
 
 
+static uic_mqtt_dotdot_by_group_unify_schedule_entry_lock_schedule_entry_lock_week_day_report_callback_t uic_mqtt_dotdot_by_group_unify_schedule_entry_lock_schedule_entry_lock_week_day_report_callback = nullptr;
+static uic_mqtt_dotdot_by_group_unify_schedule_entry_lock_schedule_entry_lock_year_day_report_callback_t uic_mqtt_dotdot_by_group_unify_schedule_entry_lock_schedule_entry_lock_year_day_report_callback = nullptr;
+static uic_mqtt_dotdot_by_group_unify_schedule_entry_lock_schedule_entry_lock_daily_repeating_report_callback_t uic_mqtt_dotdot_by_group_unify_schedule_entry_lock_schedule_entry_lock_daily_repeating_report_callback = nullptr;
+static uic_mqtt_dotdot_by_group_unify_schedule_entry_lock_write_attributes_callback_t uic_mqtt_dotdot_by_group_unify_schedule_entry_lock_write_attributes_callback = nullptr;
+
+
 static uic_mqtt_dotdot_by_group_unify_humidity_control_mode_set_callback_t uic_mqtt_dotdot_by_group_unify_humidity_control_mode_set_callback = nullptr;
 static uic_mqtt_dotdot_by_group_unify_humidity_control_setpoint_set_callback_t uic_mqtt_dotdot_by_group_unify_humidity_control_setpoint_set_callback = nullptr;
 static uic_mqtt_dotdot_by_group_unify_humidity_control_write_attributes_callback_t uic_mqtt_dotdot_by_group_unify_humidity_control_write_attributes_callback = nullptr;
@@ -1886,6 +1892,33 @@ void uic_mqtt_dotdot_by_group_unify_thermostat_write_attributes_callback_set(
 
 
 
+// Callbacks setters
+
+void uic_mqtt_dotdot_by_group_unify_schedule_entry_lock_schedule_entry_lock_week_day_report_callback_set(const uic_mqtt_dotdot_by_group_unify_schedule_entry_lock_schedule_entry_lock_week_day_report_callback_t callback)
+{
+  uic_mqtt_dotdot_by_group_unify_schedule_entry_lock_schedule_entry_lock_week_day_report_callback = callback;
+}
+
+
+void uic_mqtt_dotdot_by_group_unify_schedule_entry_lock_schedule_entry_lock_year_day_report_callback_set(const uic_mqtt_dotdot_by_group_unify_schedule_entry_lock_schedule_entry_lock_year_day_report_callback_t callback)
+{
+  uic_mqtt_dotdot_by_group_unify_schedule_entry_lock_schedule_entry_lock_year_day_report_callback = callback;
+}
+
+
+void uic_mqtt_dotdot_by_group_unify_schedule_entry_lock_schedule_entry_lock_daily_repeating_report_callback_set(const uic_mqtt_dotdot_by_group_unify_schedule_entry_lock_schedule_entry_lock_daily_repeating_report_callback_t callback)
+{
+  uic_mqtt_dotdot_by_group_unify_schedule_entry_lock_schedule_entry_lock_daily_repeating_report_callback = callback;
+}
+
+void uic_mqtt_dotdot_by_group_unify_schedule_entry_lock_write_attributes_callback_set(
+  const uic_mqtt_dotdot_by_group_unify_schedule_entry_lock_write_attributes_callback_t callback)
+{
+  uic_mqtt_dotdot_by_group_unify_schedule_entry_lock_write_attributes_callback = callback;
+}
+
+
+
 // Callbacks setters
 
 void uic_mqtt_dotdot_by_group_unify_humidity_control_mode_set_callback_set(const uic_mqtt_dotdot_by_group_unify_humidity_control_mode_set_callback_t callback)
@@ -23427,6 +23460,496 @@ sl_status_t uic_mqtt_dotdot_by_group_unify_thermostat_init()
 
 
 
+// Callback function for incoming publications on ucl/by-group/+/UnifyScheduleEntryLock/Commands/ScheduleEntryLockWeekDayReport
+static void uic_mqtt_dotdot_on_by_group_unify_schedule_entry_lock_schedule_entry_lock_week_day_report(
+  const char *topic,
+  const char *message,
+  const size_t message_length)
+{
+  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_unify_schedule_entry_lock_schedule_entry_lock_week_day_report_callback == nullptr)) {
+    return;
+  }
+  if (message_length == 0) {
+    return;
+  }
+
+  dotdot_group_id_t group_id = 0U;
+  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
+    sl_log_debug(LOG_TAG,
+                "Failed to parse GroupId from topic %s. Ignoring",
+                topic);
+    return;
+  }
+
+  // Pass to command-specific callback if set. Otherwise, pass to
+  // group-dispatch callback
+  if (uic_mqtt_dotdot_by_group_unify_schedule_entry_lock_schedule_entry_lock_week_day_report_callback != nullptr) {
+
+    
+    uic_mqtt_dotdot_unify_schedule_entry_lock_command_schedule_entry_lock_week_day_report_fields_t fields;
+
+
+      nlohmann::json jsn;
+      try {
+        jsn = nlohmann::json::parse(std::string(message));
+
+      
+        uic_mqtt_dotdot_parse_unify_schedule_entry_lock_schedule_entry_lock_week_day_report(
+          jsn,
+          fields.user_identifier,
+              
+          fields.schedule_slotid,
+              
+          fields.day_of_week,
+              
+          fields.start_hour,
+              
+          fields.start_minute,
+              
+          fields.stop_hour,
+              
+          fields.stop_minute
+              );
+
+      // Populate list fields from vector or string types
+      
+
+      } catch (const nlohmann::json::parse_error& e) {
+        // Catch JSON object field parsing errors
+        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "UnifyScheduleEntryLock", "ScheduleEntryLockWeekDayReport");
+        return;
+      } catch (const nlohmann::json::exception& e) {
+        // Catch JSON object field parsing errors
+        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "UnifyScheduleEntryLock", "ScheduleEntryLockWeekDayReport", e.what());
+        return;
+      } catch (const std::exception& e) {
+        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "UnifyScheduleEntryLock", "ScheduleEntryLockWeekDayReport", "");
+        return;
+      }
+
+      uic_mqtt_dotdot_by_group_unify_schedule_entry_lock_schedule_entry_lock_week_day_report_callback(
+        group_id,
+        &fields
+      );
+  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_week_day_report_callback().empty())) {
+    // group-dispatch callback only called if the command-specific by-unid
+    // callback is set
+    try {
+      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
+      if (jsn.find("UserIdentifier") == jsn.end()) {
+        sl_log_debug(LOG_TAG, "UnifyScheduleEntryLock::ScheduleEntryLockWeekDayReport: Missing command-argument: UserIdentifier\n");
+        return;
+      }
+      if (jsn.find("ScheduleSlotID") == jsn.end()) {
+        sl_log_debug(LOG_TAG, "UnifyScheduleEntryLock::ScheduleEntryLockWeekDayReport: Missing command-argument: ScheduleSlotID\n");
+        return;
+      }
+      if (jsn.find("DayOfWeek") == jsn.end()) {
+        sl_log_debug(LOG_TAG, "UnifyScheduleEntryLock::ScheduleEntryLockWeekDayReport: Missing command-argument: DayOfWeek\n");
+        return;
+      }
+      if (jsn.find("StartHour") == jsn.end()) {
+        sl_log_debug(LOG_TAG, "UnifyScheduleEntryLock::ScheduleEntryLockWeekDayReport: Missing command-argument: StartHour\n");
+        return;
+      }
+      if (jsn.find("StartMinute") == jsn.end()) {
+        sl_log_debug(LOG_TAG, "UnifyScheduleEntryLock::ScheduleEntryLockWeekDayReport: Missing command-argument: StartMinute\n");
+        return;
+      }
+      if (jsn.find("StopHour") == jsn.end()) {
+        sl_log_debug(LOG_TAG, "UnifyScheduleEntryLock::ScheduleEntryLockWeekDayReport: Missing command-argument: StopHour\n");
+        return;
+      }
+      if (jsn.find("StopMinute") == jsn.end()) {
+        sl_log_debug(LOG_TAG, "UnifyScheduleEntryLock::ScheduleEntryLockWeekDayReport: Missing command-argument: StopMinute\n");
+        return;
+      }
+
+      group_dispatch_callback(
+        group_id,
+        "UnifyScheduleEntryLock",
+        "ScheduleEntryLockWeekDayReport",
+        message,
+        message_length,
+        uic_mqtt_dotdot_on_unify_schedule_entry_lock_schedule_entry_lock_week_day_report);
+
+    } catch (...) {
+      sl_log_debug(LOG_TAG, "ScheduleEntryLockWeekDayReport: Unable to parse JSON payload.\n");
+      return;
+    }
+  }
+
+}
+
+// Callback function for incoming publications on ucl/by-group/+/UnifyScheduleEntryLock/Commands/ScheduleEntryLockYearDayReport
+static void uic_mqtt_dotdot_on_by_group_unify_schedule_entry_lock_schedule_entry_lock_year_day_report(
+  const char *topic,
+  const char *message,
+  const size_t message_length)
+{
+  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_unify_schedule_entry_lock_schedule_entry_lock_year_day_report_callback == nullptr)) {
+    return;
+  }
+  if (message_length == 0) {
+    return;
+  }
+
+  dotdot_group_id_t group_id = 0U;
+  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
+    sl_log_debug(LOG_TAG,
+                "Failed to parse GroupId from topic %s. Ignoring",
+                topic);
+    return;
+  }
+
+  // Pass to command-specific callback if set. Otherwise, pass to
+  // group-dispatch callback
+  if (uic_mqtt_dotdot_by_group_unify_schedule_entry_lock_schedule_entry_lock_year_day_report_callback != nullptr) {
+
+    
+    uic_mqtt_dotdot_unify_schedule_entry_lock_command_schedule_entry_lock_year_day_report_fields_t fields;
+
+
+      nlohmann::json jsn;
+      try {
+        jsn = nlohmann::json::parse(std::string(message));
+
+      
+        uic_mqtt_dotdot_parse_unify_schedule_entry_lock_schedule_entry_lock_year_day_report(
+          jsn,
+          fields.set_action,
+              
+          fields.user_identifier,
+              
+          fields.schedule_slotid,
+              
+          fields.start_year,
+              
+          fields.start_day,
+              
+          fields.start_hour,
+              
+          fields.start_minute,
+              
+          fields.stop_year,
+              
+          fields.stop_day,
+              
+          fields.stop_hour,
+              
+          fields.stop_minute
+              );
+
+      // Populate list fields from vector or string types
+      
+
+      } catch (const nlohmann::json::parse_error& e) {
+        // Catch JSON object field parsing errors
+        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "UnifyScheduleEntryLock", "ScheduleEntryLockYearDayReport");
+        return;
+      } catch (const nlohmann::json::exception& e) {
+        // Catch JSON object field parsing errors
+        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "UnifyScheduleEntryLock", "ScheduleEntryLockYearDayReport", e.what());
+        return;
+      } catch (const std::exception& e) {
+        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "UnifyScheduleEntryLock", "ScheduleEntryLockYearDayReport", "");
+        return;
+      }
+
+      uic_mqtt_dotdot_by_group_unify_schedule_entry_lock_schedule_entry_lock_year_day_report_callback(
+        group_id,
+        &fields
+      );
+  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_year_day_report_callback().empty())) {
+    // group-dispatch callback only called if the command-specific by-unid
+    // callback is set
+    try {
+      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
+      if (jsn.find("SetAction") == jsn.end()) {
+        sl_log_debug(LOG_TAG, "UnifyScheduleEntryLock::ScheduleEntryLockYearDayReport: Missing command-argument: SetAction\n");
+        return;
+      }
+      if (jsn.find("UserIdentifier") == jsn.end()) {
+        sl_log_debug(LOG_TAG, "UnifyScheduleEntryLock::ScheduleEntryLockYearDayReport: Missing command-argument: UserIdentifier\n");
+        return;
+      }
+      if (jsn.find("ScheduleSlotID") == jsn.end()) {
+        sl_log_debug(LOG_TAG, "UnifyScheduleEntryLock::ScheduleEntryLockYearDayReport: Missing command-argument: ScheduleSlotID\n");
+        return;
+      }
+      if (jsn.find("StartYear") == jsn.end()) {
+        sl_log_debug(LOG_TAG, "UnifyScheduleEntryLock::ScheduleEntryLockYearDayReport: Missing command-argument: StartYear\n");
+        return;
+      }
+      if (jsn.find("StartDay") == jsn.end()) {
+        sl_log_debug(LOG_TAG, "UnifyScheduleEntryLock::ScheduleEntryLockYearDayReport: Missing command-argument: StartDay\n");
+        return;
+      }
+      if (jsn.find("StartHour") == jsn.end()) {
+        sl_log_debug(LOG_TAG, "UnifyScheduleEntryLock::ScheduleEntryLockYearDayReport: Missing command-argument: StartHour\n");
+        return;
+      }
+      if (jsn.find("StartMinute") == jsn.end()) {
+        sl_log_debug(LOG_TAG, "UnifyScheduleEntryLock::ScheduleEntryLockYearDayReport: Missing command-argument: StartMinute\n");
+        return;
+      }
+      if (jsn.find("StopYear") == jsn.end()) {
+        sl_log_debug(LOG_TAG, "UnifyScheduleEntryLock::ScheduleEntryLockYearDayReport: Missing command-argument: StopYear\n");
+        return;
+      }
+      if (jsn.find("StopDay") == jsn.end()) {
+        sl_log_debug(LOG_TAG, "UnifyScheduleEntryLock::ScheduleEntryLockYearDayReport: Missing command-argument: StopDay\n");
+        return;
+      }
+      if (jsn.find("StopHour") == jsn.end()) {
+        sl_log_debug(LOG_TAG, "UnifyScheduleEntryLock::ScheduleEntryLockYearDayReport: Missing command-argument: StopHour\n");
+        return;
+      }
+      if (jsn.find("StopMinute") == jsn.end()) {
+        sl_log_debug(LOG_TAG, "UnifyScheduleEntryLock::ScheduleEntryLockYearDayReport: Missing command-argument: StopMinute\n");
+        return;
+      }
+
+      group_dispatch_callback(
+        group_id,
+        "UnifyScheduleEntryLock",
+        "ScheduleEntryLockYearDayReport",
+        message,
+        message_length,
+        uic_mqtt_dotdot_on_unify_schedule_entry_lock_schedule_entry_lock_year_day_report);
+
+    } catch (...) {
+      sl_log_debug(LOG_TAG, "ScheduleEntryLockYearDayReport: Unable to parse JSON payload.\n");
+      return;
+    }
+  }
+
+}
+
+// Callback function for incoming publications on ucl/by-group/+/UnifyScheduleEntryLock/Commands/ScheduleEntryLockDailyRepeatingReport
+static void uic_mqtt_dotdot_on_by_group_unify_schedule_entry_lock_schedule_entry_lock_daily_repeating_report(
+  const char *topic,
+  const char *message,
+  const size_t message_length)
+{
+  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_unify_schedule_entry_lock_schedule_entry_lock_daily_repeating_report_callback == nullptr)) {
+    return;
+  }
+  if (message_length == 0) {
+    return;
+  }
+
+  dotdot_group_id_t group_id = 0U;
+  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
+    sl_log_debug(LOG_TAG,
+                "Failed to parse GroupId from topic %s. Ignoring",
+                topic);
+    return;
+  }
+
+  // Pass to command-specific callback if set. Otherwise, pass to
+  // group-dispatch callback
+  if (uic_mqtt_dotdot_by_group_unify_schedule_entry_lock_schedule_entry_lock_daily_repeating_report_callback != nullptr) {
+
+    
+    uic_mqtt_dotdot_unify_schedule_entry_lock_command_schedule_entry_lock_daily_repeating_report_fields_t fields;
+
+
+      nlohmann::json jsn;
+      try {
+        jsn = nlohmann::json::parse(std::string(message));
+
+      
+        uic_mqtt_dotdot_parse_unify_schedule_entry_lock_schedule_entry_lock_daily_repeating_report(
+          jsn,
+          fields.set_action,
+              
+          fields.user_identifier,
+              
+          fields.schedule_slotid,
+              
+          fields.week_day_bitmask,
+              
+          fields.start_hour,
+              
+          fields.start_minute,
+              
+          fields.duration_hour,
+              
+          fields.duration_minute
+              );
+
+      // Populate list fields from vector or string types
+      
+
+      } catch (const nlohmann::json::parse_error& e) {
+        // Catch JSON object field parsing errors
+        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "UnifyScheduleEntryLock", "ScheduleEntryLockDailyRepeatingReport");
+        return;
+      } catch (const nlohmann::json::exception& e) {
+        // Catch JSON object field parsing errors
+        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "UnifyScheduleEntryLock", "ScheduleEntryLockDailyRepeatingReport", e.what());
+        return;
+      } catch (const std::exception& e) {
+        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "UnifyScheduleEntryLock", "ScheduleEntryLockDailyRepeatingReport", "");
+        return;
+      }
+
+      uic_mqtt_dotdot_by_group_unify_schedule_entry_lock_schedule_entry_lock_daily_repeating_report_callback(
+        group_id,
+        &fields
+      );
+  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_daily_repeating_report_callback().empty())) {
+    // group-dispatch callback only called if the command-specific by-unid
+    // callback is set
+    try {
+      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
+      if (jsn.find("SetAction") == jsn.end()) {
+        sl_log_debug(LOG_TAG, "UnifyScheduleEntryLock::ScheduleEntryLockDailyRepeatingReport: Missing command-argument: SetAction\n");
+        return;
+      }
+      if (jsn.find("UserIdentifier") == jsn.end()) {
+        sl_log_debug(LOG_TAG, "UnifyScheduleEntryLock::ScheduleEntryLockDailyRepeatingReport: Missing command-argument: UserIdentifier\n");
+        return;
+      }
+      if (jsn.find("ScheduleSlotID") == jsn.end()) {
+        sl_log_debug(LOG_TAG, "UnifyScheduleEntryLock::ScheduleEntryLockDailyRepeatingReport: Missing command-argument: ScheduleSlotID\n");
+        return;
+      }
+      if (jsn.find("WeekDayBitmask") == jsn.end()) {
+        sl_log_debug(LOG_TAG, "UnifyScheduleEntryLock::ScheduleEntryLockDailyRepeatingReport: Missing command-argument: WeekDayBitmask\n");
+        return;
+      }
+      if (jsn.find("StartHour") == jsn.end()) {
+        sl_log_debug(LOG_TAG, "UnifyScheduleEntryLock::ScheduleEntryLockDailyRepeatingReport: Missing command-argument: StartHour\n");
+        return;
+      }
+      if (jsn.find("StartMinute") == jsn.end()) {
+        sl_log_debug(LOG_TAG, "UnifyScheduleEntryLock::ScheduleEntryLockDailyRepeatingReport: Missing command-argument: StartMinute\n");
+        return;
+      }
+      if (jsn.find("DurationHour") == jsn.end()) {
+        sl_log_debug(LOG_TAG, "UnifyScheduleEntryLock::ScheduleEntryLockDailyRepeatingReport: Missing command-argument: DurationHour\n");
+        return;
+      }
+      if (jsn.find("DurationMinute") == jsn.end()) {
+        sl_log_debug(LOG_TAG, "UnifyScheduleEntryLock::ScheduleEntryLockDailyRepeatingReport: Missing command-argument: DurationMinute\n");
+        return;
+      }
+
+      group_dispatch_callback(
+        group_id,
+        "UnifyScheduleEntryLock",
+        "ScheduleEntryLockDailyRepeatingReport",
+        message,
+        message_length,
+        uic_mqtt_dotdot_on_unify_schedule_entry_lock_schedule_entry_lock_daily_repeating_report);
+
+    } catch (...) {
+      sl_log_debug(LOG_TAG, "ScheduleEntryLockDailyRepeatingReport: Unable to parse JSON payload.\n");
+      return;
+    }
+  }
+
+}
+
+static void uic_mqtt_dotdot_on_by_group_unify_schedule_entry_lock_WriteAttributes(
+  const char *topic,
+  const char *message,
+  const size_t message_length)
+{
+
+  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_unify_schedule_entry_lock_write_attributes_callback == nullptr)) {
+    return;
+  }
+  if (message_length == 0) {
+    return;
+  }
+
+  dotdot_group_id_t group_id = 0U;
+  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
+    sl_log_debug(LOG_TAG,
+                "Failed to parse GroupId from topic %s. Ignoring",
+                topic);
+    return;
+  }
+
+  if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_unify_schedule_entry_lock_write_attributes_callback().empty())) {
+    try {
+      group_dispatch_callback(group_id,
+                              "UnifyScheduleEntryLock",
+                              "WriteAttributes",
+                              message,
+                              message_length,
+                              uic_mqtt_dotdot_on_unify_schedule_entry_lock_WriteAttributes);
+
+    } catch (...) {
+      sl_log_debug(LOG_TAG, "UnifyScheduleEntryLock: Unable to parse JSON payload.\n");
+      return;
+    }
+  } else if (uic_mqtt_dotdot_by_group_unify_schedule_entry_lock_write_attributes_callback != nullptr) {
+
+    uic_mqtt_dotdot_unify_schedule_entry_lock_state_t new_state = {};
+    uic_mqtt_dotdot_unify_schedule_entry_lock_updated_state_t new_updated_state = {};
+    
+
+    nlohmann::json jsn;
+    try {
+      jsn = nlohmann::json::parse(std::string(message));
+
+      uic_mqtt_dotdot_parse_unify_schedule_entry_lock_write_attributes(
+        jsn,
+        new_state,
+        new_updated_state
+      );
+    } catch (const nlohmann::json::parse_error& e) {
+      // Catch JSON object field parsing errors
+      sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "UnifyScheduleEntryLock", "WriteAttributes");
+      return;
+    } catch (const nlohmann::json::exception& e) {
+      // Catch JSON object field parsing errors
+      sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "UnifyScheduleEntryLock", "WriteAttributes", e.what());
+      return;
+    } catch (const std::exception& e) {
+      sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "UnifyScheduleEntryLock", "WriteAttributes", "");
+      return;
+    }
+
+    uic_mqtt_dotdot_by_group_unify_schedule_entry_lock_write_attributes_callback(
+      group_id,
+      new_state,
+      new_updated_state
+    );
+  }
+}
+
+sl_status_t uic_mqtt_dotdot_by_group_unify_schedule_entry_lock_init()
+{
+  std::string subscription_topic;
+  const std::string topic_bygroup = TOPIC_BY_GROUP_PREFIX;
+  if(uic_mqtt_dotdot_by_group_unify_schedule_entry_lock_write_attributes_callback) {
+    subscription_topic = topic_bygroup + "UnifyScheduleEntryLock/Commands/WriteAttributes";
+    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_unify_schedule_entry_lock_WriteAttributes);
+  }
+  if (uic_mqtt_dotdot_by_group_unify_schedule_entry_lock_schedule_entry_lock_week_day_report_callback) {
+    subscription_topic = topic_bygroup + "UnifyScheduleEntryLock/Commands/ScheduleEntryLockWeekDayReport";
+    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_unify_schedule_entry_lock_schedule_entry_lock_week_day_report);
+  }
+  if (uic_mqtt_dotdot_by_group_unify_schedule_entry_lock_schedule_entry_lock_year_day_report_callback) {
+    subscription_topic = topic_bygroup + "UnifyScheduleEntryLock/Commands/ScheduleEntryLockYearDayReport";
+    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_unify_schedule_entry_lock_schedule_entry_lock_year_day_report);
+  }
+  if (uic_mqtt_dotdot_by_group_unify_schedule_entry_lock_schedule_entry_lock_daily_repeating_report_callback) {
+    subscription_topic = topic_bygroup + "UnifyScheduleEntryLock/Commands/ScheduleEntryLockDailyRepeatingReport";
+    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_unify_schedule_entry_lock_schedule_entry_lock_daily_repeating_report);
+  }
+
+  return SL_STATUS_OK;
+}
+
+
+
+
 // Callback function for incoming publications on ucl/by-group/+/UnifyHumidityControl/Commands/ModeSet
 static void uic_mqtt_dotdot_on_by_group_unify_humidity_control_mode_set(
   const char *topic,
@@ -23989,6 +24512,11 @@ void uic_mqtt_dotdot_set_group_dispatch_callback(group_dispatch_t callback)
 
     uic_mqtt_subscribe("ucl/by-group/+/UnifyThermostat/Commands/WriteAttributes", uic_mqtt_dotdot_on_by_group_unify_thermostat_WriteAttributes);
 
+    uic_mqtt_subscribe("ucl/by-group/+/UnifyScheduleEntryLock/Commands/WriteAttributes", uic_mqtt_dotdot_on_by_group_unify_schedule_entry_lock_WriteAttributes);
+    uic_mqtt_subscribe("ucl/by-group/+/UnifyScheduleEntryLock/Commands/ScheduleEntryLockWeekDayReport", uic_mqtt_dotdot_on_by_group_unify_schedule_entry_lock_schedule_entry_lock_week_day_report);
+    uic_mqtt_subscribe("ucl/by-group/+/UnifyScheduleEntryLock/Commands/ScheduleEntryLockYearDayReport", uic_mqtt_dotdot_on_by_group_unify_schedule_entry_lock_schedule_entry_lock_year_day_report);
+    uic_mqtt_subscribe("ucl/by-group/+/UnifyScheduleEntryLock/Commands/ScheduleEntryLockDailyRepeatingReport", uic_mqtt_dotdot_on_by_group_unify_schedule_entry_lock_schedule_entry_lock_daily_repeating_report);
+
     uic_mqtt_subscribe("ucl/by-group/+/UnifyHumidityControl/Commands/WriteAttributes", uic_mqtt_dotdot_on_by_group_unify_humidity_control_WriteAttributes);
     uic_mqtt_subscribe("ucl/by-group/+/UnifyHumidityControl/Commands/ModeSet", uic_mqtt_dotdot_on_by_group_unify_humidity_control_mode_set);
     uic_mqtt_subscribe("ucl/by-group/+/UnifyHumidityControl/Commands/SetpointSet", uic_mqtt_dotdot_on_by_group_unify_humidity_control_setpoint_set);
diff --git a/components/uic_dotdot_mqtt/zap-generated/src/dotdot_mqtt_helpers.cpp b/components/uic_dotdot_mqtt/zap-generated/src/dotdot_mqtt_helpers.cpp
index 3cfdb34365..63daf43fec 100644
--- a/components/uic_dotdot_mqtt/zap-generated/src/dotdot_mqtt_helpers.cpp
+++ b/components/uic_dotdot_mqtt/zap-generated/src/dotdot_mqtt_helpers.cpp
@@ -10473,6 +10473,57 @@ std::string get_enum_value_name(
   #endif
   }
 
+  if (64801 == cluster_id) {
+  #ifdef UNIFY_SCHEDULE_ENTRY_LOCK_SLOTS_WEEK_DAY_ENUM_NAME_AVAILABLE
+    if (1 == attribute_id) {
+      // FIXME: Some attributes don't work because multi-upper case names end up like this: unify_schedule_entry_lockslots_week_day instead of this: unify_schedule_entry_lock_slots_week_day
+      return unify_schedule_entry_lock_slots_week_day_get_enum_value_name(value);
+    }
+  #endif
+  #ifdef UNIFY_SCHEDULE_ENTRY_LOCK_SLOTS_YEAR_DAY_ENUM_NAME_AVAILABLE
+    if (2 == attribute_id) {
+      // FIXME: Some attributes don't work because multi-upper case names end up like this: unify_schedule_entry_lockslots_year_day instead of this: unify_schedule_entry_lock_slots_year_day
+      return unify_schedule_entry_lock_slots_year_day_get_enum_value_name(value);
+    }
+  #endif
+  #ifdef UNIFY_SCHEDULE_ENTRY_LOCK_SIGNTZO_ENUM_NAME_AVAILABLE
+    if (3 == attribute_id) {
+      // FIXME: Some attributes don't work because multi-upper case names end up like this: unify_schedule_entry_locksigntzo instead of this: unify_schedule_entry_lock_signtzo
+      return unify_schedule_entry_lock_signtzo_get_enum_value_name(value);
+    }
+  #endif
+  #ifdef UNIFY_SCHEDULE_ENTRY_LOCK_HOURTZO_ENUM_NAME_AVAILABLE
+    if (4 == attribute_id) {
+      // FIXME: Some attributes don't work because multi-upper case names end up like this: unify_schedule_entry_lockhourtzo instead of this: unify_schedule_entry_lock_hourtzo
+      return unify_schedule_entry_lock_hourtzo_get_enum_value_name(value);
+    }
+  #endif
+  #ifdef UNIFY_SCHEDULE_ENTRY_LOCK_MINUTETZO_ENUM_NAME_AVAILABLE
+    if (5 == attribute_id) {
+      // FIXME: Some attributes don't work because multi-upper case names end up like this: unify_schedule_entry_lockminutetzo instead of this: unify_schedule_entry_lock_minutetzo
+      return unify_schedule_entry_lock_minutetzo_get_enum_value_name(value);
+    }
+  #endif
+  #ifdef UNIFY_SCHEDULE_ENTRY_LOCK_DST_OFFSET_SIGN_ENUM_NAME_AVAILABLE
+    if (6 == attribute_id) {
+      // FIXME: Some attributes don't work because multi-upper case names end up like this: unify_schedule_entry_lockdst_offset_sign instead of this: unify_schedule_entry_lock_dst_offset_sign
+      return unify_schedule_entry_lock_dst_offset_sign_get_enum_value_name(value);
+    }
+  #endif
+  #ifdef UNIFY_SCHEDULE_ENTRY_LOCK_DST_OFFSET_MINUTE_ENUM_NAME_AVAILABLE
+    if (7 == attribute_id) {
+      // FIXME: Some attributes don't work because multi-upper case names end up like this: unify_schedule_entry_lockdst_offset_minute instead of this: unify_schedule_entry_lock_dst_offset_minute
+      return unify_schedule_entry_lock_dst_offset_minute_get_enum_value_name(value);
+    }
+  #endif
+  #ifdef UNIFY_SCHEDULE_ENTRY_LOCK_NUMBER_OF_SLOTS_DAILY_REPEATING_ENUM_NAME_AVAILABLE
+    if (8 == attribute_id) {
+      // FIXME: Some attributes don't work because multi-upper case names end up like this: unify_schedule_entry_locknumber_of_slots_daily_repeating instead of this: unify_schedule_entry_lock_number_of_slots_daily_repeating
+      return unify_schedule_entry_lock_number_of_slots_daily_repeating_get_enum_value_name(value);
+    }
+  #endif
+  }
+
   if (64928 == cluster_id) {
   #ifdef UNIFY_HUMIDITY_CONTROL_REPORTING_MODE_ENUM_NAME_AVAILABLE
     if (1 == attribute_id) {
@@ -14995,6 +15046,57 @@ uint32_t get_enum_name_value(
   #endif
   }
 
+  if (64801 == cluster_id) {
+  #ifdef UNIFY_SCHEDULE_ENTRY_LOCK_SLOTS_WEEK_DAY_ENUM_NAME_AVAILABLE
+    if (1 == attribute_id) {
+      // FIXME: Some attributes don't work because multi-upper case names end up like this: unify_schedule_entry_lockslots_week_day instead of this: unify_schedule_entry_lock_slots_week_day
+      return unify_schedule_entry_lock_slots_week_day_get_enum_value_number(name);
+    }
+  #endif
+  #ifdef UNIFY_SCHEDULE_ENTRY_LOCK_SLOTS_YEAR_DAY_ENUM_NAME_AVAILABLE
+    if (2 == attribute_id) {
+      // FIXME: Some attributes don't work because multi-upper case names end up like this: unify_schedule_entry_lockslots_year_day instead of this: unify_schedule_entry_lock_slots_year_day
+      return unify_schedule_entry_lock_slots_year_day_get_enum_value_number(name);
+    }
+  #endif
+  #ifdef UNIFY_SCHEDULE_ENTRY_LOCK_SIGNTZO_ENUM_NAME_AVAILABLE
+    if (3 == attribute_id) {
+      // FIXME: Some attributes don't work because multi-upper case names end up like this: unify_schedule_entry_locksigntzo instead of this: unify_schedule_entry_lock_signtzo
+      return unify_schedule_entry_lock_signtzo_get_enum_value_number(name);
+    }
+  #endif
+  #ifdef UNIFY_SCHEDULE_ENTRY_LOCK_HOURTZO_ENUM_NAME_AVAILABLE
+    if (4 == attribute_id) {
+      // FIXME: Some attributes don't work because multi-upper case names end up like this: unify_schedule_entry_lockhourtzo instead of this: unify_schedule_entry_lock_hourtzo
+      return unify_schedule_entry_lock_hourtzo_get_enum_value_number(name);
+    }
+  #endif
+  #ifdef UNIFY_SCHEDULE_ENTRY_LOCK_MINUTETZO_ENUM_NAME_AVAILABLE
+    if (5 == attribute_id) {
+      // FIXME: Some attributes don't work because multi-upper case names end up like this: unify_schedule_entry_lockminutetzo instead of this: unify_schedule_entry_lock_minutetzo
+      return unify_schedule_entry_lock_minutetzo_get_enum_value_number(name);
+    }
+  #endif
+  #ifdef UNIFY_SCHEDULE_ENTRY_LOCK_DST_OFFSET_SIGN_ENUM_NAME_AVAILABLE
+    if (6 == attribute_id) {
+      // FIXME: Some attributes don't work because multi-upper case names end up like this: unify_schedule_entry_lockdst_offset_sign instead of this: unify_schedule_entry_lock_dst_offset_sign
+      return unify_schedule_entry_lock_dst_offset_sign_get_enum_value_number(name);
+    }
+  #endif
+  #ifdef UNIFY_SCHEDULE_ENTRY_LOCK_DST_OFFSET_MINUTE_ENUM_NAME_AVAILABLE
+    if (7 == attribute_id) {
+      // FIXME: Some attributes don't work because multi-upper case names end up like this: unify_schedule_entry_lockdst_offset_minute instead of this: unify_schedule_entry_lock_dst_offset_minute
+      return unify_schedule_entry_lock_dst_offset_minute_get_enum_value_number(name);
+    }
+  #endif
+  #ifdef UNIFY_SCHEDULE_ENTRY_LOCK_NUMBER_OF_SLOTS_DAILY_REPEATING_ENUM_NAME_AVAILABLE
+    if (8 == attribute_id) {
+      // FIXME: Some attributes don't work because multi-upper case names end up like this: unify_schedule_entry_locknumber_of_slots_daily_repeating instead of this: unify_schedule_entry_lock_number_of_slots_daily_repeating
+      return unify_schedule_entry_lock_number_of_slots_daily_repeating_get_enum_value_number(name);
+    }
+  #endif
+  }
+
   if (64928 == cluster_id) {
   #ifdef UNIFY_HUMIDITY_CONTROL_REPORTING_MODE_ENUM_NAME_AVAILABLE
     if (1 == attribute_id) {
diff --git a/components/uic_dotdot_mqtt/zap-generated/src/dotdot_mqtt_send_commands.cpp b/components/uic_dotdot_mqtt/zap-generated/src/dotdot_mqtt_send_commands.cpp
index 42fbbf8671..2f17f4fceb 100644
--- a/components/uic_dotdot_mqtt/zap-generated/src/dotdot_mqtt_send_commands.cpp
+++ b/components/uic_dotdot_mqtt/zap-generated/src/dotdot_mqtt_send_commands.cpp
@@ -13708,6 +13708,228 @@ void uic_mqtt_dotdot_unify_fan_control_publish_turn_off_command_to_group(
                    false);
 }
 
+/**
+ * @brief Sends/Publishes a ScheduleEntryLockWeekDayReport command for
+ * the UnifyScheduleEntryLock cluster to a destination.
+ *
+ * Publication will be made at the following topic
+ * ucl/by-unid/UNID/epID/UnifyScheduleEntryLock/Commands/ScheduleEntryLockWeekDayReport
+ *
+ * @param destination_unid      The UNID of the node that should receive the command.
+ * 
+ * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
+ * 
+ * 
+ * @param fields                Struct pointer with the fields value of the command
+ * 
+ */
+void uic_mqtt_dotdot_unify_schedule_entry_lock_publish_schedule_entry_lock_week_day_report_command(
+  const dotdot_unid_t destination_unid,
+  const dotdot_endpoint_id_t destination_endpoint,
+  const uic_mqtt_dotdot_unify_schedule_entry_lock_command_schedule_entry_lock_week_day_report_fields_t *fields
+  
+) {
+  // Create the topic
+  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
+                      std::to_string(destination_endpoint) + "/";
+  topic += "UnifyScheduleEntryLock/Commands/ScheduleEntryLockWeekDayReport";
+
+
+  std::string payload =
+    get_json_payload_for_unify_schedule_entry_lock_schedule_entry_lock_week_day_report_command(
+    fields);
+
+  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());
+
+  // Publish our command, not retained
+  uic_mqtt_publish(topic.c_str(),
+                   payload.c_str(),
+                   payload.size(),
+                   false);
+}
+
+/**
+ * @brief Sends/Publishes a ScheduleEntryLockWeekDayReport command for
+ * the UnifyScheduleEntryLock cluster to a group.
+ *
+ * Publication will be made at the following topic
+ * ucl/by-group/GroupID/UnifyScheduleEntryLock/Commands/ScheduleEntryLockWeekDayReport
+ *
+ * @param destination_group_id  The GroupID that should receive the command.
+ * 
+ * @param fields                Struct pointer with the fields value of the command
+ * 
+ */
+void uic_mqtt_dotdot_unify_schedule_entry_lock_publish_schedule_entry_lock_week_day_report_command_to_group(
+  uint16_t destination_group_id,
+  const uic_mqtt_dotdot_unify_schedule_entry_lock_command_schedule_entry_lock_week_day_report_fields_t *fields
+  
+){
+  // Create the topic
+  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
+                      "/UnifyScheduleEntryLock/Commands/ScheduleEntryLockWeekDayReport";
+
+  std::string payload =
+    get_json_payload_for_unify_schedule_entry_lock_schedule_entry_lock_week_day_report_command(
+    fields);
+
+  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());
+
+  // Publish our command, not retained
+  uic_mqtt_publish(topic.c_str(),
+                   payload.c_str(),
+                   payload.size(),
+                   false);
+}
+
+/**
+ * @brief Sends/Publishes a ScheduleEntryLockYearDayReport command for
+ * the UnifyScheduleEntryLock cluster to a destination.
+ *
+ * Publication will be made at the following topic
+ * ucl/by-unid/UNID/epID/UnifyScheduleEntryLock/Commands/ScheduleEntryLockYearDayReport
+ *
+ * @param destination_unid      The UNID of the node that should receive the command.
+ * 
+ * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
+ * 
+ * 
+ * @param fields                Struct pointer with the fields value of the command
+ * 
+ */
+void uic_mqtt_dotdot_unify_schedule_entry_lock_publish_schedule_entry_lock_year_day_report_command(
+  const dotdot_unid_t destination_unid,
+  const dotdot_endpoint_id_t destination_endpoint,
+  const uic_mqtt_dotdot_unify_schedule_entry_lock_command_schedule_entry_lock_year_day_report_fields_t *fields
+  
+) {
+  // Create the topic
+  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
+                      std::to_string(destination_endpoint) + "/";
+  topic += "UnifyScheduleEntryLock/Commands/ScheduleEntryLockYearDayReport";
+
+
+  std::string payload =
+    get_json_payload_for_unify_schedule_entry_lock_schedule_entry_lock_year_day_report_command(
+    fields);
+
+  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());
+
+  // Publish our command, not retained
+  uic_mqtt_publish(topic.c_str(),
+                   payload.c_str(),
+                   payload.size(),
+                   false);
+}
+
+/**
+ * @brief Sends/Publishes a ScheduleEntryLockYearDayReport command for
+ * the UnifyScheduleEntryLock cluster to a group.
+ *
+ * Publication will be made at the following topic
+ * ucl/by-group/GroupID/UnifyScheduleEntryLock/Commands/ScheduleEntryLockYearDayReport
+ *
+ * @param destination_group_id  The GroupID that should receive the command.
+ * 
+ * @param fields                Struct pointer with the fields value of the command
+ * 
+ */
+void uic_mqtt_dotdot_unify_schedule_entry_lock_publish_schedule_entry_lock_year_day_report_command_to_group(
+  uint16_t destination_group_id,
+  const uic_mqtt_dotdot_unify_schedule_entry_lock_command_schedule_entry_lock_year_day_report_fields_t *fields
+  
+){
+  // Create the topic
+  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
+                      "/UnifyScheduleEntryLock/Commands/ScheduleEntryLockYearDayReport";
+
+  std::string payload =
+    get_json_payload_for_unify_schedule_entry_lock_schedule_entry_lock_year_day_report_command(
+    fields);
+
+  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());
+
+  // Publish our command, not retained
+  uic_mqtt_publish(topic.c_str(),
+                   payload.c_str(),
+                   payload.size(),
+                   false);
+}
+
+/**
+ * @brief Sends/Publishes a ScheduleEntryLockDailyRepeatingReport command for
+ * the UnifyScheduleEntryLock cluster to a destination.
+ *
+ * Publication will be made at the following topic
+ * ucl/by-unid/UNID/epID/UnifyScheduleEntryLock/Commands/ScheduleEntryLockDailyRepeatingReport
+ *
+ * @param destination_unid      The UNID of the node that should receive the command.
+ * 
+ * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
+ * 
+ * 
+ * @param fields                Struct pointer with the fields value of the command
+ * 
+ */
+void uic_mqtt_dotdot_unify_schedule_entry_lock_publish_schedule_entry_lock_daily_repeating_report_command(
+  const dotdot_unid_t destination_unid,
+  const dotdot_endpoint_id_t destination_endpoint,
+  const uic_mqtt_dotdot_unify_schedule_entry_lock_command_schedule_entry_lock_daily_repeating_report_fields_t *fields
+  
+) {
+  // Create the topic
+  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
+                      std::to_string(destination_endpoint) + "/";
+  topic += "UnifyScheduleEntryLock/Commands/ScheduleEntryLockDailyRepeatingReport";
+
+
+  std::string payload =
+    get_json_payload_for_unify_schedule_entry_lock_schedule_entry_lock_daily_repeating_report_command(
+    fields);
+
+  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());
+
+  // Publish our command, not retained
+  uic_mqtt_publish(topic.c_str(),
+                   payload.c_str(),
+                   payload.size(),
+                   false);
+}
+
+/**
+ * @brief Sends/Publishes a ScheduleEntryLockDailyRepeatingReport command for
+ * the UnifyScheduleEntryLock cluster to a group.
+ *
+ * Publication will be made at the following topic
+ * ucl/by-group/GroupID/UnifyScheduleEntryLock/Commands/ScheduleEntryLockDailyRepeatingReport
+ *
+ * @param destination_group_id  The GroupID that should receive the command.
+ * 
+ * @param fields                Struct pointer with the fields value of the command
+ * 
+ */
+void uic_mqtt_dotdot_unify_schedule_entry_lock_publish_schedule_entry_lock_daily_repeating_report_command_to_group(
+  uint16_t destination_group_id,
+  const uic_mqtt_dotdot_unify_schedule_entry_lock_command_schedule_entry_lock_daily_repeating_report_fields_t *fields
+  
+){
+  // Create the topic
+  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
+                      "/UnifyScheduleEntryLock/Commands/ScheduleEntryLockDailyRepeatingReport";
+
+  std::string payload =
+    get_json_payload_for_unify_schedule_entry_lock_schedule_entry_lock_daily_repeating_report_command(
+    fields);
+
+  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());
+
+  // Publish our command, not retained
+  uic_mqtt_publish(topic.c_str(),
+                   payload.c_str(),
+                   payload.size(),
+                   false);
+}
+
 /**
  * @brief Sends/Publishes a ModeSet command for
  * the UnifyHumidityControl cluster to a destination.
diff --git a/components/uic_dotdot_mqtt/zap-generated/src/dotdot_mqtt_supported_generated_commands.cpp b/components/uic_dotdot_mqtt/zap-generated/src/dotdot_mqtt_supported_generated_commands.cpp
index f7db295e9c..39ed2297f0 100644
--- a/components/uic_dotdot_mqtt/zap-generated/src/dotdot_mqtt_supported_generated_commands.cpp
+++ b/components/uic_dotdot_mqtt/zap-generated/src/dotdot_mqtt_supported_generated_commands.cpp
@@ -2856,6 +2856,58 @@ void uic_mqtt_dotdot_unify_thermostat_publish_supported_generated_commands(
 }
 
 
+/**
+ * @brief Sends/Publishes a the SupportedGenerated commands for
+ * the UnifyScheduleEntryLock cluster for a UNID/Endpoint
+ *
+ * Publication will be made at the following topic
+ * ucl/by-unid/UNID/epID/UnifyScheduleEntryLock/SupportedGeneratedCommands
+ *
+ * @param unid      The UNID of the node on behalf of which the advertisment is made
+ * 
+ * @param endpoint  The Endpoint ID of the node on behalf of which the advertisment is made
+ * 
+ * @param command_list      Struct pointer with the fields value indicating if
+ *                          individual commands can be generated.
+ */
+void uic_mqtt_dotdot_unify_schedule_entry_lock_publish_supported_generated_commands(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint,
+  const uic_mqtt_dotdot_unify_schedule_entry_lock_supported_commands_t *command_list)
+{
+  std::string topic = "ucl/by-unid/" + std::string(unid);
+  topic +=  "/ep"+ std::to_string(endpoint);
+  topic +=  "/UnifyScheduleEntryLock/SupportedGeneratedCommands";
+
+  // Assemble of vector of strings for the Supported Commands:
+  std::vector<std::string> command_vector;
+  if (command_list->schedule_entry_lock_week_day_report == true) {
+    command_vector.emplace_back("ScheduleEntryLockWeekDayReport");
+  }
+  if (command_list->schedule_entry_lock_year_day_report == true) {
+    command_vector.emplace_back("ScheduleEntryLockYearDayReport");
+  }
+  if (command_list->schedule_entry_lock_daily_repeating_report == true) {
+    command_vector.emplace_back("ScheduleEntryLockDailyRepeatingReport");
+  }
+  if (command_list->write_attributes == true) {
+    command_vector.emplace_back("WriteAttributes");
+  }
+
+  // JSONify, then Stringify
+  nlohmann::json json_payload;
+  json_payload["value"] = command_vector;
+  std::string string_payload = json_payload.dump();
+
+  // Publish to MQTT
+  uic_mqtt_publish(topic.c_str(),
+                   string_payload.c_str(),
+                   string_payload.length(),
+                   true);
+
+}
+
+
 /**
  * @brief Sends/Publishes a the SupportedGenerated commands for
  * the UnifyHumidityControl cluster for a UNID/Endpoint
diff --git a/components/uic_dotdot_mqtt/zap-generated/test/dotdot_mqtt_test.include b/components/uic_dotdot_mqtt/zap-generated/test/dotdot_mqtt_test.include
index c1fe725721..64c6d7fe29 100644
--- a/components/uic_dotdot_mqtt/zap-generated/test/dotdot_mqtt_test.include
+++ b/components/uic_dotdot_mqtt/zap-generated/test/dotdot_mqtt_test.include
@@ -2995,6 +2995,91 @@ static sl_status_t uic_mqtt_dotdot_unify_fan_control_turn_off_callback_func(
   return SL_STATUS_OK;
 }
 
+static unsigned int uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_week_day_report_callback_count;
+static sl_status_t uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_week_day_report_callback_func(
+    dotdot_unid_t unid,
+    dotdot_endpoint_id_t endpoint,
+    uic_mqtt_dotdot_callback_call_type_t callback_type,
+    uint8_t user_identifier,
+
+    uint8_t schedule_slotid,
+
+    uint8_t day_of_week,
+
+    uint8_t start_hour,
+
+    uint8_t start_minute,
+
+    uint8_t stop_hour,
+
+    uint8_t stop_minute
+
+) {
+  uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_week_day_report_callback_count++;
+  num_command_callbacks++;
+  return SL_STATUS_OK;
+}
+
+static unsigned int uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_year_day_report_callback_count;
+static sl_status_t uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_year_day_report_callback_func(
+    dotdot_unid_t unid,
+    dotdot_endpoint_id_t endpoint,
+    uic_mqtt_dotdot_callback_call_type_t callback_type,
+    uint8_t set_action,
+
+    uint8_t user_identifier,
+
+    uint8_t schedule_slotid,
+
+    uint8_t start_year,
+
+    uint8_t start_day,
+
+    uint8_t start_hour,
+
+    uint8_t start_minute,
+
+    uint8_t stop_year,
+
+    uint8_t stop_day,
+
+    uint8_t stop_hour,
+
+    uint8_t stop_minute
+
+) {
+  uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_year_day_report_callback_count++;
+  num_command_callbacks++;
+  return SL_STATUS_OK;
+}
+
+static unsigned int uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_daily_repeating_report_callback_count;
+static sl_status_t uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_daily_repeating_report_callback_func(
+    dotdot_unid_t unid,
+    dotdot_endpoint_id_t endpoint,
+    uic_mqtt_dotdot_callback_call_type_t callback_type,
+    uint8_t set_action,
+
+    uint8_t user_identifier,
+
+    uint8_t schedule_slotid,
+
+    uint8_t week_day_bitmask,
+
+    uint8_t start_hour,
+
+    uint8_t start_minute,
+
+    uint8_t duration_hour,
+
+    uint8_t duration_minute
+
+) {
+  uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_daily_repeating_report_callback_count++;
+  num_command_callbacks++;
+  return SL_STATUS_OK;
+}
+
 static unsigned int uic_mqtt_dotdot_unify_humidity_control_mode_set_callback_count;
 static sl_status_t uic_mqtt_dotdot_unify_humidity_control_mode_set_callback_func(
     dotdot_unid_t unid,
@@ -3409,6 +3494,12 @@ static unsigned int set_all_callbacks()
   num_callbacks++;
   uic_mqtt_dotdot_unify_fan_control_turn_off_callback_set(&uic_mqtt_dotdot_unify_fan_control_turn_off_callback_func);
   num_callbacks++;
+  uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_week_day_report_callback_set(&uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_week_day_report_callback_func);
+  num_callbacks++;
+  uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_year_day_report_callback_set(&uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_year_day_report_callback_func);
+  num_callbacks++;
+  uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_daily_repeating_report_callback_set(&uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_daily_repeating_report_callback_func);
+  num_callbacks++;
   uic_mqtt_dotdot_unify_humidity_control_mode_set_callback_set(&uic_mqtt_dotdot_unify_humidity_control_mode_set_callback_func);
   num_callbacks++;
   uic_mqtt_dotdot_unify_humidity_control_setpoint_set_callback_set(&uic_mqtt_dotdot_unify_humidity_control_setpoint_set_callback_func);
@@ -3661,6 +3752,10 @@ static void unset_all_callbacks()
   uic_mqtt_dotdot_unify_fan_control_turn_off_callback_clear();
   uic_mqtt_dotdot_clear_unify_fan_control_write_attributes_callbacks();
   uic_mqtt_dotdot_clear_unify_thermostat_write_attributes_callbacks();
+  uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_week_day_report_callback_clear();
+  uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_year_day_report_callback_clear();
+  uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_daily_repeating_report_callback_clear();
+  uic_mqtt_dotdot_clear_unify_schedule_entry_lock_write_attributes_callbacks();
   uic_mqtt_dotdot_unify_humidity_control_mode_set_callback_clear();
   uic_mqtt_dotdot_unify_humidity_control_setpoint_set_callback_clear();
   uic_mqtt_dotdot_clear_unify_humidity_control_write_attributes_callbacks();
@@ -3858,6 +3953,9 @@ static void reset_callback_counters()
   uic_mqtt_dotdot_protocol_controller_network_management_write_callback_count = 0;
   uic_mqtt_dotdot_unify_fan_control_set_fan_mode_callback_count = 0;
   uic_mqtt_dotdot_unify_fan_control_turn_off_callback_count = 0;
+  uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_week_day_report_callback_count = 0;
+  uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_year_day_report_callback_count = 0;
+  uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_daily_repeating_report_callback_count = 0;
   uic_mqtt_dotdot_unify_humidity_control_mode_set_callback_count = 0;
   uic_mqtt_dotdot_unify_humidity_control_setpoint_set_callback_count = 0;
 }
diff --git a/components/unify_dotdot_attribute_store/zap-generated/include/dotdot_attributes.uam b/components/unify_dotdot_attribute_store/zap-generated/include/dotdot_attributes.uam
index 0c168c053a..df968cbd76 100644
--- a/components/unify_dotdot_attribute_store/zap-generated/include/dotdot_attributes.uam
+++ b/components/unify_dotdot_attribute_store/zap-generated/include/dotdot_attributes.uam
@@ -877,6 +877,16 @@ def DOTDOT_ATTRIBUTE_ID_UNIFY_THERMOSTAT_THERMOSTAT_MODE 0xfd150001
 def DOTDOT_ATTRIBUTE_ID_UNIFY_THERMOSTAT_SUPPORTED_THERMOSTAT_MODE 0xfd150002
 def DOTDOT_ATTRIBUTE_ID_UNIFY_THERMOSTAT_OPERATING_STATE 0xfd150003
 
+// This represents the attributes in the DotDot UnifyScheduleEntryLock cluster
+def DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_SLOTS_WEEK_DAY 0xfd210001
+def DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_SLOTS_YEAR_DAY 0xfd210002
+def DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_SIGNTZO 0xfd210003
+def DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_HOURTZO 0xfd210004
+def DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_MINUTETZO 0xfd210005
+def DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_DST_OFFSET_SIGN 0xfd210006
+def DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_DST_OFFSET_MINUTE 0xfd210007
+def DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_NUMBER_OF_SLOTS_DAILY_REPEATING 0xfd210008
+
 // This represents the attributes in the DotDot UnifyHumidityControl cluster
 def DOTDOT_ATTRIBUTE_ID_UNIFY_HUMIDITY_CONTROL_REPORTING_MODE 0xfda00001
 def DOTDOT_ATTRIBUTE_ID_UNIFY_HUMIDITY_CONTROL_SUPPORTED_REPORTING_MODE 0xfda00002
diff --git a/components/unify_dotdot_attribute_store/zap-generated/include/dotdot_attributes_camel_case.uam b/components/unify_dotdot_attribute_store/zap-generated/include/dotdot_attributes_camel_case.uam
index b867ea5a05..4c4f44f2ba 100644
--- a/components/unify_dotdot_attribute_store/zap-generated/include/dotdot_attributes_camel_case.uam
+++ b/components/unify_dotdot_attribute_store/zap-generated/include/dotdot_attributes_camel_case.uam
@@ -877,6 +877,16 @@ def zb_ThermostatMode 0xfd150001
 def zb_SupportedThermostatMode 0xfd150002
 def zb_OperatingState 0xfd150003
 
+// This represents short CamelCase labels the attributes in the DotDot UnifyScheduleEntryLock cluster
+def zb_SlotsWeekDay 0xfd210001
+def zb_SlotsYearDay 0xfd210002
+def zb_SignTZO 0xfd210003
+def zb_HourTZO 0xfd210004
+def zb_MinuteTZO 0xfd210005
+def zb_DSTOffsetSign 0xfd210006
+def zb_DSTOffsetMinute 0xfd210007
+def zb_NumberOfSlotsDailyRepeating 0xfd210008
+
 // This represents short CamelCase labels the attributes in the DotDot UnifyHumidityControl cluster
 def zb_ReportingMode 0xfda00001
 def zb_SupportedReportingMode 0xfda00002
diff --git a/components/unify_dotdot_attribute_store/zap-generated/include/unify_dotdot_attribute_store_helpers.h b/components/unify_dotdot_attribute_store/zap-generated/include/unify_dotdot_attribute_store_helpers.h
index e98230c88f..df476f6504 100644
--- a/components/unify_dotdot_attribute_store/zap-generated/include/unify_dotdot_attribute_store_helpers.h
+++ b/components/unify_dotdot_attribute_store/zap-generated/include/unify_dotdot_attribute_store_helpers.h
@@ -76496,6 +76496,882 @@ bool dotdot_is_any_unify_thermostat_writable_attribute_supported(
   const dotdot_unid_t unid,
   const dotdot_endpoint_id_t endpoint_id);
 
+////////////////////////////////////////////////////////////////////////////////
+// Start of cluster UnifyScheduleEntryLock
+////////////////////////////////////////////////////////////////////////////////
+// UnifyScheduleEntryLock SlotsWeekDay
+/**
+ * @brief Verifies if the DotDot UnifyScheduleEntryLock - SlotsWeekDay is supported
+ * under a UNID/EndpoinID
+ *
+ * @param unid          Node's UNID
+ * @param endpoint_id   Endpoint ID
+ *
+ * @returns true if SlotsWeekDay is supported
+ * @returns false if SlotsWeekDay is not supported
+ */
+bool dotdot_is_supported_unify_schedule_entry_lock_slots_week_day (
+              const dotdot_unid_t unid, const dotdot_endpoint_id_t endpoint_id);
+
+/**
+ * @brief Gets the DotDot UnifyScheduleEntryLock - SlotsWeekDay attribute value under a UNID/EndpoinID
+ *
+ * @param unid          Node's UNID
+ * @param endpoint_id   Endpoint ID
+ * @param value_state   value state to get,
+ *                      see \ref attribute_store_get_node_attribute_value
+ * 
+ *
+ * @returns SlotsWeekDay attribute
+ */
+uint8_t dotdot_get_unify_schedule_entry_lock_slots_week_day(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id,
+  attribute_store_node_value_state_t value_state);
+
+/**
+ * @brief Set the DotDot UnifyScheduleEntryLock - SlotsWeekDay attribute under a UNID/EndpoinID
+ *
+ * @param unid          Node's UNID
+ * @param endpoint_id   Endpoint ID
+ * @param value_state   value state to write for the node,
+ *                      see \ref attribute_store_set_node_attribute_value
+ * 
+ * @param new_slots_week_day new value to set
+ * @returns sl_status_t SL_STATUS_OK on success
+ */
+sl_status_t dotdot_set_unify_schedule_entry_lock_slots_week_day(
+  const dotdot_unid_t unid,
+  dotdot_endpoint_id_t endpoint_id,
+  attribute_store_node_value_state_t value_state,
+  uint8_t new_slots_week_day
+  );
+
+/**
+ * @brief Undefines the Reported value of the the DotDot UnifyScheduleEntryLock - SlotsWeekDay
+ * attribute under a UNID/EndpoinID
+ *
+ * @param unid          Node's UNID
+ * @param endpoint_id   Endpoint ID
+ * @returns sl_status_t SL_STATUS_OK on success
+ */
+sl_status_t dotdot_unify_schedule_entry_lock_slots_week_day_undefine_reported(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id);
+
+/**
+ * @brief Undefines the Desired value of the DotDot
+ * UnifyScheduleEntryLock - SlotsWeekDay attribute under a UNID/EndpointID
+ *
+ * @param unid          Node's UNID
+ * @param endpoint_id   Endpoint ID
+ * @returns sl_status_t SL_STATUS_OK on success
+ */
+sl_status_t dotdot_unify_schedule_entry_lock_slots_week_day_undefine_desired(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id);
+
+/**
+ * @brief Checks if the reported value is defined for the DotDot
+ * UnifyScheduleEntryLock - SlotsWeekDay attribute under a UNID/EndpointID
+ *
+ * @param unid          Node's UNID
+ * @param endpoint_id   Endpoint ID
+ * @returns true if defined, false is undefined or non-existent
+ */
+bool dotdot_unify_schedule_entry_lock_slots_week_day_is_reported_defined(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id);
+
+/**
+ * @brief Checks if the desired value is defined for the DotDot
+ * UnifyScheduleEntryLock - SlotsWeekDay attribute under a UNID/EndpointID
+ *
+ * @param unid          Node's UNID
+ * @param endpoint_id   Endpoint ID
+ * @returns true if defined, false is undefined or non-existent
+ */
+bool dotdot_unify_schedule_entry_lock_slots_week_day_is_desired_defined(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id);
+
+/**
+ * @brief Creates a DotDot UnifyScheduleEntryLock - SlotsWeekDay attribute under a UNID/EndpoinID
+ *
+ * @param unid          Node's UNID
+ * @param endpoint_id   Endpoint ID
+ * @returns sl_status_t SL_STATUS_OK on success
+ */
+sl_status_t dotdot_create_unify_schedule_entry_lock_slots_week_day(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id);
+// UnifyScheduleEntryLock SlotsYearDay
+/**
+ * @brief Verifies if the DotDot UnifyScheduleEntryLock - SlotsYearDay is supported
+ * under a UNID/EndpoinID
+ *
+ * @param unid          Node's UNID
+ * @param endpoint_id   Endpoint ID
+ *
+ * @returns true if SlotsYearDay is supported
+ * @returns false if SlotsYearDay is not supported
+ */
+bool dotdot_is_supported_unify_schedule_entry_lock_slots_year_day (
+              const dotdot_unid_t unid, const dotdot_endpoint_id_t endpoint_id);
+
+/**
+ * @brief Gets the DotDot UnifyScheduleEntryLock - SlotsYearDay attribute value under a UNID/EndpoinID
+ *
+ * @param unid          Node's UNID
+ * @param endpoint_id   Endpoint ID
+ * @param value_state   value state to get,
+ *                      see \ref attribute_store_get_node_attribute_value
+ * 
+ *
+ * @returns SlotsYearDay attribute
+ */
+uint8_t dotdot_get_unify_schedule_entry_lock_slots_year_day(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id,
+  attribute_store_node_value_state_t value_state);
+
+/**
+ * @brief Set the DotDot UnifyScheduleEntryLock - SlotsYearDay attribute under a UNID/EndpoinID
+ *
+ * @param unid          Node's UNID
+ * @param endpoint_id   Endpoint ID
+ * @param value_state   value state to write for the node,
+ *                      see \ref attribute_store_set_node_attribute_value
+ * 
+ * @param new_slots_year_day new value to set
+ * @returns sl_status_t SL_STATUS_OK on success
+ */
+sl_status_t dotdot_set_unify_schedule_entry_lock_slots_year_day(
+  const dotdot_unid_t unid,
+  dotdot_endpoint_id_t endpoint_id,
+  attribute_store_node_value_state_t value_state,
+  uint8_t new_slots_year_day
+  );
+
+/**
+ * @brief Undefines the Reported value of the the DotDot UnifyScheduleEntryLock - SlotsYearDay
+ * attribute under a UNID/EndpoinID
+ *
+ * @param unid          Node's UNID
+ * @param endpoint_id   Endpoint ID
+ * @returns sl_status_t SL_STATUS_OK on success
+ */
+sl_status_t dotdot_unify_schedule_entry_lock_slots_year_day_undefine_reported(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id);
+
+/**
+ * @brief Undefines the Desired value of the DotDot
+ * UnifyScheduleEntryLock - SlotsYearDay attribute under a UNID/EndpointID
+ *
+ * @param unid          Node's UNID
+ * @param endpoint_id   Endpoint ID
+ * @returns sl_status_t SL_STATUS_OK on success
+ */
+sl_status_t dotdot_unify_schedule_entry_lock_slots_year_day_undefine_desired(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id);
+
+/**
+ * @brief Checks if the reported value is defined for the DotDot
+ * UnifyScheduleEntryLock - SlotsYearDay attribute under a UNID/EndpointID
+ *
+ * @param unid          Node's UNID
+ * @param endpoint_id   Endpoint ID
+ * @returns true if defined, false is undefined or non-existent
+ */
+bool dotdot_unify_schedule_entry_lock_slots_year_day_is_reported_defined(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id);
+
+/**
+ * @brief Checks if the desired value is defined for the DotDot
+ * UnifyScheduleEntryLock - SlotsYearDay attribute under a UNID/EndpointID
+ *
+ * @param unid          Node's UNID
+ * @param endpoint_id   Endpoint ID
+ * @returns true if defined, false is undefined or non-existent
+ */
+bool dotdot_unify_schedule_entry_lock_slots_year_day_is_desired_defined(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id);
+
+/**
+ * @brief Creates a DotDot UnifyScheduleEntryLock - SlotsYearDay attribute under a UNID/EndpoinID
+ *
+ * @param unid          Node's UNID
+ * @param endpoint_id   Endpoint ID
+ * @returns sl_status_t SL_STATUS_OK on success
+ */
+sl_status_t dotdot_create_unify_schedule_entry_lock_slots_year_day(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id);
+// UnifyScheduleEntryLock SignTZO
+/**
+ * @brief Verifies if the DotDot UnifyScheduleEntryLock - SignTZO is supported
+ * under a UNID/EndpoinID
+ *
+ * @param unid          Node's UNID
+ * @param endpoint_id   Endpoint ID
+ *
+ * @returns true if SignTZO is supported
+ * @returns false if SignTZO is not supported
+ */
+bool dotdot_is_supported_unify_schedule_entry_lock_signtzo (
+              const dotdot_unid_t unid, const dotdot_endpoint_id_t endpoint_id);
+
+/**
+ * @brief Gets the DotDot UnifyScheduleEntryLock - SignTZO attribute value under a UNID/EndpoinID
+ *
+ * @param unid          Node's UNID
+ * @param endpoint_id   Endpoint ID
+ * @param value_state   value state to get,
+ *                      see \ref attribute_store_get_node_attribute_value
+ * 
+ *
+ * @returns SignTZO attribute
+ */
+uint8_t dotdot_get_unify_schedule_entry_lock_signtzo(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id,
+  attribute_store_node_value_state_t value_state);
+
+/**
+ * @brief Set the DotDot UnifyScheduleEntryLock - SignTZO attribute under a UNID/EndpoinID
+ *
+ * @param unid          Node's UNID
+ * @param endpoint_id   Endpoint ID
+ * @param value_state   value state to write for the node,
+ *                      see \ref attribute_store_set_node_attribute_value
+ * 
+ * @param new_signtzo new value to set
+ * @returns sl_status_t SL_STATUS_OK on success
+ */
+sl_status_t dotdot_set_unify_schedule_entry_lock_signtzo(
+  const dotdot_unid_t unid,
+  dotdot_endpoint_id_t endpoint_id,
+  attribute_store_node_value_state_t value_state,
+  uint8_t new_signtzo
+  );
+
+/**
+ * @brief Undefines the Reported value of the the DotDot UnifyScheduleEntryLock - SignTZO
+ * attribute under a UNID/EndpoinID
+ *
+ * @param unid          Node's UNID
+ * @param endpoint_id   Endpoint ID
+ * @returns sl_status_t SL_STATUS_OK on success
+ */
+sl_status_t dotdot_unify_schedule_entry_lock_signtzo_undefine_reported(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id);
+
+/**
+ * @brief Undefines the Desired value of the DotDot
+ * UnifyScheduleEntryLock - SignTZO attribute under a UNID/EndpointID
+ *
+ * @param unid          Node's UNID
+ * @param endpoint_id   Endpoint ID
+ * @returns sl_status_t SL_STATUS_OK on success
+ */
+sl_status_t dotdot_unify_schedule_entry_lock_signtzo_undefine_desired(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id);
+
+/**
+ * @brief Checks if the reported value is defined for the DotDot
+ * UnifyScheduleEntryLock - SignTZO attribute under a UNID/EndpointID
+ *
+ * @param unid          Node's UNID
+ * @param endpoint_id   Endpoint ID
+ * @returns true if defined, false is undefined or non-existent
+ */
+bool dotdot_unify_schedule_entry_lock_signtzo_is_reported_defined(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id);
+
+/**
+ * @brief Checks if the desired value is defined for the DotDot
+ * UnifyScheduleEntryLock - SignTZO attribute under a UNID/EndpointID
+ *
+ * @param unid          Node's UNID
+ * @param endpoint_id   Endpoint ID
+ * @returns true if defined, false is undefined or non-existent
+ */
+bool dotdot_unify_schedule_entry_lock_signtzo_is_desired_defined(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id);
+
+/**
+ * @brief Creates a DotDot UnifyScheduleEntryLock - SignTZO attribute under a UNID/EndpoinID
+ *
+ * @param unid          Node's UNID
+ * @param endpoint_id   Endpoint ID
+ * @returns sl_status_t SL_STATUS_OK on success
+ */
+sl_status_t dotdot_create_unify_schedule_entry_lock_signtzo(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id);
+// UnifyScheduleEntryLock HourTZO
+/**
+ * @brief Verifies if the DotDot UnifyScheduleEntryLock - HourTZO is supported
+ * under a UNID/EndpoinID
+ *
+ * @param unid          Node's UNID
+ * @param endpoint_id   Endpoint ID
+ *
+ * @returns true if HourTZO is supported
+ * @returns false if HourTZO is not supported
+ */
+bool dotdot_is_supported_unify_schedule_entry_lock_hourtzo (
+              const dotdot_unid_t unid, const dotdot_endpoint_id_t endpoint_id);
+
+/**
+ * @brief Gets the DotDot UnifyScheduleEntryLock - HourTZO attribute value under a UNID/EndpoinID
+ *
+ * @param unid          Node's UNID
+ * @param endpoint_id   Endpoint ID
+ * @param value_state   value state to get,
+ *                      see \ref attribute_store_get_node_attribute_value
+ * 
+ *
+ * @returns HourTZO attribute
+ */
+uint8_t dotdot_get_unify_schedule_entry_lock_hourtzo(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id,
+  attribute_store_node_value_state_t value_state);
+
+/**
+ * @brief Set the DotDot UnifyScheduleEntryLock - HourTZO attribute under a UNID/EndpoinID
+ *
+ * @param unid          Node's UNID
+ * @param endpoint_id   Endpoint ID
+ * @param value_state   value state to write for the node,
+ *                      see \ref attribute_store_set_node_attribute_value
+ * 
+ * @param new_hourtzo new value to set
+ * @returns sl_status_t SL_STATUS_OK on success
+ */
+sl_status_t dotdot_set_unify_schedule_entry_lock_hourtzo(
+  const dotdot_unid_t unid,
+  dotdot_endpoint_id_t endpoint_id,
+  attribute_store_node_value_state_t value_state,
+  uint8_t new_hourtzo
+  );
+
+/**
+ * @brief Undefines the Reported value of the the DotDot UnifyScheduleEntryLock - HourTZO
+ * attribute under a UNID/EndpoinID
+ *
+ * @param unid          Node's UNID
+ * @param endpoint_id   Endpoint ID
+ * @returns sl_status_t SL_STATUS_OK on success
+ */
+sl_status_t dotdot_unify_schedule_entry_lock_hourtzo_undefine_reported(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id);
+
+/**
+ * @brief Undefines the Desired value of the DotDot
+ * UnifyScheduleEntryLock - HourTZO attribute under a UNID/EndpointID
+ *
+ * @param unid          Node's UNID
+ * @param endpoint_id   Endpoint ID
+ * @returns sl_status_t SL_STATUS_OK on success
+ */
+sl_status_t dotdot_unify_schedule_entry_lock_hourtzo_undefine_desired(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id);
+
+/**
+ * @brief Checks if the reported value is defined for the DotDot
+ * UnifyScheduleEntryLock - HourTZO attribute under a UNID/EndpointID
+ *
+ * @param unid          Node's UNID
+ * @param endpoint_id   Endpoint ID
+ * @returns true if defined, false is undefined or non-existent
+ */
+bool dotdot_unify_schedule_entry_lock_hourtzo_is_reported_defined(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id);
+
+/**
+ * @brief Checks if the desired value is defined for the DotDot
+ * UnifyScheduleEntryLock - HourTZO attribute under a UNID/EndpointID
+ *
+ * @param unid          Node's UNID
+ * @param endpoint_id   Endpoint ID
+ * @returns true if defined, false is undefined or non-existent
+ */
+bool dotdot_unify_schedule_entry_lock_hourtzo_is_desired_defined(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id);
+
+/**
+ * @brief Creates a DotDot UnifyScheduleEntryLock - HourTZO attribute under a UNID/EndpoinID
+ *
+ * @param unid          Node's UNID
+ * @param endpoint_id   Endpoint ID
+ * @returns sl_status_t SL_STATUS_OK on success
+ */
+sl_status_t dotdot_create_unify_schedule_entry_lock_hourtzo(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id);
+// UnifyScheduleEntryLock MinuteTZO
+/**
+ * @brief Verifies if the DotDot UnifyScheduleEntryLock - MinuteTZO is supported
+ * under a UNID/EndpoinID
+ *
+ * @param unid          Node's UNID
+ * @param endpoint_id   Endpoint ID
+ *
+ * @returns true if MinuteTZO is supported
+ * @returns false if MinuteTZO is not supported
+ */
+bool dotdot_is_supported_unify_schedule_entry_lock_minutetzo (
+              const dotdot_unid_t unid, const dotdot_endpoint_id_t endpoint_id);
+
+/**
+ * @brief Gets the DotDot UnifyScheduleEntryLock - MinuteTZO attribute value under a UNID/EndpoinID
+ *
+ * @param unid          Node's UNID
+ * @param endpoint_id   Endpoint ID
+ * @param value_state   value state to get,
+ *                      see \ref attribute_store_get_node_attribute_value
+ * 
+ *
+ * @returns MinuteTZO attribute
+ */
+uint8_t dotdot_get_unify_schedule_entry_lock_minutetzo(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id,
+  attribute_store_node_value_state_t value_state);
+
+/**
+ * @brief Set the DotDot UnifyScheduleEntryLock - MinuteTZO attribute under a UNID/EndpoinID
+ *
+ * @param unid          Node's UNID
+ * @param endpoint_id   Endpoint ID
+ * @param value_state   value state to write for the node,
+ *                      see \ref attribute_store_set_node_attribute_value
+ * 
+ * @param new_minutetzo new value to set
+ * @returns sl_status_t SL_STATUS_OK on success
+ */
+sl_status_t dotdot_set_unify_schedule_entry_lock_minutetzo(
+  const dotdot_unid_t unid,
+  dotdot_endpoint_id_t endpoint_id,
+  attribute_store_node_value_state_t value_state,
+  uint8_t new_minutetzo
+  );
+
+/**
+ * @brief Undefines the Reported value of the the DotDot UnifyScheduleEntryLock - MinuteTZO
+ * attribute under a UNID/EndpoinID
+ *
+ * @param unid          Node's UNID
+ * @param endpoint_id   Endpoint ID
+ * @returns sl_status_t SL_STATUS_OK on success
+ */
+sl_status_t dotdot_unify_schedule_entry_lock_minutetzo_undefine_reported(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id);
+
+/**
+ * @brief Undefines the Desired value of the DotDot
+ * UnifyScheduleEntryLock - MinuteTZO attribute under a UNID/EndpointID
+ *
+ * @param unid          Node's UNID
+ * @param endpoint_id   Endpoint ID
+ * @returns sl_status_t SL_STATUS_OK on success
+ */
+sl_status_t dotdot_unify_schedule_entry_lock_minutetzo_undefine_desired(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id);
+
+/**
+ * @brief Checks if the reported value is defined for the DotDot
+ * UnifyScheduleEntryLock - MinuteTZO attribute under a UNID/EndpointID
+ *
+ * @param unid          Node's UNID
+ * @param endpoint_id   Endpoint ID
+ * @returns true if defined, false is undefined or non-existent
+ */
+bool dotdot_unify_schedule_entry_lock_minutetzo_is_reported_defined(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id);
+
+/**
+ * @brief Checks if the desired value is defined for the DotDot
+ * UnifyScheduleEntryLock - MinuteTZO attribute under a UNID/EndpointID
+ *
+ * @param unid          Node's UNID
+ * @param endpoint_id   Endpoint ID
+ * @returns true if defined, false is undefined or non-existent
+ */
+bool dotdot_unify_schedule_entry_lock_minutetzo_is_desired_defined(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id);
+
+/**
+ * @brief Creates a DotDot UnifyScheduleEntryLock - MinuteTZO attribute under a UNID/EndpoinID
+ *
+ * @param unid          Node's UNID
+ * @param endpoint_id   Endpoint ID
+ * @returns sl_status_t SL_STATUS_OK on success
+ */
+sl_status_t dotdot_create_unify_schedule_entry_lock_minutetzo(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id);
+// UnifyScheduleEntryLock DSTOffsetSign
+/**
+ * @brief Verifies if the DotDot UnifyScheduleEntryLock - DSTOffsetSign is supported
+ * under a UNID/EndpoinID
+ *
+ * @param unid          Node's UNID
+ * @param endpoint_id   Endpoint ID
+ *
+ * @returns true if DSTOffsetSign is supported
+ * @returns false if DSTOffsetSign is not supported
+ */
+bool dotdot_is_supported_unify_schedule_entry_lock_dst_offset_sign (
+              const dotdot_unid_t unid, const dotdot_endpoint_id_t endpoint_id);
+
+/**
+ * @brief Gets the DotDot UnifyScheduleEntryLock - DSTOffsetSign attribute value under a UNID/EndpoinID
+ *
+ * @param unid          Node's UNID
+ * @param endpoint_id   Endpoint ID
+ * @param value_state   value state to get,
+ *                      see \ref attribute_store_get_node_attribute_value
+ * 
+ *
+ * @returns DSTOffsetSign attribute
+ */
+uint8_t dotdot_get_unify_schedule_entry_lock_dst_offset_sign(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id,
+  attribute_store_node_value_state_t value_state);
+
+/**
+ * @brief Set the DotDot UnifyScheduleEntryLock - DSTOffsetSign attribute under a UNID/EndpoinID
+ *
+ * @param unid          Node's UNID
+ * @param endpoint_id   Endpoint ID
+ * @param value_state   value state to write for the node,
+ *                      see \ref attribute_store_set_node_attribute_value
+ * 
+ * @param new_dst_offset_sign new value to set
+ * @returns sl_status_t SL_STATUS_OK on success
+ */
+sl_status_t dotdot_set_unify_schedule_entry_lock_dst_offset_sign(
+  const dotdot_unid_t unid,
+  dotdot_endpoint_id_t endpoint_id,
+  attribute_store_node_value_state_t value_state,
+  uint8_t new_dst_offset_sign
+  );
+
+/**
+ * @brief Undefines the Reported value of the the DotDot UnifyScheduleEntryLock - DSTOffsetSign
+ * attribute under a UNID/EndpoinID
+ *
+ * @param unid          Node's UNID
+ * @param endpoint_id   Endpoint ID
+ * @returns sl_status_t SL_STATUS_OK on success
+ */
+sl_status_t dotdot_unify_schedule_entry_lock_dst_offset_sign_undefine_reported(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id);
+
+/**
+ * @brief Undefines the Desired value of the DotDot
+ * UnifyScheduleEntryLock - DSTOffsetSign attribute under a UNID/EndpointID
+ *
+ * @param unid          Node's UNID
+ * @param endpoint_id   Endpoint ID
+ * @returns sl_status_t SL_STATUS_OK on success
+ */
+sl_status_t dotdot_unify_schedule_entry_lock_dst_offset_sign_undefine_desired(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id);
+
+/**
+ * @brief Checks if the reported value is defined for the DotDot
+ * UnifyScheduleEntryLock - DSTOffsetSign attribute under a UNID/EndpointID
+ *
+ * @param unid          Node's UNID
+ * @param endpoint_id   Endpoint ID
+ * @returns true if defined, false is undefined or non-existent
+ */
+bool dotdot_unify_schedule_entry_lock_dst_offset_sign_is_reported_defined(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id);
+
+/**
+ * @brief Checks if the desired value is defined for the DotDot
+ * UnifyScheduleEntryLock - DSTOffsetSign attribute under a UNID/EndpointID
+ *
+ * @param unid          Node's UNID
+ * @param endpoint_id   Endpoint ID
+ * @returns true if defined, false is undefined or non-existent
+ */
+bool dotdot_unify_schedule_entry_lock_dst_offset_sign_is_desired_defined(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id);
+
+/**
+ * @brief Creates a DotDot UnifyScheduleEntryLock - DSTOffsetSign attribute under a UNID/EndpoinID
+ *
+ * @param unid          Node's UNID
+ * @param endpoint_id   Endpoint ID
+ * @returns sl_status_t SL_STATUS_OK on success
+ */
+sl_status_t dotdot_create_unify_schedule_entry_lock_dst_offset_sign(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id);
+// UnifyScheduleEntryLock DSTOffsetMinute
+/**
+ * @brief Verifies if the DotDot UnifyScheduleEntryLock - DSTOffsetMinute is supported
+ * under a UNID/EndpoinID
+ *
+ * @param unid          Node's UNID
+ * @param endpoint_id   Endpoint ID
+ *
+ * @returns true if DSTOffsetMinute is supported
+ * @returns false if DSTOffsetMinute is not supported
+ */
+bool dotdot_is_supported_unify_schedule_entry_lock_dst_offset_minute (
+              const dotdot_unid_t unid, const dotdot_endpoint_id_t endpoint_id);
+
+/**
+ * @brief Gets the DotDot UnifyScheduleEntryLock - DSTOffsetMinute attribute value under a UNID/EndpoinID
+ *
+ * @param unid          Node's UNID
+ * @param endpoint_id   Endpoint ID
+ * @param value_state   value state to get,
+ *                      see \ref attribute_store_get_node_attribute_value
+ * 
+ *
+ * @returns DSTOffsetMinute attribute
+ */
+uint8_t dotdot_get_unify_schedule_entry_lock_dst_offset_minute(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id,
+  attribute_store_node_value_state_t value_state);
+
+/**
+ * @brief Set the DotDot UnifyScheduleEntryLock - DSTOffsetMinute attribute under a UNID/EndpoinID
+ *
+ * @param unid          Node's UNID
+ * @param endpoint_id   Endpoint ID
+ * @param value_state   value state to write for the node,
+ *                      see \ref attribute_store_set_node_attribute_value
+ * 
+ * @param new_dst_offset_minute new value to set
+ * @returns sl_status_t SL_STATUS_OK on success
+ */
+sl_status_t dotdot_set_unify_schedule_entry_lock_dst_offset_minute(
+  const dotdot_unid_t unid,
+  dotdot_endpoint_id_t endpoint_id,
+  attribute_store_node_value_state_t value_state,
+  uint8_t new_dst_offset_minute
+  );
+
+/**
+ * @brief Undefines the Reported value of the the DotDot UnifyScheduleEntryLock - DSTOffsetMinute
+ * attribute under a UNID/EndpoinID
+ *
+ * @param unid          Node's UNID
+ * @param endpoint_id   Endpoint ID
+ * @returns sl_status_t SL_STATUS_OK on success
+ */
+sl_status_t dotdot_unify_schedule_entry_lock_dst_offset_minute_undefine_reported(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id);
+
+/**
+ * @brief Undefines the Desired value of the DotDot
+ * UnifyScheduleEntryLock - DSTOffsetMinute attribute under a UNID/EndpointID
+ *
+ * @param unid          Node's UNID
+ * @param endpoint_id   Endpoint ID
+ * @returns sl_status_t SL_STATUS_OK on success
+ */
+sl_status_t dotdot_unify_schedule_entry_lock_dst_offset_minute_undefine_desired(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id);
+
+/**
+ * @brief Checks if the reported value is defined for the DotDot
+ * UnifyScheduleEntryLock - DSTOffsetMinute attribute under a UNID/EndpointID
+ *
+ * @param unid          Node's UNID
+ * @param endpoint_id   Endpoint ID
+ * @returns true if defined, false is undefined or non-existent
+ */
+bool dotdot_unify_schedule_entry_lock_dst_offset_minute_is_reported_defined(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id);
+
+/**
+ * @brief Checks if the desired value is defined for the DotDot
+ * UnifyScheduleEntryLock - DSTOffsetMinute attribute under a UNID/EndpointID
+ *
+ * @param unid          Node's UNID
+ * @param endpoint_id   Endpoint ID
+ * @returns true if defined, false is undefined or non-existent
+ */
+bool dotdot_unify_schedule_entry_lock_dst_offset_minute_is_desired_defined(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id);
+
+/**
+ * @brief Creates a DotDot UnifyScheduleEntryLock - DSTOffsetMinute attribute under a UNID/EndpoinID
+ *
+ * @param unid          Node's UNID
+ * @param endpoint_id   Endpoint ID
+ * @returns sl_status_t SL_STATUS_OK on success
+ */
+sl_status_t dotdot_create_unify_schedule_entry_lock_dst_offset_minute(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id);
+// UnifyScheduleEntryLock NumberOfSlotsDailyRepeating
+/**
+ * @brief Verifies if the DotDot UnifyScheduleEntryLock - NumberOfSlotsDailyRepeating is supported
+ * under a UNID/EndpoinID
+ *
+ * @param unid          Node's UNID
+ * @param endpoint_id   Endpoint ID
+ *
+ * @returns true if NumberOfSlotsDailyRepeating is supported
+ * @returns false if NumberOfSlotsDailyRepeating is not supported
+ */
+bool dotdot_is_supported_unify_schedule_entry_lock_number_of_slots_daily_repeating (
+              const dotdot_unid_t unid, const dotdot_endpoint_id_t endpoint_id);
+
+/**
+ * @brief Gets the DotDot UnifyScheduleEntryLock - NumberOfSlotsDailyRepeating attribute value under a UNID/EndpoinID
+ *
+ * @param unid          Node's UNID
+ * @param endpoint_id   Endpoint ID
+ * @param value_state   value state to get,
+ *                      see \ref attribute_store_get_node_attribute_value
+ * 
+ *
+ * @returns NumberOfSlotsDailyRepeating attribute
+ */
+uint8_t dotdot_get_unify_schedule_entry_lock_number_of_slots_daily_repeating(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id,
+  attribute_store_node_value_state_t value_state);
+
+/**
+ * @brief Set the DotDot UnifyScheduleEntryLock - NumberOfSlotsDailyRepeating attribute under a UNID/EndpoinID
+ *
+ * @param unid          Node's UNID
+ * @param endpoint_id   Endpoint ID
+ * @param value_state   value state to write for the node,
+ *                      see \ref attribute_store_set_node_attribute_value
+ * 
+ * @param new_number_of_slots_daily_repeating new value to set
+ * @returns sl_status_t SL_STATUS_OK on success
+ */
+sl_status_t dotdot_set_unify_schedule_entry_lock_number_of_slots_daily_repeating(
+  const dotdot_unid_t unid,
+  dotdot_endpoint_id_t endpoint_id,
+  attribute_store_node_value_state_t value_state,
+  uint8_t new_number_of_slots_daily_repeating
+  );
+
+/**
+ * @brief Undefines the Reported value of the the DotDot UnifyScheduleEntryLock - NumberOfSlotsDailyRepeating
+ * attribute under a UNID/EndpoinID
+ *
+ * @param unid          Node's UNID
+ * @param endpoint_id   Endpoint ID
+ * @returns sl_status_t SL_STATUS_OK on success
+ */
+sl_status_t dotdot_unify_schedule_entry_lock_number_of_slots_daily_repeating_undefine_reported(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id);
+
+/**
+ * @brief Undefines the Desired value of the DotDot
+ * UnifyScheduleEntryLock - NumberOfSlotsDailyRepeating attribute under a UNID/EndpointID
+ *
+ * @param unid          Node's UNID
+ * @param endpoint_id   Endpoint ID
+ * @returns sl_status_t SL_STATUS_OK on success
+ */
+sl_status_t dotdot_unify_schedule_entry_lock_number_of_slots_daily_repeating_undefine_desired(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id);
+
+/**
+ * @brief Checks if the reported value is defined for the DotDot
+ * UnifyScheduleEntryLock - NumberOfSlotsDailyRepeating attribute under a UNID/EndpointID
+ *
+ * @param unid          Node's UNID
+ * @param endpoint_id   Endpoint ID
+ * @returns true if defined, false is undefined or non-existent
+ */
+bool dotdot_unify_schedule_entry_lock_number_of_slots_daily_repeating_is_reported_defined(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id);
+
+/**
+ * @brief Checks if the desired value is defined for the DotDot
+ * UnifyScheduleEntryLock - NumberOfSlotsDailyRepeating attribute under a UNID/EndpointID
+ *
+ * @param unid          Node's UNID
+ * @param endpoint_id   Endpoint ID
+ * @returns true if defined, false is undefined or non-existent
+ */
+bool dotdot_unify_schedule_entry_lock_number_of_slots_daily_repeating_is_desired_defined(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id);
+
+/**
+ * @brief Creates a DotDot UnifyScheduleEntryLock - NumberOfSlotsDailyRepeating attribute under a UNID/EndpoinID
+ *
+ * @param unid          Node's UNID
+ * @param endpoint_id   Endpoint ID
+ * @returns sl_status_t SL_STATUS_OK on success
+ */
+sl_status_t dotdot_create_unify_schedule_entry_lock_number_of_slots_daily_repeating(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id);
+
+/**
+ * @brief Checks if a UNID/Endpoint supports any attribute for the UnifyScheduleEntryLock
+ * Cluster
+ *
+ * @param unid          Node's UNID
+ * @param endpoint_id   Endpoint ID
+ * @returns true if at least 1 attribute in the Attribute Store, false otherwise
+ */
+bool dotdot_is_any_unify_schedule_entry_lock_attribute_supported(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id);
+
+/**
+ * @brief Checks if a UNID/Endpoint supports any writable attribute for the
+ * UnifyScheduleEntryLock Cluster
+ *
+ * @param unid          Node's UNID
+ * @param endpoint_id   Endpoint ID
+ * @returns true if at least 1 writable attribute in the Attribute Store, false otherwise
+ */
+bool dotdot_is_any_unify_schedule_entry_lock_writable_attribute_supported(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id);
+
 ////////////////////////////////////////////////////////////////////////////////
 // Start of cluster UnifyHumidityControl
 ////////////////////////////////////////////////////////////////////////////////
diff --git a/components/unify_dotdot_attribute_store/zap-generated/include/unify_dotdot_defined_attribute_types.h b/components/unify_dotdot_attribute_store/zap-generated/include/unify_dotdot_defined_attribute_types.h
index 6150a9ae87..75ec8aaada 100644
--- a/components/unify_dotdot_attribute_store/zap-generated/include/unify_dotdot_defined_attribute_types.h
+++ b/components/unify_dotdot_attribute_store/zap-generated/include/unify_dotdot_defined_attribute_types.h
@@ -784,6 +784,15 @@ DEFINE_ATTRIBUTE(DOTDOT_ATTRIBUTE_ID_UNIFY_FAN_CONTROL_Z_WAVE_FAN_STATE , 0xfd14
 DEFINE_ATTRIBUTE(DOTDOT_ATTRIBUTE_ID_UNIFY_THERMOSTAT_THERMOSTAT_MODE , 0xfd150001)
 DEFINE_ATTRIBUTE(DOTDOT_ATTRIBUTE_ID_UNIFY_THERMOSTAT_SUPPORTED_THERMOSTAT_MODE , 0xfd150002)
 DEFINE_ATTRIBUTE(DOTDOT_ATTRIBUTE_ID_UNIFY_THERMOSTAT_OPERATING_STATE , 0xfd150003)
+// Attribute Defines for UnifyScheduleEntryLock
+DEFINE_ATTRIBUTE(DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_SLOTS_WEEK_DAY , 0xfd210001)
+DEFINE_ATTRIBUTE(DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_SLOTS_YEAR_DAY , 0xfd210002)
+DEFINE_ATTRIBUTE(DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_SIGNTZO , 0xfd210003)
+DEFINE_ATTRIBUTE(DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_HOURTZO , 0xfd210004)
+DEFINE_ATTRIBUTE(DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_MINUTETZO , 0xfd210005)
+DEFINE_ATTRIBUTE(DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_DST_OFFSET_SIGN , 0xfd210006)
+DEFINE_ATTRIBUTE(DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_DST_OFFSET_MINUTE , 0xfd210007)
+DEFINE_ATTRIBUTE(DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_NUMBER_OF_SLOTS_DAILY_REPEATING , 0xfd210008)
 // Attribute Defines for UnifyHumidityControl
 DEFINE_ATTRIBUTE(DOTDOT_ATTRIBUTE_ID_UNIFY_HUMIDITY_CONTROL_REPORTING_MODE , 0xfda00001)
 DEFINE_ATTRIBUTE(DOTDOT_ATTRIBUTE_ID_UNIFY_HUMIDITY_CONTROL_SUPPORTED_REPORTING_MODE , 0xfda00002)
diff --git a/components/unify_dotdot_attribute_store/zap-generated/src/unify_dotdot_attribute_store_attribute_publisher.cpp b/components/unify_dotdot_attribute_store/zap-generated/src/unify_dotdot_attribute_store_attribute_publisher.cpp
index d208971476..5b2324063c 100644
--- a/components/unify_dotdot_attribute_store/zap-generated/src/unify_dotdot_attribute_store_attribute_publisher.cpp
+++ b/components/unify_dotdot_attribute_store/zap-generated/src/unify_dotdot_attribute_store_attribute_publisher.cpp
@@ -25624,6 +25624,375 @@ static void unify_thermostat_cluster_cluster_revision_callback(
 }
 
 
+/**
+ * @brief Publishes the desired value of an updated attribute store node for
+ * the UnifyScheduleEntryLock cluster.
+ * @param updated_node Updated attribute store node
+ * @param change       Type of change applied
+ */
+static void unify_schedule_entry_lock_cluster_publish_desired_value_callback(
+   attribute_store_node_t updated_node, attribute_store_change_t change)
+{
+  // clang-format on
+  if (false == is_publish_desired_attribute_values_to_mqtt_enabled()) {
+    return;
+  }
+  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED) {
+    return;
+  }
+  // Scene exception: check that the attribute is not under the Scene Table extension, which is a config and not the node's state.
+  if (ATTRIBUTE_STORE_INVALID_NODE
+      != attribute_store_get_first_parent_with_type(
+        updated_node,
+        DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_TABLE)) {
+    return;
+  }
+
+  // Get the UNID and EndPoint, and prepare the basic topic
+  char unid[MAXIMUM_UNID_SIZE]     = {};
+  // clang-format off
+  // clang-format on
+  dotdot_endpoint_id_t endpoint_id = 0;
+  if (SL_STATUS_OK
+      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
+                                                     unid,
+                                                     &endpoint_id)) {
+    return;
+  }
+  // clang-format off
+  // clang-format on
+
+  std::string base_topic = "ucl/by-unid/" + std::string(unid);
+  // clang-format off
+  base_topic += "/ep" + std::to_string(endpoint_id);
+  // clang-format on
+
+  attribute_store_type_t type = attribute_store_get_node_type(updated_node);
+  if (type == ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
+    sl_log_debug(LOG_TAG,
+                 "Warning: Invalid type for Attribute ID %d, "
+                 "this should not happen.",
+                 updated_node);
+    return;
+  }
+
+  // If the value got updated but both Reported and Desired undefined, we skip publication
+  if (false == attribute_store_is_reported_defined(updated_node)
+      && false == attribute_store_is_desired_defined(updated_node)) {
+    sl_log_debug(LOG_TAG,
+                 "Reported/Desired values are undefined. "
+                 "Skipping publication");
+    return;
+  }
+
+  // clang-format off
+  try {
+    attribute_store::attribute attr(updated_node);
+      if (type == DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_SLOTS_WEEK_DAY) {
+          uic_mqtt_dotdot_unify_schedule_entry_lock_slots_week_day_publish(
+            base_topic.c_str(),
+            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
+            UCL_MQTT_PUBLISH_TYPE_DESIRED);
+        return;
+      }
+          if (type == DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_SLOTS_YEAR_DAY) {
+          uic_mqtt_dotdot_unify_schedule_entry_lock_slots_year_day_publish(
+            base_topic.c_str(),
+            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
+            UCL_MQTT_PUBLISH_TYPE_DESIRED);
+        return;
+      }
+          if (type == DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_SIGNTZO) {
+          uic_mqtt_dotdot_unify_schedule_entry_lock_signtzo_publish(
+            base_topic.c_str(),
+            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
+            UCL_MQTT_PUBLISH_TYPE_DESIRED);
+        return;
+      }
+          if (type == DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_HOURTZO) {
+          uic_mqtt_dotdot_unify_schedule_entry_lock_hourtzo_publish(
+            base_topic.c_str(),
+            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
+            UCL_MQTT_PUBLISH_TYPE_DESIRED);
+        return;
+      }
+          if (type == DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_MINUTETZO) {
+          uic_mqtt_dotdot_unify_schedule_entry_lock_minutetzo_publish(
+            base_topic.c_str(),
+            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
+            UCL_MQTT_PUBLISH_TYPE_DESIRED);
+        return;
+      }
+          if (type == DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_DST_OFFSET_SIGN) {
+          uic_mqtt_dotdot_unify_schedule_entry_lock_dst_offset_sign_publish(
+            base_topic.c_str(),
+            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
+            UCL_MQTT_PUBLISH_TYPE_DESIRED);
+        return;
+      }
+          if (type == DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_DST_OFFSET_MINUTE) {
+          uic_mqtt_dotdot_unify_schedule_entry_lock_dst_offset_minute_publish(
+            base_topic.c_str(),
+            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
+            UCL_MQTT_PUBLISH_TYPE_DESIRED);
+        return;
+      }
+          if (type == DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_NUMBER_OF_SLOTS_DAILY_REPEATING) {
+          uic_mqtt_dotdot_unify_schedule_entry_lock_number_of_slots_daily_repeating_publish(
+            base_topic.c_str(),
+            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
+            UCL_MQTT_PUBLISH_TYPE_DESIRED);
+        return;
+      }
+      } catch (std::exception &ex) {
+    sl_log_warning(LOG_TAG, "Failed to publish the Desired attribute value: %s", ex.what());
+  }
+}
+
+/**
+ * @brief Publishes the reported value of an updated attribute store node for
+ * the UnifyScheduleEntryLock cluster.
+ * @param updated_node Updated attribute store node
+ * @param change       Type of change applied
+ */
+static void unify_schedule_entry_lock_cluster_publish_reported_value_callback(
+   attribute_store_node_t updated_node, attribute_store_change_t change)
+{
+  // clang-format on
+  if (false == is_publish_reported_attribute_values_to_mqtt_enabled()) {
+    return;
+  }
+  if (change == ATTRIBUTE_CREATED) {
+    return;
+  }
+  // Scene exception: check that the attribute is not under the Scene Table extension, which is a config and not the node's state.
+  if (ATTRIBUTE_STORE_INVALID_NODE
+      != attribute_store_get_first_parent_with_type(
+        updated_node,
+        DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_TABLE)) {
+    return;
+  }
+
+  // Get the UNID and EndPoint, and prepare the basic topic
+  char unid[MAXIMUM_UNID_SIZE]     = {};
+  // clang-format off
+  // clang-format on
+  dotdot_endpoint_id_t endpoint_id = 0;
+  if (SL_STATUS_OK
+      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
+                                                     unid,
+                                                     &endpoint_id)) {
+    return;
+  }
+  // clang-format off
+  // clang-format on
+
+  std::string base_topic = "ucl/by-unid/" + std::string(unid);
+  // clang-format off
+  base_topic += "/ep" + std::to_string(endpoint_id);
+  // clang-format on
+
+  attribute_store_type_t type = attribute_store_get_node_type(updated_node);
+  if (type == ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
+    sl_log_debug(LOG_TAG,
+                 "Warning: Invalid type for Attribute ID %d, "
+                 "this should not happen.",
+                 updated_node);
+    return;
+  }
+
+  // Deletion case:
+  if (change == ATTRIBUTE_DELETED) {
+    // clang-format off
+    switch(type) {
+     case DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_SLOTS_WEEK_DAY:
+        // clang-format on
+        sl_log_debug(LOG_TAG,
+                     "Unretaining UnifyScheduleEntryLock::SlotsWeekDay under topic %s",
+                     base_topic.c_str());
+        // clang-format off
+      uic_mqtt_dotdot_unify_schedule_entry_lock_slots_week_day_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
+      break;
+     case DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_SLOTS_YEAR_DAY:
+        // clang-format on
+        sl_log_debug(LOG_TAG,
+                     "Unretaining UnifyScheduleEntryLock::SlotsYearDay under topic %s",
+                     base_topic.c_str());
+        // clang-format off
+      uic_mqtt_dotdot_unify_schedule_entry_lock_slots_year_day_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
+      break;
+     case DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_SIGNTZO:
+        // clang-format on
+        sl_log_debug(LOG_TAG,
+                     "Unretaining UnifyScheduleEntryLock::SignTZO under topic %s",
+                     base_topic.c_str());
+        // clang-format off
+      uic_mqtt_dotdot_unify_schedule_entry_lock_signtzo_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
+      break;
+     case DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_HOURTZO:
+        // clang-format on
+        sl_log_debug(LOG_TAG,
+                     "Unretaining UnifyScheduleEntryLock::HourTZO under topic %s",
+                     base_topic.c_str());
+        // clang-format off
+      uic_mqtt_dotdot_unify_schedule_entry_lock_hourtzo_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
+      break;
+     case DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_MINUTETZO:
+        // clang-format on
+        sl_log_debug(LOG_TAG,
+                     "Unretaining UnifyScheduleEntryLock::MinuteTZO under topic %s",
+                     base_topic.c_str());
+        // clang-format off
+      uic_mqtt_dotdot_unify_schedule_entry_lock_minutetzo_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
+      break;
+     case DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_DST_OFFSET_SIGN:
+        // clang-format on
+        sl_log_debug(LOG_TAG,
+                     "Unretaining UnifyScheduleEntryLock::DSTOffsetSign under topic %s",
+                     base_topic.c_str());
+        // clang-format off
+      uic_mqtt_dotdot_unify_schedule_entry_lock_dst_offset_sign_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
+      break;
+     case DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_DST_OFFSET_MINUTE:
+        // clang-format on
+        sl_log_debug(LOG_TAG,
+                     "Unretaining UnifyScheduleEntryLock::DSTOffsetMinute under topic %s",
+                     base_topic.c_str());
+        // clang-format off
+      uic_mqtt_dotdot_unify_schedule_entry_lock_dst_offset_minute_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
+      break;
+     case DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_NUMBER_OF_SLOTS_DAILY_REPEATING:
+        // clang-format on
+        sl_log_debug(LOG_TAG,
+                     "Unretaining UnifyScheduleEntryLock::NumberOfSlotsDailyRepeating under topic %s",
+                     base_topic.c_str());
+        // clang-format off
+      uic_mqtt_dotdot_unify_schedule_entry_lock_number_of_slots_daily_repeating_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
+      break;
+    default:
+    break;
+    }
+    // clang-format on
+    return;
+  }
+
+  // If the value got updated but undefined, we skip publication
+  if (false == attribute_store_is_reported_defined(updated_node)) {
+    sl_log_debug(LOG_TAG, "Reported value is undefined. Skipping publication");
+    return;
+  }
+
+  // Else we assume update case:
+  // clang-format off
+  try {
+    attribute_store::attribute attr(updated_node);
+      if (type == DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_SLOTS_WEEK_DAY) {
+          uic_mqtt_dotdot_unify_schedule_entry_lock_slots_week_day_publish(
+            base_topic.c_str(),
+            static_cast<uint8_t>(attr.reported<uint8_t>()),
+            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
+        return;
+      }
+          if (type == DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_SLOTS_YEAR_DAY) {
+          uic_mqtt_dotdot_unify_schedule_entry_lock_slots_year_day_publish(
+            base_topic.c_str(),
+            static_cast<uint8_t>(attr.reported<uint8_t>()),
+            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
+        return;
+      }
+          if (type == DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_SIGNTZO) {
+          uic_mqtt_dotdot_unify_schedule_entry_lock_signtzo_publish(
+            base_topic.c_str(),
+            static_cast<uint8_t>(attr.reported<uint8_t>()),
+            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
+        return;
+      }
+          if (type == DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_HOURTZO) {
+          uic_mqtt_dotdot_unify_schedule_entry_lock_hourtzo_publish(
+            base_topic.c_str(),
+            static_cast<uint8_t>(attr.reported<uint8_t>()),
+            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
+        return;
+      }
+          if (type == DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_MINUTETZO) {
+          uic_mqtt_dotdot_unify_schedule_entry_lock_minutetzo_publish(
+            base_topic.c_str(),
+            static_cast<uint8_t>(attr.reported<uint8_t>()),
+            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
+        return;
+      }
+          if (type == DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_DST_OFFSET_SIGN) {
+          uic_mqtt_dotdot_unify_schedule_entry_lock_dst_offset_sign_publish(
+            base_topic.c_str(),
+            static_cast<uint8_t>(attr.reported<uint8_t>()),
+            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
+        return;
+      }
+          if (type == DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_DST_OFFSET_MINUTE) {
+          uic_mqtt_dotdot_unify_schedule_entry_lock_dst_offset_minute_publish(
+            base_topic.c_str(),
+            static_cast<uint8_t>(attr.reported<uint8_t>()),
+            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
+        return;
+      }
+          if (type == DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_NUMBER_OF_SLOTS_DAILY_REPEATING) {
+          uic_mqtt_dotdot_unify_schedule_entry_lock_number_of_slots_daily_repeating_publish(
+            base_topic.c_str(),
+            static_cast<uint8_t>(attr.reported<uint8_t>()),
+            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
+        return;
+      }
+      } catch (std::exception &ex) {
+    sl_log_warning(LOG_TAG, "Failed to publish the Reported attribute value: %s", ex.what());
+  }
+}
+
+static void unify_schedule_entry_lock_cluster_cluster_revision_callback(
+   attribute_store_node_t updated_node, attribute_store_change_t change)
+{
+  // clang-format on
+  if (false == is_publish_reported_attribute_values_to_mqtt_enabled()) {
+    return;
+  }
+
+  // Get the UNID and EndPoint, and prepare the basic topic
+  char unid[MAXIMUM_UNID_SIZE]     = {};
+  dotdot_endpoint_id_t endpoint_id = 0;
+  // clang-format off
+  // clang-format on
+  if (SL_STATUS_OK
+      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
+                                                     unid,
+                                                     &endpoint_id)) {
+    return;
+  }
+  // clang-format off
+  // clang-format on
+
+  std::string base_topic = "ucl/by-unid/" + std::string(unid);
+  // clang-format off
+  base_topic += "/ep" + std::to_string(endpoint_id);
+
+  if ((change == ATTRIBUTE_CREATED) || (change == ATTRIBUTE_UPDATED)) {
+    // On attribute creation, make sure to publish the attribute revision for the first time
+    std::string cluster_revision_topic = base_topic + "/UnifyScheduleEntryLock/Attributes/ClusterRevision";
+    if (uic_mqtt_count_topics(cluster_revision_topic.c_str()) == 0) {
+      uic_mqtt_dotdot_unify_schedule_entry_lock_publish_cluster_revision(base_topic.c_str(), 1);
+    }
+  }
+
+  if (change == ATTRIBUTE_DELETED) {
+    // Check if we just erased the last attribute under a cluster, if yes, unretain
+    // the Cluster revision too.
+    if (false == dotdot_is_any_unify_schedule_entry_lock_attribute_supported(unid, endpoint_id)) {
+      base_topic +=  "/UnifyScheduleEntryLock";
+      sl_log_debug(LOG_TAG, "No more attributes supported for UnifyScheduleEntryLock cluster for UNID %s Endpoint %d. Unretaining leftover topics at %s",unid, endpoint_id, base_topic.c_str());
+      uic_mqtt_unretain(base_topic.c_str());
+    }
+  }
+}
+
+
 /**
  * @brief Publishes the desired value of an updated attribute store node for
  * the UnifyHumidityControl cluster.
@@ -36124,6 +36493,118 @@ sl_status_t unify_dotdot_attribute_store_attribute_publisher_init()
       unify_thermostat_cluster_cluster_revision_callback,
       DOTDOT_ATTRIBUTE_ID_UNIFY_THERMOSTAT_OPERATING_STATE);
     //Desired attribute state
+    attribute_store_register_callback_by_type_and_state(
+      unify_schedule_entry_lock_cluster_publish_desired_value_callback,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_SLOTS_WEEK_DAY,
+      DESIRED_ATTRIBUTE);
+    //Reported attribute state
+    attribute_store_register_callback_by_type_and_state(
+      unify_schedule_entry_lock_cluster_publish_reported_value_callback,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_SLOTS_WEEK_DAY,
+      REPORTED_ATTRIBUTE);
+    //registering a callback when an attribute is created for publishing cluster revision
+    attribute_store_register_callback_by_type(
+      unify_schedule_entry_lock_cluster_cluster_revision_callback,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_SLOTS_WEEK_DAY);
+    //Desired attribute state
+    attribute_store_register_callback_by_type_and_state(
+      unify_schedule_entry_lock_cluster_publish_desired_value_callback,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_SLOTS_YEAR_DAY,
+      DESIRED_ATTRIBUTE);
+    //Reported attribute state
+    attribute_store_register_callback_by_type_and_state(
+      unify_schedule_entry_lock_cluster_publish_reported_value_callback,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_SLOTS_YEAR_DAY,
+      REPORTED_ATTRIBUTE);
+    //registering a callback when an attribute is created for publishing cluster revision
+    attribute_store_register_callback_by_type(
+      unify_schedule_entry_lock_cluster_cluster_revision_callback,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_SLOTS_YEAR_DAY);
+    //Desired attribute state
+    attribute_store_register_callback_by_type_and_state(
+      unify_schedule_entry_lock_cluster_publish_desired_value_callback,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_SIGNTZO,
+      DESIRED_ATTRIBUTE);
+    //Reported attribute state
+    attribute_store_register_callback_by_type_and_state(
+      unify_schedule_entry_lock_cluster_publish_reported_value_callback,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_SIGNTZO,
+      REPORTED_ATTRIBUTE);
+    //registering a callback when an attribute is created for publishing cluster revision
+    attribute_store_register_callback_by_type(
+      unify_schedule_entry_lock_cluster_cluster_revision_callback,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_SIGNTZO);
+    //Desired attribute state
+    attribute_store_register_callback_by_type_and_state(
+      unify_schedule_entry_lock_cluster_publish_desired_value_callback,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_HOURTZO,
+      DESIRED_ATTRIBUTE);
+    //Reported attribute state
+    attribute_store_register_callback_by_type_and_state(
+      unify_schedule_entry_lock_cluster_publish_reported_value_callback,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_HOURTZO,
+      REPORTED_ATTRIBUTE);
+    //registering a callback when an attribute is created for publishing cluster revision
+    attribute_store_register_callback_by_type(
+      unify_schedule_entry_lock_cluster_cluster_revision_callback,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_HOURTZO);
+    //Desired attribute state
+    attribute_store_register_callback_by_type_and_state(
+      unify_schedule_entry_lock_cluster_publish_desired_value_callback,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_MINUTETZO,
+      DESIRED_ATTRIBUTE);
+    //Reported attribute state
+    attribute_store_register_callback_by_type_and_state(
+      unify_schedule_entry_lock_cluster_publish_reported_value_callback,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_MINUTETZO,
+      REPORTED_ATTRIBUTE);
+    //registering a callback when an attribute is created for publishing cluster revision
+    attribute_store_register_callback_by_type(
+      unify_schedule_entry_lock_cluster_cluster_revision_callback,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_MINUTETZO);
+    //Desired attribute state
+    attribute_store_register_callback_by_type_and_state(
+      unify_schedule_entry_lock_cluster_publish_desired_value_callback,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_DST_OFFSET_SIGN,
+      DESIRED_ATTRIBUTE);
+    //Reported attribute state
+    attribute_store_register_callback_by_type_and_state(
+      unify_schedule_entry_lock_cluster_publish_reported_value_callback,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_DST_OFFSET_SIGN,
+      REPORTED_ATTRIBUTE);
+    //registering a callback when an attribute is created for publishing cluster revision
+    attribute_store_register_callback_by_type(
+      unify_schedule_entry_lock_cluster_cluster_revision_callback,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_DST_OFFSET_SIGN);
+    //Desired attribute state
+    attribute_store_register_callback_by_type_and_state(
+      unify_schedule_entry_lock_cluster_publish_desired_value_callback,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_DST_OFFSET_MINUTE,
+      DESIRED_ATTRIBUTE);
+    //Reported attribute state
+    attribute_store_register_callback_by_type_and_state(
+      unify_schedule_entry_lock_cluster_publish_reported_value_callback,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_DST_OFFSET_MINUTE,
+      REPORTED_ATTRIBUTE);
+    //registering a callback when an attribute is created for publishing cluster revision
+    attribute_store_register_callback_by_type(
+      unify_schedule_entry_lock_cluster_cluster_revision_callback,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_DST_OFFSET_MINUTE);
+    //Desired attribute state
+    attribute_store_register_callback_by_type_and_state(
+      unify_schedule_entry_lock_cluster_publish_desired_value_callback,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_NUMBER_OF_SLOTS_DAILY_REPEATING,
+      DESIRED_ATTRIBUTE);
+    //Reported attribute state
+    attribute_store_register_callback_by_type_and_state(
+      unify_schedule_entry_lock_cluster_publish_reported_value_callback,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_NUMBER_OF_SLOTS_DAILY_REPEATING,
+      REPORTED_ATTRIBUTE);
+    //registering a callback when an attribute is created for publishing cluster revision
+    attribute_store_register_callback_by_type(
+      unify_schedule_entry_lock_cluster_cluster_revision_callback,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_NUMBER_OF_SLOTS_DAILY_REPEATING);
+    //Desired attribute state
     attribute_store_register_callback_by_type_and_state(
       unify_humidity_control_cluster_publish_desired_value_callback,
       DOTDOT_ATTRIBUTE_ID_UNIFY_HUMIDITY_CONTROL_REPORTING_MODE,
diff --git a/components/unify_dotdot_attribute_store/zap-generated/src/unify_dotdot_attribute_store_force_read_attributes_command_callbacks.c b/components/unify_dotdot_attribute_store/zap-generated/src/unify_dotdot_attribute_store_force_read_attributes_command_callbacks.c
index 9774152fb6..a114ce59bd 100644
--- a/components/unify_dotdot_attribute_store/zap-generated/src/unify_dotdot_attribute_store_force_read_attributes_command_callbacks.c
+++ b/components/unify_dotdot_attribute_store/zap-generated/src/unify_dotdot_attribute_store_force_read_attributes_command_callbacks.c
@@ -4470,6 +4470,71 @@ static sl_status_t uic_mqtt_dotdot_unify_thermostat_force_read_attributes_callba
   return SL_STATUS_OK;
 }
 ////////////////////////////////////////////////////////////////////////////////
+// Start of cluster UnifyScheduleEntryLock
+////////////////////////////////////////////////////////////////////////////////
+static sl_status_t uic_mqtt_dotdot_unify_schedule_entry_lock_force_read_attributes_callback (
+  const dotdot_unid_t unid,
+  dotdot_endpoint_id_t endpoint_id,
+  uic_mqtt_dotdot_callback_call_type_t call_type,
+  uic_mqtt_dotdot_unify_schedule_entry_lock_updated_state_t attribute_list) {
+
+  if (false == is_force_read_attributes_enabled()){
+    return SL_STATUS_FAIL;
+  }
+
+  if (call_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
+    if (is_automatic_deduction_of_supported_commands_enabled()) {
+      return dotdot_is_any_unify_schedule_entry_lock_attribute_supported(unid, endpoint_id) ?
+        SL_STATUS_OK : SL_STATUS_FAIL;
+    } else {
+      return SL_STATUS_FAIL;
+    }
+  }
+
+  // Go and undefine everything that needs to be read again:
+  if (true == attribute_list.slots_week_day) {
+    if (SL_STATUS_OK == dotdot_unify_schedule_entry_lock_slots_week_day_undefine_reported(unid, endpoint_id)) {
+      sl_log_debug(LOG_TAG, "Undefined Reported value of UnifyScheduleEntryLock::SlotsWeekDay under %s - Endpoint %d", unid, endpoint_id);
+    }
+  }
+  if (true == attribute_list.slots_year_day) {
+    if (SL_STATUS_OK == dotdot_unify_schedule_entry_lock_slots_year_day_undefine_reported(unid, endpoint_id)) {
+      sl_log_debug(LOG_TAG, "Undefined Reported value of UnifyScheduleEntryLock::SlotsYearDay under %s - Endpoint %d", unid, endpoint_id);
+    }
+  }
+  if (true == attribute_list.signtzo) {
+    if (SL_STATUS_OK == dotdot_unify_schedule_entry_lock_signtzo_undefine_reported(unid, endpoint_id)) {
+      sl_log_debug(LOG_TAG, "Undefined Reported value of UnifyScheduleEntryLock::SignTZO under %s - Endpoint %d", unid, endpoint_id);
+    }
+  }
+  if (true == attribute_list.hourtzo) {
+    if (SL_STATUS_OK == dotdot_unify_schedule_entry_lock_hourtzo_undefine_reported(unid, endpoint_id)) {
+      sl_log_debug(LOG_TAG, "Undefined Reported value of UnifyScheduleEntryLock::HourTZO under %s - Endpoint %d", unid, endpoint_id);
+    }
+  }
+  if (true == attribute_list.minutetzo) {
+    if (SL_STATUS_OK == dotdot_unify_schedule_entry_lock_minutetzo_undefine_reported(unid, endpoint_id)) {
+      sl_log_debug(LOG_TAG, "Undefined Reported value of UnifyScheduleEntryLock::MinuteTZO under %s - Endpoint %d", unid, endpoint_id);
+    }
+  }
+  if (true == attribute_list.dst_offset_sign) {
+    if (SL_STATUS_OK == dotdot_unify_schedule_entry_lock_dst_offset_sign_undefine_reported(unid, endpoint_id)) {
+      sl_log_debug(LOG_TAG, "Undefined Reported value of UnifyScheduleEntryLock::DSTOffsetSign under %s - Endpoint %d", unid, endpoint_id);
+    }
+  }
+  if (true == attribute_list.dst_offset_minute) {
+    if (SL_STATUS_OK == dotdot_unify_schedule_entry_lock_dst_offset_minute_undefine_reported(unid, endpoint_id)) {
+      sl_log_debug(LOG_TAG, "Undefined Reported value of UnifyScheduleEntryLock::DSTOffsetMinute under %s - Endpoint %d", unid, endpoint_id);
+    }
+  }
+  if (true == attribute_list.number_of_slots_daily_repeating) {
+    if (SL_STATUS_OK == dotdot_unify_schedule_entry_lock_number_of_slots_daily_repeating_undefine_reported(unid, endpoint_id)) {
+      sl_log_debug(LOG_TAG, "Undefined Reported value of UnifyScheduleEntryLock::NumberOfSlotsDailyRepeating under %s - Endpoint %d", unid, endpoint_id);
+    }
+  }
+  return SL_STATUS_OK;
+}
+////////////////////////////////////////////////////////////////////////////////
 // Start of cluster UnifyHumidityControl
 ////////////////////////////////////////////////////////////////////////////////
 static sl_status_t uic_mqtt_dotdot_unify_humidity_control_force_read_attributes_callback (
@@ -4701,6 +4766,8 @@ sl_status_t
   
   uic_mqtt_dotdot_set_unify_thermostat_force_read_attributes_callback(&uic_mqtt_dotdot_unify_thermostat_force_read_attributes_callback);
   
+  uic_mqtt_dotdot_set_unify_schedule_entry_lock_force_read_attributes_callback(&uic_mqtt_dotdot_unify_schedule_entry_lock_force_read_attributes_callback);
+  
   uic_mqtt_dotdot_set_unify_humidity_control_force_read_attributes_callback(&uic_mqtt_dotdot_unify_humidity_control_force_read_attributes_callback);
   
   // clang-format on
diff --git a/components/unify_dotdot_attribute_store/zap-generated/src/unify_dotdot_attribute_store_helpers.cpp b/components/unify_dotdot_attribute_store/zap-generated/src/unify_dotdot_attribute_store_helpers.cpp
index 95fffa41fc..13bc62892f 100644
--- a/components/unify_dotdot_attribute_store/zap-generated/src/unify_dotdot_attribute_store_helpers.cpp
+++ b/components/unify_dotdot_attribute_store/zap-generated/src/unify_dotdot_attribute_store_helpers.cpp
@@ -82302,6 +82302,961 @@ bool dotdot_is_any_unify_thermostat_writable_attribute_supported(
   return false;
 }
 ////////////////////////////////////////////////////////////////////////////////
+// Start of cluster UnifyScheduleEntryLock
+////////////////////////////////////////////////////////////////////////////////
+bool dotdot_is_supported_unify_schedule_entry_lock_slots_week_day(
+  const dotdot_unid_t unid, const dotdot_endpoint_id_t endpoint_id)
+{
+  attribute_store_node_t endpoint_node = unify_dotdot_attributes_get_endpoint_node()(unid, endpoint_id);
+  attribute_store_node_t node
+    = attribute_store_get_first_child_by_type(
+      endpoint_node,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_SLOTS_WEEK_DAY);
+  return attribute_store_node_exists(node);
+}
+
+uint8_t dotdot_get_unify_schedule_entry_lock_slots_week_day(
+  const dotdot_unid_t unid,
+  dotdot_endpoint_id_t endpoint_id,
+  attribute_store_node_value_state_t value_state)
+{
+  attribute_store_node_t endpoint_node = unify_dotdot_attributes_get_endpoint_node()(unid, endpoint_id);
+  attribute_store_node_t node
+    = attribute_store_get_first_child_by_type(
+      endpoint_node,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_SLOTS_WEEK_DAY);
+
+  uint8_t result = {};
+  attribute_store_read_value(node,
+                             value_state,
+                             (uint8_t *)&result,
+                             sizeof(result));
+  return result;
+}
+
+sl_status_t dotdot_set_unify_schedule_entry_lock_slots_week_day(
+  const dotdot_unid_t unid,
+  dotdot_endpoint_id_t endpoint_id,
+  attribute_store_node_value_state_t value_state,
+  uint8_t new_slots_week_day
+  )
+{
+  attribute_store_node_t endpoint_node = unify_dotdot_attributes_get_endpoint_node()(unid, endpoint_id);
+
+  attribute_store_node_t node
+    = attribute_store_get_first_child_by_type(
+      endpoint_node,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_SLOTS_WEEK_DAY);
+
+  return attribute_store_set_node_attribute_value(node,
+                                                  value_state,
+                                                  (uint8_t *)&new_slots_week_day,
+                                                  sizeof(uint8_t));
+  }
+
+sl_status_t dotdot_unify_schedule_entry_lock_slots_week_day_undefine_reported(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id) {
+  attribute_store_node_t endpoint_node = unify_dotdot_attributes_get_endpoint_node()(unid, endpoint_id);
+  attribute_store_node_t node
+    = attribute_store_get_first_child_by_type(
+      endpoint_node,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_SLOTS_WEEK_DAY);
+  attribute_store_undefine_reported(node);
+  return (node != ATTRIBUTE_STORE_INVALID_NODE) ? SL_STATUS_OK : SL_STATUS_FAIL;
+}
+
+sl_status_t dotdot_unify_schedule_entry_lock_slots_week_day_undefine_desired(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id) {
+
+  attribute_store_node_t endpoint_node = unify_dotdot_attributes_get_endpoint_node()(unid, endpoint_id);
+  attribute_store_node_t node
+    = attribute_store_get_first_child_by_type(
+      endpoint_node,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_SLOTS_WEEK_DAY);
+  attribute_store_undefine_desired(node);
+  return (node != ATTRIBUTE_STORE_INVALID_NODE) ? SL_STATUS_OK : SL_STATUS_FAIL;
+}
+
+
+bool dotdot_unify_schedule_entry_lock_slots_week_day_is_reported_defined(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id)
+{
+  attribute_store_node_t endpoint_node = unify_dotdot_attributes_get_endpoint_node()(unid, endpoint_id);
+  attribute_store_node_t node
+    = attribute_store_get_first_child_by_type(
+      endpoint_node,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_SLOTS_WEEK_DAY);
+  return attribute_store_is_reported_defined(node);
+}
+
+bool dotdot_unify_schedule_entry_lock_slots_week_day_is_desired_defined(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id)
+{
+  attribute_store_node_t endpoint_node = unify_dotdot_attributes_get_endpoint_node()(unid, endpoint_id);
+  attribute_store_node_t node
+    = attribute_store_get_first_child_by_type(
+      endpoint_node,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_SLOTS_WEEK_DAY);
+  return attribute_store_is_desired_defined(node);
+}
+
+sl_status_t dotdot_create_unify_schedule_entry_lock_slots_week_day(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id) {
+
+  attribute_store_node_t endpoint_node = unify_dotdot_attributes_get_endpoint_node()(unid, endpoint_id);
+  attribute_store_node_t node =
+    attribute_store_create_child_if_missing(endpoint_node,
+                                           DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_SLOTS_WEEK_DAY);
+
+  return (node != ATTRIBUTE_STORE_INVALID_NODE) ? SL_STATUS_OK : SL_STATUS_FAIL;
+}
+bool dotdot_is_supported_unify_schedule_entry_lock_slots_year_day(
+  const dotdot_unid_t unid, const dotdot_endpoint_id_t endpoint_id)
+{
+  attribute_store_node_t endpoint_node = unify_dotdot_attributes_get_endpoint_node()(unid, endpoint_id);
+  attribute_store_node_t node
+    = attribute_store_get_first_child_by_type(
+      endpoint_node,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_SLOTS_YEAR_DAY);
+  return attribute_store_node_exists(node);
+}
+
+uint8_t dotdot_get_unify_schedule_entry_lock_slots_year_day(
+  const dotdot_unid_t unid,
+  dotdot_endpoint_id_t endpoint_id,
+  attribute_store_node_value_state_t value_state)
+{
+  attribute_store_node_t endpoint_node = unify_dotdot_attributes_get_endpoint_node()(unid, endpoint_id);
+  attribute_store_node_t node
+    = attribute_store_get_first_child_by_type(
+      endpoint_node,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_SLOTS_YEAR_DAY);
+
+  uint8_t result = {};
+  attribute_store_read_value(node,
+                             value_state,
+                             (uint8_t *)&result,
+                             sizeof(result));
+  return result;
+}
+
+sl_status_t dotdot_set_unify_schedule_entry_lock_slots_year_day(
+  const dotdot_unid_t unid,
+  dotdot_endpoint_id_t endpoint_id,
+  attribute_store_node_value_state_t value_state,
+  uint8_t new_slots_year_day
+  )
+{
+  attribute_store_node_t endpoint_node = unify_dotdot_attributes_get_endpoint_node()(unid, endpoint_id);
+
+  attribute_store_node_t node
+    = attribute_store_get_first_child_by_type(
+      endpoint_node,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_SLOTS_YEAR_DAY);
+
+  return attribute_store_set_node_attribute_value(node,
+                                                  value_state,
+                                                  (uint8_t *)&new_slots_year_day,
+                                                  sizeof(uint8_t));
+  }
+
+sl_status_t dotdot_unify_schedule_entry_lock_slots_year_day_undefine_reported(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id) {
+  attribute_store_node_t endpoint_node = unify_dotdot_attributes_get_endpoint_node()(unid, endpoint_id);
+  attribute_store_node_t node
+    = attribute_store_get_first_child_by_type(
+      endpoint_node,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_SLOTS_YEAR_DAY);
+  attribute_store_undefine_reported(node);
+  return (node != ATTRIBUTE_STORE_INVALID_NODE) ? SL_STATUS_OK : SL_STATUS_FAIL;
+}
+
+sl_status_t dotdot_unify_schedule_entry_lock_slots_year_day_undefine_desired(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id) {
+
+  attribute_store_node_t endpoint_node = unify_dotdot_attributes_get_endpoint_node()(unid, endpoint_id);
+  attribute_store_node_t node
+    = attribute_store_get_first_child_by_type(
+      endpoint_node,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_SLOTS_YEAR_DAY);
+  attribute_store_undefine_desired(node);
+  return (node != ATTRIBUTE_STORE_INVALID_NODE) ? SL_STATUS_OK : SL_STATUS_FAIL;
+}
+
+
+bool dotdot_unify_schedule_entry_lock_slots_year_day_is_reported_defined(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id)
+{
+  attribute_store_node_t endpoint_node = unify_dotdot_attributes_get_endpoint_node()(unid, endpoint_id);
+  attribute_store_node_t node
+    = attribute_store_get_first_child_by_type(
+      endpoint_node,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_SLOTS_YEAR_DAY);
+  return attribute_store_is_reported_defined(node);
+}
+
+bool dotdot_unify_schedule_entry_lock_slots_year_day_is_desired_defined(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id)
+{
+  attribute_store_node_t endpoint_node = unify_dotdot_attributes_get_endpoint_node()(unid, endpoint_id);
+  attribute_store_node_t node
+    = attribute_store_get_first_child_by_type(
+      endpoint_node,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_SLOTS_YEAR_DAY);
+  return attribute_store_is_desired_defined(node);
+}
+
+sl_status_t dotdot_create_unify_schedule_entry_lock_slots_year_day(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id) {
+
+  attribute_store_node_t endpoint_node = unify_dotdot_attributes_get_endpoint_node()(unid, endpoint_id);
+  attribute_store_node_t node =
+    attribute_store_create_child_if_missing(endpoint_node,
+                                           DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_SLOTS_YEAR_DAY);
+
+  return (node != ATTRIBUTE_STORE_INVALID_NODE) ? SL_STATUS_OK : SL_STATUS_FAIL;
+}
+bool dotdot_is_supported_unify_schedule_entry_lock_signtzo(
+  const dotdot_unid_t unid, const dotdot_endpoint_id_t endpoint_id)
+{
+  attribute_store_node_t endpoint_node = unify_dotdot_attributes_get_endpoint_node()(unid, endpoint_id);
+  attribute_store_node_t node
+    = attribute_store_get_first_child_by_type(
+      endpoint_node,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_SIGNTZO);
+  return attribute_store_node_exists(node);
+}
+
+uint8_t dotdot_get_unify_schedule_entry_lock_signtzo(
+  const dotdot_unid_t unid,
+  dotdot_endpoint_id_t endpoint_id,
+  attribute_store_node_value_state_t value_state)
+{
+  attribute_store_node_t endpoint_node = unify_dotdot_attributes_get_endpoint_node()(unid, endpoint_id);
+  attribute_store_node_t node
+    = attribute_store_get_first_child_by_type(
+      endpoint_node,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_SIGNTZO);
+
+  uint8_t result = {};
+  attribute_store_read_value(node,
+                             value_state,
+                             (uint8_t *)&result,
+                             sizeof(result));
+  return result;
+}
+
+sl_status_t dotdot_set_unify_schedule_entry_lock_signtzo(
+  const dotdot_unid_t unid,
+  dotdot_endpoint_id_t endpoint_id,
+  attribute_store_node_value_state_t value_state,
+  uint8_t new_signtzo
+  )
+{
+  attribute_store_node_t endpoint_node = unify_dotdot_attributes_get_endpoint_node()(unid, endpoint_id);
+
+  attribute_store_node_t node
+    = attribute_store_get_first_child_by_type(
+      endpoint_node,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_SIGNTZO);
+
+  return attribute_store_set_node_attribute_value(node,
+                                                  value_state,
+                                                  (uint8_t *)&new_signtzo,
+                                                  sizeof(uint8_t));
+  }
+
+sl_status_t dotdot_unify_schedule_entry_lock_signtzo_undefine_reported(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id) {
+  attribute_store_node_t endpoint_node = unify_dotdot_attributes_get_endpoint_node()(unid, endpoint_id);
+  attribute_store_node_t node
+    = attribute_store_get_first_child_by_type(
+      endpoint_node,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_SIGNTZO);
+  attribute_store_undefine_reported(node);
+  return (node != ATTRIBUTE_STORE_INVALID_NODE) ? SL_STATUS_OK : SL_STATUS_FAIL;
+}
+
+sl_status_t dotdot_unify_schedule_entry_lock_signtzo_undefine_desired(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id) {
+
+  attribute_store_node_t endpoint_node = unify_dotdot_attributes_get_endpoint_node()(unid, endpoint_id);
+  attribute_store_node_t node
+    = attribute_store_get_first_child_by_type(
+      endpoint_node,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_SIGNTZO);
+  attribute_store_undefine_desired(node);
+  return (node != ATTRIBUTE_STORE_INVALID_NODE) ? SL_STATUS_OK : SL_STATUS_FAIL;
+}
+
+
+bool dotdot_unify_schedule_entry_lock_signtzo_is_reported_defined(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id)
+{
+  attribute_store_node_t endpoint_node = unify_dotdot_attributes_get_endpoint_node()(unid, endpoint_id);
+  attribute_store_node_t node
+    = attribute_store_get_first_child_by_type(
+      endpoint_node,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_SIGNTZO);
+  return attribute_store_is_reported_defined(node);
+}
+
+bool dotdot_unify_schedule_entry_lock_signtzo_is_desired_defined(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id)
+{
+  attribute_store_node_t endpoint_node = unify_dotdot_attributes_get_endpoint_node()(unid, endpoint_id);
+  attribute_store_node_t node
+    = attribute_store_get_first_child_by_type(
+      endpoint_node,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_SIGNTZO);
+  return attribute_store_is_desired_defined(node);
+}
+
+sl_status_t dotdot_create_unify_schedule_entry_lock_signtzo(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id) {
+
+  attribute_store_node_t endpoint_node = unify_dotdot_attributes_get_endpoint_node()(unid, endpoint_id);
+  attribute_store_node_t node =
+    attribute_store_create_child_if_missing(endpoint_node,
+                                           DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_SIGNTZO);
+
+  return (node != ATTRIBUTE_STORE_INVALID_NODE) ? SL_STATUS_OK : SL_STATUS_FAIL;
+}
+bool dotdot_is_supported_unify_schedule_entry_lock_hourtzo(
+  const dotdot_unid_t unid, const dotdot_endpoint_id_t endpoint_id)
+{
+  attribute_store_node_t endpoint_node = unify_dotdot_attributes_get_endpoint_node()(unid, endpoint_id);
+  attribute_store_node_t node
+    = attribute_store_get_first_child_by_type(
+      endpoint_node,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_HOURTZO);
+  return attribute_store_node_exists(node);
+}
+
+uint8_t dotdot_get_unify_schedule_entry_lock_hourtzo(
+  const dotdot_unid_t unid,
+  dotdot_endpoint_id_t endpoint_id,
+  attribute_store_node_value_state_t value_state)
+{
+  attribute_store_node_t endpoint_node = unify_dotdot_attributes_get_endpoint_node()(unid, endpoint_id);
+  attribute_store_node_t node
+    = attribute_store_get_first_child_by_type(
+      endpoint_node,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_HOURTZO);
+
+  uint8_t result = {};
+  attribute_store_read_value(node,
+                             value_state,
+                             (uint8_t *)&result,
+                             sizeof(result));
+  return result;
+}
+
+sl_status_t dotdot_set_unify_schedule_entry_lock_hourtzo(
+  const dotdot_unid_t unid,
+  dotdot_endpoint_id_t endpoint_id,
+  attribute_store_node_value_state_t value_state,
+  uint8_t new_hourtzo
+  )
+{
+  attribute_store_node_t endpoint_node = unify_dotdot_attributes_get_endpoint_node()(unid, endpoint_id);
+
+  attribute_store_node_t node
+    = attribute_store_get_first_child_by_type(
+      endpoint_node,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_HOURTZO);
+
+  return attribute_store_set_node_attribute_value(node,
+                                                  value_state,
+                                                  (uint8_t *)&new_hourtzo,
+                                                  sizeof(uint8_t));
+  }
+
+sl_status_t dotdot_unify_schedule_entry_lock_hourtzo_undefine_reported(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id) {
+  attribute_store_node_t endpoint_node = unify_dotdot_attributes_get_endpoint_node()(unid, endpoint_id);
+  attribute_store_node_t node
+    = attribute_store_get_first_child_by_type(
+      endpoint_node,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_HOURTZO);
+  attribute_store_undefine_reported(node);
+  return (node != ATTRIBUTE_STORE_INVALID_NODE) ? SL_STATUS_OK : SL_STATUS_FAIL;
+}
+
+sl_status_t dotdot_unify_schedule_entry_lock_hourtzo_undefine_desired(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id) {
+
+  attribute_store_node_t endpoint_node = unify_dotdot_attributes_get_endpoint_node()(unid, endpoint_id);
+  attribute_store_node_t node
+    = attribute_store_get_first_child_by_type(
+      endpoint_node,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_HOURTZO);
+  attribute_store_undefine_desired(node);
+  return (node != ATTRIBUTE_STORE_INVALID_NODE) ? SL_STATUS_OK : SL_STATUS_FAIL;
+}
+
+
+bool dotdot_unify_schedule_entry_lock_hourtzo_is_reported_defined(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id)
+{
+  attribute_store_node_t endpoint_node = unify_dotdot_attributes_get_endpoint_node()(unid, endpoint_id);
+  attribute_store_node_t node
+    = attribute_store_get_first_child_by_type(
+      endpoint_node,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_HOURTZO);
+  return attribute_store_is_reported_defined(node);
+}
+
+bool dotdot_unify_schedule_entry_lock_hourtzo_is_desired_defined(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id)
+{
+  attribute_store_node_t endpoint_node = unify_dotdot_attributes_get_endpoint_node()(unid, endpoint_id);
+  attribute_store_node_t node
+    = attribute_store_get_first_child_by_type(
+      endpoint_node,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_HOURTZO);
+  return attribute_store_is_desired_defined(node);
+}
+
+sl_status_t dotdot_create_unify_schedule_entry_lock_hourtzo(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id) {
+
+  attribute_store_node_t endpoint_node = unify_dotdot_attributes_get_endpoint_node()(unid, endpoint_id);
+  attribute_store_node_t node =
+    attribute_store_create_child_if_missing(endpoint_node,
+                                           DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_HOURTZO);
+
+  return (node != ATTRIBUTE_STORE_INVALID_NODE) ? SL_STATUS_OK : SL_STATUS_FAIL;
+}
+bool dotdot_is_supported_unify_schedule_entry_lock_minutetzo(
+  const dotdot_unid_t unid, const dotdot_endpoint_id_t endpoint_id)
+{
+  attribute_store_node_t endpoint_node = unify_dotdot_attributes_get_endpoint_node()(unid, endpoint_id);
+  attribute_store_node_t node
+    = attribute_store_get_first_child_by_type(
+      endpoint_node,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_MINUTETZO);
+  return attribute_store_node_exists(node);
+}
+
+uint8_t dotdot_get_unify_schedule_entry_lock_minutetzo(
+  const dotdot_unid_t unid,
+  dotdot_endpoint_id_t endpoint_id,
+  attribute_store_node_value_state_t value_state)
+{
+  attribute_store_node_t endpoint_node = unify_dotdot_attributes_get_endpoint_node()(unid, endpoint_id);
+  attribute_store_node_t node
+    = attribute_store_get_first_child_by_type(
+      endpoint_node,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_MINUTETZO);
+
+  uint8_t result = {};
+  attribute_store_read_value(node,
+                             value_state,
+                             (uint8_t *)&result,
+                             sizeof(result));
+  return result;
+}
+
+sl_status_t dotdot_set_unify_schedule_entry_lock_minutetzo(
+  const dotdot_unid_t unid,
+  dotdot_endpoint_id_t endpoint_id,
+  attribute_store_node_value_state_t value_state,
+  uint8_t new_minutetzo
+  )
+{
+  attribute_store_node_t endpoint_node = unify_dotdot_attributes_get_endpoint_node()(unid, endpoint_id);
+
+  attribute_store_node_t node
+    = attribute_store_get_first_child_by_type(
+      endpoint_node,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_MINUTETZO);
+
+  return attribute_store_set_node_attribute_value(node,
+                                                  value_state,
+                                                  (uint8_t *)&new_minutetzo,
+                                                  sizeof(uint8_t));
+  }
+
+sl_status_t dotdot_unify_schedule_entry_lock_minutetzo_undefine_reported(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id) {
+  attribute_store_node_t endpoint_node = unify_dotdot_attributes_get_endpoint_node()(unid, endpoint_id);
+  attribute_store_node_t node
+    = attribute_store_get_first_child_by_type(
+      endpoint_node,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_MINUTETZO);
+  attribute_store_undefine_reported(node);
+  return (node != ATTRIBUTE_STORE_INVALID_NODE) ? SL_STATUS_OK : SL_STATUS_FAIL;
+}
+
+sl_status_t dotdot_unify_schedule_entry_lock_minutetzo_undefine_desired(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id) {
+
+  attribute_store_node_t endpoint_node = unify_dotdot_attributes_get_endpoint_node()(unid, endpoint_id);
+  attribute_store_node_t node
+    = attribute_store_get_first_child_by_type(
+      endpoint_node,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_MINUTETZO);
+  attribute_store_undefine_desired(node);
+  return (node != ATTRIBUTE_STORE_INVALID_NODE) ? SL_STATUS_OK : SL_STATUS_FAIL;
+}
+
+
+bool dotdot_unify_schedule_entry_lock_minutetzo_is_reported_defined(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id)
+{
+  attribute_store_node_t endpoint_node = unify_dotdot_attributes_get_endpoint_node()(unid, endpoint_id);
+  attribute_store_node_t node
+    = attribute_store_get_first_child_by_type(
+      endpoint_node,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_MINUTETZO);
+  return attribute_store_is_reported_defined(node);
+}
+
+bool dotdot_unify_schedule_entry_lock_minutetzo_is_desired_defined(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id)
+{
+  attribute_store_node_t endpoint_node = unify_dotdot_attributes_get_endpoint_node()(unid, endpoint_id);
+  attribute_store_node_t node
+    = attribute_store_get_first_child_by_type(
+      endpoint_node,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_MINUTETZO);
+  return attribute_store_is_desired_defined(node);
+}
+
+sl_status_t dotdot_create_unify_schedule_entry_lock_minutetzo(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id) {
+
+  attribute_store_node_t endpoint_node = unify_dotdot_attributes_get_endpoint_node()(unid, endpoint_id);
+  attribute_store_node_t node =
+    attribute_store_create_child_if_missing(endpoint_node,
+                                           DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_MINUTETZO);
+
+  return (node != ATTRIBUTE_STORE_INVALID_NODE) ? SL_STATUS_OK : SL_STATUS_FAIL;
+}
+bool dotdot_is_supported_unify_schedule_entry_lock_dst_offset_sign(
+  const dotdot_unid_t unid, const dotdot_endpoint_id_t endpoint_id)
+{
+  attribute_store_node_t endpoint_node = unify_dotdot_attributes_get_endpoint_node()(unid, endpoint_id);
+  attribute_store_node_t node
+    = attribute_store_get_first_child_by_type(
+      endpoint_node,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_DST_OFFSET_SIGN);
+  return attribute_store_node_exists(node);
+}
+
+uint8_t dotdot_get_unify_schedule_entry_lock_dst_offset_sign(
+  const dotdot_unid_t unid,
+  dotdot_endpoint_id_t endpoint_id,
+  attribute_store_node_value_state_t value_state)
+{
+  attribute_store_node_t endpoint_node = unify_dotdot_attributes_get_endpoint_node()(unid, endpoint_id);
+  attribute_store_node_t node
+    = attribute_store_get_first_child_by_type(
+      endpoint_node,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_DST_OFFSET_SIGN);
+
+  uint8_t result = {};
+  attribute_store_read_value(node,
+                             value_state,
+                             (uint8_t *)&result,
+                             sizeof(result));
+  return result;
+}
+
+sl_status_t dotdot_set_unify_schedule_entry_lock_dst_offset_sign(
+  const dotdot_unid_t unid,
+  dotdot_endpoint_id_t endpoint_id,
+  attribute_store_node_value_state_t value_state,
+  uint8_t new_dst_offset_sign
+  )
+{
+  attribute_store_node_t endpoint_node = unify_dotdot_attributes_get_endpoint_node()(unid, endpoint_id);
+
+  attribute_store_node_t node
+    = attribute_store_get_first_child_by_type(
+      endpoint_node,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_DST_OFFSET_SIGN);
+
+  return attribute_store_set_node_attribute_value(node,
+                                                  value_state,
+                                                  (uint8_t *)&new_dst_offset_sign,
+                                                  sizeof(uint8_t));
+  }
+
+sl_status_t dotdot_unify_schedule_entry_lock_dst_offset_sign_undefine_reported(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id) {
+  attribute_store_node_t endpoint_node = unify_dotdot_attributes_get_endpoint_node()(unid, endpoint_id);
+  attribute_store_node_t node
+    = attribute_store_get_first_child_by_type(
+      endpoint_node,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_DST_OFFSET_SIGN);
+  attribute_store_undefine_reported(node);
+  return (node != ATTRIBUTE_STORE_INVALID_NODE) ? SL_STATUS_OK : SL_STATUS_FAIL;
+}
+
+sl_status_t dotdot_unify_schedule_entry_lock_dst_offset_sign_undefine_desired(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id) {
+
+  attribute_store_node_t endpoint_node = unify_dotdot_attributes_get_endpoint_node()(unid, endpoint_id);
+  attribute_store_node_t node
+    = attribute_store_get_first_child_by_type(
+      endpoint_node,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_DST_OFFSET_SIGN);
+  attribute_store_undefine_desired(node);
+  return (node != ATTRIBUTE_STORE_INVALID_NODE) ? SL_STATUS_OK : SL_STATUS_FAIL;
+}
+
+
+bool dotdot_unify_schedule_entry_lock_dst_offset_sign_is_reported_defined(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id)
+{
+  attribute_store_node_t endpoint_node = unify_dotdot_attributes_get_endpoint_node()(unid, endpoint_id);
+  attribute_store_node_t node
+    = attribute_store_get_first_child_by_type(
+      endpoint_node,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_DST_OFFSET_SIGN);
+  return attribute_store_is_reported_defined(node);
+}
+
+bool dotdot_unify_schedule_entry_lock_dst_offset_sign_is_desired_defined(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id)
+{
+  attribute_store_node_t endpoint_node = unify_dotdot_attributes_get_endpoint_node()(unid, endpoint_id);
+  attribute_store_node_t node
+    = attribute_store_get_first_child_by_type(
+      endpoint_node,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_DST_OFFSET_SIGN);
+  return attribute_store_is_desired_defined(node);
+}
+
+sl_status_t dotdot_create_unify_schedule_entry_lock_dst_offset_sign(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id) {
+
+  attribute_store_node_t endpoint_node = unify_dotdot_attributes_get_endpoint_node()(unid, endpoint_id);
+  attribute_store_node_t node =
+    attribute_store_create_child_if_missing(endpoint_node,
+                                           DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_DST_OFFSET_SIGN);
+
+  return (node != ATTRIBUTE_STORE_INVALID_NODE) ? SL_STATUS_OK : SL_STATUS_FAIL;
+}
+bool dotdot_is_supported_unify_schedule_entry_lock_dst_offset_minute(
+  const dotdot_unid_t unid, const dotdot_endpoint_id_t endpoint_id)
+{
+  attribute_store_node_t endpoint_node = unify_dotdot_attributes_get_endpoint_node()(unid, endpoint_id);
+  attribute_store_node_t node
+    = attribute_store_get_first_child_by_type(
+      endpoint_node,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_DST_OFFSET_MINUTE);
+  return attribute_store_node_exists(node);
+}
+
+uint8_t dotdot_get_unify_schedule_entry_lock_dst_offset_minute(
+  const dotdot_unid_t unid,
+  dotdot_endpoint_id_t endpoint_id,
+  attribute_store_node_value_state_t value_state)
+{
+  attribute_store_node_t endpoint_node = unify_dotdot_attributes_get_endpoint_node()(unid, endpoint_id);
+  attribute_store_node_t node
+    = attribute_store_get_first_child_by_type(
+      endpoint_node,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_DST_OFFSET_MINUTE);
+
+  uint8_t result = {};
+  attribute_store_read_value(node,
+                             value_state,
+                             (uint8_t *)&result,
+                             sizeof(result));
+  return result;
+}
+
+sl_status_t dotdot_set_unify_schedule_entry_lock_dst_offset_minute(
+  const dotdot_unid_t unid,
+  dotdot_endpoint_id_t endpoint_id,
+  attribute_store_node_value_state_t value_state,
+  uint8_t new_dst_offset_minute
+  )
+{
+  attribute_store_node_t endpoint_node = unify_dotdot_attributes_get_endpoint_node()(unid, endpoint_id);
+
+  attribute_store_node_t node
+    = attribute_store_get_first_child_by_type(
+      endpoint_node,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_DST_OFFSET_MINUTE);
+
+  return attribute_store_set_node_attribute_value(node,
+                                                  value_state,
+                                                  (uint8_t *)&new_dst_offset_minute,
+                                                  sizeof(uint8_t));
+  }
+
+sl_status_t dotdot_unify_schedule_entry_lock_dst_offset_minute_undefine_reported(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id) {
+  attribute_store_node_t endpoint_node = unify_dotdot_attributes_get_endpoint_node()(unid, endpoint_id);
+  attribute_store_node_t node
+    = attribute_store_get_first_child_by_type(
+      endpoint_node,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_DST_OFFSET_MINUTE);
+  attribute_store_undefine_reported(node);
+  return (node != ATTRIBUTE_STORE_INVALID_NODE) ? SL_STATUS_OK : SL_STATUS_FAIL;
+}
+
+sl_status_t dotdot_unify_schedule_entry_lock_dst_offset_minute_undefine_desired(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id) {
+
+  attribute_store_node_t endpoint_node = unify_dotdot_attributes_get_endpoint_node()(unid, endpoint_id);
+  attribute_store_node_t node
+    = attribute_store_get_first_child_by_type(
+      endpoint_node,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_DST_OFFSET_MINUTE);
+  attribute_store_undefine_desired(node);
+  return (node != ATTRIBUTE_STORE_INVALID_NODE) ? SL_STATUS_OK : SL_STATUS_FAIL;
+}
+
+
+bool dotdot_unify_schedule_entry_lock_dst_offset_minute_is_reported_defined(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id)
+{
+  attribute_store_node_t endpoint_node = unify_dotdot_attributes_get_endpoint_node()(unid, endpoint_id);
+  attribute_store_node_t node
+    = attribute_store_get_first_child_by_type(
+      endpoint_node,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_DST_OFFSET_MINUTE);
+  return attribute_store_is_reported_defined(node);
+}
+
+bool dotdot_unify_schedule_entry_lock_dst_offset_minute_is_desired_defined(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id)
+{
+  attribute_store_node_t endpoint_node = unify_dotdot_attributes_get_endpoint_node()(unid, endpoint_id);
+  attribute_store_node_t node
+    = attribute_store_get_first_child_by_type(
+      endpoint_node,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_DST_OFFSET_MINUTE);
+  return attribute_store_is_desired_defined(node);
+}
+
+sl_status_t dotdot_create_unify_schedule_entry_lock_dst_offset_minute(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id) {
+
+  attribute_store_node_t endpoint_node = unify_dotdot_attributes_get_endpoint_node()(unid, endpoint_id);
+  attribute_store_node_t node =
+    attribute_store_create_child_if_missing(endpoint_node,
+                                           DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_DST_OFFSET_MINUTE);
+
+  return (node != ATTRIBUTE_STORE_INVALID_NODE) ? SL_STATUS_OK : SL_STATUS_FAIL;
+}
+bool dotdot_is_supported_unify_schedule_entry_lock_number_of_slots_daily_repeating(
+  const dotdot_unid_t unid, const dotdot_endpoint_id_t endpoint_id)
+{
+  attribute_store_node_t endpoint_node = unify_dotdot_attributes_get_endpoint_node()(unid, endpoint_id);
+  attribute_store_node_t node
+    = attribute_store_get_first_child_by_type(
+      endpoint_node,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_NUMBER_OF_SLOTS_DAILY_REPEATING);
+  return attribute_store_node_exists(node);
+}
+
+uint8_t dotdot_get_unify_schedule_entry_lock_number_of_slots_daily_repeating(
+  const dotdot_unid_t unid,
+  dotdot_endpoint_id_t endpoint_id,
+  attribute_store_node_value_state_t value_state)
+{
+  attribute_store_node_t endpoint_node = unify_dotdot_attributes_get_endpoint_node()(unid, endpoint_id);
+  attribute_store_node_t node
+    = attribute_store_get_first_child_by_type(
+      endpoint_node,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_NUMBER_OF_SLOTS_DAILY_REPEATING);
+
+  uint8_t result = {};
+  attribute_store_read_value(node,
+                             value_state,
+                             (uint8_t *)&result,
+                             sizeof(result));
+  return result;
+}
+
+sl_status_t dotdot_set_unify_schedule_entry_lock_number_of_slots_daily_repeating(
+  const dotdot_unid_t unid,
+  dotdot_endpoint_id_t endpoint_id,
+  attribute_store_node_value_state_t value_state,
+  uint8_t new_number_of_slots_daily_repeating
+  )
+{
+  attribute_store_node_t endpoint_node = unify_dotdot_attributes_get_endpoint_node()(unid, endpoint_id);
+
+  attribute_store_node_t node
+    = attribute_store_get_first_child_by_type(
+      endpoint_node,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_NUMBER_OF_SLOTS_DAILY_REPEATING);
+
+  return attribute_store_set_node_attribute_value(node,
+                                                  value_state,
+                                                  (uint8_t *)&new_number_of_slots_daily_repeating,
+                                                  sizeof(uint8_t));
+  }
+
+sl_status_t dotdot_unify_schedule_entry_lock_number_of_slots_daily_repeating_undefine_reported(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id) {
+  attribute_store_node_t endpoint_node = unify_dotdot_attributes_get_endpoint_node()(unid, endpoint_id);
+  attribute_store_node_t node
+    = attribute_store_get_first_child_by_type(
+      endpoint_node,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_NUMBER_OF_SLOTS_DAILY_REPEATING);
+  attribute_store_undefine_reported(node);
+  return (node != ATTRIBUTE_STORE_INVALID_NODE) ? SL_STATUS_OK : SL_STATUS_FAIL;
+}
+
+sl_status_t dotdot_unify_schedule_entry_lock_number_of_slots_daily_repeating_undefine_desired(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id) {
+
+  attribute_store_node_t endpoint_node = unify_dotdot_attributes_get_endpoint_node()(unid, endpoint_id);
+  attribute_store_node_t node
+    = attribute_store_get_first_child_by_type(
+      endpoint_node,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_NUMBER_OF_SLOTS_DAILY_REPEATING);
+  attribute_store_undefine_desired(node);
+  return (node != ATTRIBUTE_STORE_INVALID_NODE) ? SL_STATUS_OK : SL_STATUS_FAIL;
+}
+
+
+bool dotdot_unify_schedule_entry_lock_number_of_slots_daily_repeating_is_reported_defined(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id)
+{
+  attribute_store_node_t endpoint_node = unify_dotdot_attributes_get_endpoint_node()(unid, endpoint_id);
+  attribute_store_node_t node
+    = attribute_store_get_first_child_by_type(
+      endpoint_node,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_NUMBER_OF_SLOTS_DAILY_REPEATING);
+  return attribute_store_is_reported_defined(node);
+}
+
+bool dotdot_unify_schedule_entry_lock_number_of_slots_daily_repeating_is_desired_defined(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id)
+{
+  attribute_store_node_t endpoint_node = unify_dotdot_attributes_get_endpoint_node()(unid, endpoint_id);
+  attribute_store_node_t node
+    = attribute_store_get_first_child_by_type(
+      endpoint_node,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_NUMBER_OF_SLOTS_DAILY_REPEATING);
+  return attribute_store_is_desired_defined(node);
+}
+
+sl_status_t dotdot_create_unify_schedule_entry_lock_number_of_slots_daily_repeating(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id) {
+
+  attribute_store_node_t endpoint_node = unify_dotdot_attributes_get_endpoint_node()(unid, endpoint_id);
+  attribute_store_node_t node =
+    attribute_store_create_child_if_missing(endpoint_node,
+                                           DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_NUMBER_OF_SLOTS_DAILY_REPEATING);
+
+  return (node != ATTRIBUTE_STORE_INVALID_NODE) ? SL_STATUS_OK : SL_STATUS_FAIL;
+}
+
+bool dotdot_is_any_unify_schedule_entry_lock_attribute_supported(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id) {
+
+  if (true == dotdot_is_supported_unify_schedule_entry_lock_slots_week_day(unid, endpoint_id)) {
+    return true;
+  }
+  if (true == dotdot_is_supported_unify_schedule_entry_lock_slots_year_day(unid, endpoint_id)) {
+    return true;
+  }
+  if (true == dotdot_is_supported_unify_schedule_entry_lock_signtzo(unid, endpoint_id)) {
+    return true;
+  }
+  if (true == dotdot_is_supported_unify_schedule_entry_lock_hourtzo(unid, endpoint_id)) {
+    return true;
+  }
+  if (true == dotdot_is_supported_unify_schedule_entry_lock_minutetzo(unid, endpoint_id)) {
+    return true;
+  }
+  if (true == dotdot_is_supported_unify_schedule_entry_lock_dst_offset_sign(unid, endpoint_id)) {
+    return true;
+  }
+  if (true == dotdot_is_supported_unify_schedule_entry_lock_dst_offset_minute(unid, endpoint_id)) {
+    return true;
+  }
+  if (true == dotdot_is_supported_unify_schedule_entry_lock_number_of_slots_daily_repeating(unid, endpoint_id)) {
+    return true;
+  }
+
+  return false;
+}
+
+bool dotdot_is_any_unify_schedule_entry_lock_writable_attribute_supported(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id) {
+
+  if (true == dotdot_is_supported_unify_schedule_entry_lock_slots_week_day(unid, endpoint_id)) {
+    return true;
+  }
+  if (true == dotdot_is_supported_unify_schedule_entry_lock_slots_year_day(unid, endpoint_id)) {
+    return true;
+  }
+  if (true == dotdot_is_supported_unify_schedule_entry_lock_signtzo(unid, endpoint_id)) {
+    return true;
+  }
+  if (true == dotdot_is_supported_unify_schedule_entry_lock_hourtzo(unid, endpoint_id)) {
+    return true;
+  }
+  if (true == dotdot_is_supported_unify_schedule_entry_lock_minutetzo(unid, endpoint_id)) {
+    return true;
+  }
+  if (true == dotdot_is_supported_unify_schedule_entry_lock_dst_offset_sign(unid, endpoint_id)) {
+    return true;
+  }
+  if (true == dotdot_is_supported_unify_schedule_entry_lock_dst_offset_minute(unid, endpoint_id)) {
+    return true;
+  }
+  if (true == dotdot_is_supported_unify_schedule_entry_lock_number_of_slots_daily_repeating(unid, endpoint_id)) {
+    return true;
+  }
+
+  return false;
+}
+////////////////////////////////////////////////////////////////////////////////
 // Start of cluster UnifyHumidityControl
 ////////////////////////////////////////////////////////////////////////////////
 bool dotdot_is_supported_unify_humidity_control_reporting_mode(
diff --git a/components/unify_dotdot_attribute_store/zap-generated/src/unify_dotdot_attribute_store_registration.cpp b/components/unify_dotdot_attribute_store/zap-generated/src/unify_dotdot_attribute_store_registration.cpp
index bbc56dd97a..9a62d6f406 100644
--- a/components/unify_dotdot_attribute_store/zap-generated/src/unify_dotdot_attribute_store_registration.cpp
+++ b/components/unify_dotdot_attribute_store/zap-generated/src/unify_dotdot_attribute_store_registration.cpp
@@ -17047,6 +17047,198 @@ sl_status_t unify_dotdot_attribute_store_registration_init()
   // clang-format off
   // clang-format on
 
+  {
+    // uint8 // uint8 // uint8_t
+    std::string attribute_type_string           = "uint8_t";
+    attribute_store_storage_type_t storage_type = UNKNOWN_STORAGE_TYPE;
+
+    // clang-format off
+    storage_type = attribute_storage_type_conversion(attribute_type_string);
+
+    if (storage_type == UNKNOWN_STORAGE_TYPE) {
+      sl_log_warning(LOG_TAG,
+                     "Unkown storage type for ZCL UnifyScheduleEntryLock SlotsWeekDay, "
+                     "type:  uint8 // uint8_t");
+    }
+
+    status |= attribute_store_register_type(
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_SLOTS_WEEK_DAY,
+      "ZCL UnifyScheduleEntryLock SlotsWeekDay",
+      ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE,
+      storage_type);
+  }
+
+  // clang-format off
+  // clang-format on
+
+  {
+    // uint8 // uint8 // uint8_t
+    std::string attribute_type_string           = "uint8_t";
+    attribute_store_storage_type_t storage_type = UNKNOWN_STORAGE_TYPE;
+
+    // clang-format off
+    storage_type = attribute_storage_type_conversion(attribute_type_string);
+
+    if (storage_type == UNKNOWN_STORAGE_TYPE) {
+      sl_log_warning(LOG_TAG,
+                     "Unkown storage type for ZCL UnifyScheduleEntryLock SlotsYearDay, "
+                     "type:  uint8 // uint8_t");
+    }
+
+    status |= attribute_store_register_type(
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_SLOTS_YEAR_DAY,
+      "ZCL UnifyScheduleEntryLock SlotsYearDay",
+      ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE,
+      storage_type);
+  }
+
+  // clang-format off
+  // clang-format on
+
+  {
+    // uint8 // uint8 // uint8_t
+    std::string attribute_type_string           = "uint8_t";
+    attribute_store_storage_type_t storage_type = UNKNOWN_STORAGE_TYPE;
+
+    // clang-format off
+    storage_type = attribute_storage_type_conversion(attribute_type_string);
+
+    if (storage_type == UNKNOWN_STORAGE_TYPE) {
+      sl_log_warning(LOG_TAG,
+                     "Unkown storage type for ZCL UnifyScheduleEntryLock SignTZO, "
+                     "type:  uint8 // uint8_t");
+    }
+
+    status |= attribute_store_register_type(
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_SIGNTZO,
+      "ZCL UnifyScheduleEntryLock SignTZO",
+      ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE,
+      storage_type);
+  }
+
+  // clang-format off
+  // clang-format on
+
+  {
+    // uint8 // uint8 // uint8_t
+    std::string attribute_type_string           = "uint8_t";
+    attribute_store_storage_type_t storage_type = UNKNOWN_STORAGE_TYPE;
+
+    // clang-format off
+    storage_type = attribute_storage_type_conversion(attribute_type_string);
+
+    if (storage_type == UNKNOWN_STORAGE_TYPE) {
+      sl_log_warning(LOG_TAG,
+                     "Unkown storage type for ZCL UnifyScheduleEntryLock HourTZO, "
+                     "type:  uint8 // uint8_t");
+    }
+
+    status |= attribute_store_register_type(
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_HOURTZO,
+      "ZCL UnifyScheduleEntryLock HourTZO",
+      ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE,
+      storage_type);
+  }
+
+  // clang-format off
+  // clang-format on
+
+  {
+    // uint8 // uint8 // uint8_t
+    std::string attribute_type_string           = "uint8_t";
+    attribute_store_storage_type_t storage_type = UNKNOWN_STORAGE_TYPE;
+
+    // clang-format off
+    storage_type = attribute_storage_type_conversion(attribute_type_string);
+
+    if (storage_type == UNKNOWN_STORAGE_TYPE) {
+      sl_log_warning(LOG_TAG,
+                     "Unkown storage type for ZCL UnifyScheduleEntryLock MinuteTZO, "
+                     "type:  uint8 // uint8_t");
+    }
+
+    status |= attribute_store_register_type(
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_MINUTETZO,
+      "ZCL UnifyScheduleEntryLock MinuteTZO",
+      ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE,
+      storage_type);
+  }
+
+  // clang-format off
+  // clang-format on
+
+  {
+    // uint8 // uint8 // uint8_t
+    std::string attribute_type_string           = "uint8_t";
+    attribute_store_storage_type_t storage_type = UNKNOWN_STORAGE_TYPE;
+
+    // clang-format off
+    storage_type = attribute_storage_type_conversion(attribute_type_string);
+
+    if (storage_type == UNKNOWN_STORAGE_TYPE) {
+      sl_log_warning(LOG_TAG,
+                     "Unkown storage type for ZCL UnifyScheduleEntryLock DSTOffsetSign, "
+                     "type:  uint8 // uint8_t");
+    }
+
+    status |= attribute_store_register_type(
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_DST_OFFSET_SIGN,
+      "ZCL UnifyScheduleEntryLock DSTOffsetSign",
+      ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE,
+      storage_type);
+  }
+
+  // clang-format off
+  // clang-format on
+
+  {
+    // uint8 // uint8 // uint8_t
+    std::string attribute_type_string           = "uint8_t";
+    attribute_store_storage_type_t storage_type = UNKNOWN_STORAGE_TYPE;
+
+    // clang-format off
+    storage_type = attribute_storage_type_conversion(attribute_type_string);
+
+    if (storage_type == UNKNOWN_STORAGE_TYPE) {
+      sl_log_warning(LOG_TAG,
+                     "Unkown storage type for ZCL UnifyScheduleEntryLock DSTOffsetMinute, "
+                     "type:  uint8 // uint8_t");
+    }
+
+    status |= attribute_store_register_type(
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_DST_OFFSET_MINUTE,
+      "ZCL UnifyScheduleEntryLock DSTOffsetMinute",
+      ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE,
+      storage_type);
+  }
+
+  // clang-format off
+  // clang-format on
+
+  {
+    // uint8 // uint8 // uint8_t
+    std::string attribute_type_string           = "uint8_t";
+    attribute_store_storage_type_t storage_type = UNKNOWN_STORAGE_TYPE;
+
+    // clang-format off
+    storage_type = attribute_storage_type_conversion(attribute_type_string);
+
+    if (storage_type == UNKNOWN_STORAGE_TYPE) {
+      sl_log_warning(LOG_TAG,
+                     "Unkown storage type for ZCL UnifyScheduleEntryLock NumberOfSlotsDailyRepeating, "
+                     "type:  uint8 // uint8_t");
+    }
+
+    status |= attribute_store_register_type(
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SCHEDULE_ENTRY_LOCK_NUMBER_OF_SLOTS_DAILY_REPEATING,
+      "ZCL UnifyScheduleEntryLock NumberOfSlotsDailyRepeating",
+      ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE,
+      storage_type);
+  }
+
+  // clang-format off
+  // clang-format on
+
   {
     // ModeType // ModeType // ModeType
     std::string attribute_type_string           = "ModeType";
diff --git a/components/unify_dotdot_attribute_store/zap-generated/src/unify_dotdot_attribute_store_write_attributes_command_callbacks.c b/components/unify_dotdot_attribute_store/zap-generated/src/unify_dotdot_attribute_store_write_attributes_command_callbacks.c
index 0eb24791b3..a3b12da1ea 100644
--- a/components/unify_dotdot_attribute_store/zap-generated/src/unify_dotdot_attribute_store_write_attributes_command_callbacks.c
+++ b/components/unify_dotdot_attribute_store/zap-generated/src/unify_dotdot_attribute_store_write_attributes_command_callbacks.c
@@ -2556,6 +2556,68 @@ static sl_status_t unify_thermostat_cluster_write_attributes_callback(
   return SL_STATUS_OK;
 }
 ////////////////////////////////////////////////////////////////////////////////
+// Start of cluster UnifyScheduleEntryLock
+////////////////////////////////////////////////////////////////////////////////
+// WriteAttribute Callbacks unify_schedule_entry_lock
+static sl_status_t unify_schedule_entry_lock_cluster_write_attributes_callback(
+  const dotdot_unid_t unid,
+  dotdot_endpoint_id_t endpoint_id,
+  uic_mqtt_dotdot_callback_call_type_t call_type,
+  uic_mqtt_dotdot_unify_schedule_entry_lock_state_t attributes,
+  uic_mqtt_dotdot_unify_schedule_entry_lock_updated_state_t updated_attributes)
+{
+  if (false == is_write_attributes_enabled()) {
+    return SL_STATUS_FAIL;
+  }
+
+  if (call_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
+    if (is_automatic_deduction_of_supported_commands_enabled()) {
+      return dotdot_is_any_unify_schedule_entry_lock_writable_attribute_supported(unid, endpoint_id) ?
+        SL_STATUS_OK : SL_STATUS_FAIL;
+    } else {
+      return SL_STATUS_FAIL;
+    }
+  }
+
+  sl_log_debug(LOG_TAG,
+               "unify_schedule_entry_lock: Incoming WriteAttributes command for %s, endpoint %d.\n",
+               unid,
+               endpoint_id);
+  if (true == updated_attributes.slots_week_day) {
+     sl_log_debug(LOG_TAG, "Updating desired value for SlotsWeekDay attribute");
+    dotdot_set_unify_schedule_entry_lock_slots_week_day(unid, endpoint_id, DESIRED_ATTRIBUTE, attributes.slots_week_day);
+  }
+  if (true == updated_attributes.slots_year_day) {
+     sl_log_debug(LOG_TAG, "Updating desired value for SlotsYearDay attribute");
+    dotdot_set_unify_schedule_entry_lock_slots_year_day(unid, endpoint_id, DESIRED_ATTRIBUTE, attributes.slots_year_day);
+  }
+  if (true == updated_attributes.signtzo) {
+     sl_log_debug(LOG_TAG, "Updating desired value for SignTZO attribute");
+    dotdot_set_unify_schedule_entry_lock_signtzo(unid, endpoint_id, DESIRED_ATTRIBUTE, attributes.signtzo);
+  }
+  if (true == updated_attributes.hourtzo) {
+     sl_log_debug(LOG_TAG, "Updating desired value for HourTZO attribute");
+    dotdot_set_unify_schedule_entry_lock_hourtzo(unid, endpoint_id, DESIRED_ATTRIBUTE, attributes.hourtzo);
+  }
+  if (true == updated_attributes.minutetzo) {
+     sl_log_debug(LOG_TAG, "Updating desired value for MinuteTZO attribute");
+    dotdot_set_unify_schedule_entry_lock_minutetzo(unid, endpoint_id, DESIRED_ATTRIBUTE, attributes.minutetzo);
+  }
+  if (true == updated_attributes.dst_offset_sign) {
+     sl_log_debug(LOG_TAG, "Updating desired value for DSTOffsetSign attribute");
+    dotdot_set_unify_schedule_entry_lock_dst_offset_sign(unid, endpoint_id, DESIRED_ATTRIBUTE, attributes.dst_offset_sign);
+  }
+  if (true == updated_attributes.dst_offset_minute) {
+     sl_log_debug(LOG_TAG, "Updating desired value for DSTOffsetMinute attribute");
+    dotdot_set_unify_schedule_entry_lock_dst_offset_minute(unid, endpoint_id, DESIRED_ATTRIBUTE, attributes.dst_offset_minute);
+  }
+  if (true == updated_attributes.number_of_slots_daily_repeating) {
+     sl_log_debug(LOG_TAG, "Updating desired value for NumberOfSlotsDailyRepeating attribute");
+    dotdot_set_unify_schedule_entry_lock_number_of_slots_daily_repeating(unid, endpoint_id, DESIRED_ATTRIBUTE, attributes.number_of_slots_daily_repeating);
+  }
+  return SL_STATUS_OK;
+}
+////////////////////////////////////////////////////////////////////////////////
 // Start of cluster UnifyHumidityControl
 ////////////////////////////////////////////////////////////////////////////////
 // WriteAttribute Callbacks unify_humidity_control
@@ -2755,6 +2817,9 @@ sl_status_t
   uic_mqtt_dotdot_set_unify_thermostat_write_attributes_callback(
     &unify_thermostat_cluster_write_attributes_callback);
   
+  uic_mqtt_dotdot_set_unify_schedule_entry_lock_write_attributes_callback(
+    &unify_schedule_entry_lock_cluster_write_attributes_callback);
+  
   uic_mqtt_dotdot_set_unify_humidity_control_write_attributes_callback(
     &unify_humidity_control_cluster_write_attributes_callback);
   
diff --git a/components/unify_dotdot_attribute_store/zap-generated/test/unify_dotdot_attribute_store_test.c b/components/unify_dotdot_attribute_store/zap-generated/test/unify_dotdot_attribute_store_test.c
index a5dd3ae27f..d47ecc8e11 100644
--- a/components/unify_dotdot_attribute_store/zap-generated/test/unify_dotdot_attribute_store_test.c
+++ b/components/unify_dotdot_attribute_store/zap-generated/test/unify_dotdot_attribute_store_test.c
@@ -1322,6 +1322,28 @@ uic_mqtt_dotdot_unify_thermostat_write_attributes_callback_t get_uic_mqtt_dotdot
   return test_uic_mqtt_dotdot_unify_thermostat_write_attributes_callback;
 }
 
+static uic_mqtt_dotdot_unify_schedule_entry_lock_force_read_attributes_callback_t test_uic_mqtt_dotdot_unify_schedule_entry_lock_force_read_attributes_callback = NULL;
+static uic_mqtt_dotdot_unify_schedule_entry_lock_write_attributes_callback_t test_uic_mqtt_dotdot_unify_schedule_entry_lock_write_attributes_callback = NULL;
+
+uic_mqtt_dotdot_unify_schedule_entry_lock_force_read_attributes_callback_t get_uic_mqtt_dotdot_unify_schedule_entry_lock_force_read_attributes_callback(){
+  return test_uic_mqtt_dotdot_unify_schedule_entry_lock_force_read_attributes_callback;
+}
+uic_mqtt_dotdot_unify_schedule_entry_lock_write_attributes_callback_t get_uic_mqtt_dotdot_unify_schedule_entry_lock_write_attributes_callback(){
+  return test_uic_mqtt_dotdot_unify_schedule_entry_lock_write_attributes_callback;
+}
+
+static uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_week_day_report_callback_t test_uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_week_day_report_callback = NULL;
+uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_week_day_report_callback_t get_uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_week_day_report_callback(){
+  return test_uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_week_day_report_callback;
+}
+static uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_year_day_report_callback_t test_uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_year_day_report_callback = NULL;
+uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_year_day_report_callback_t get_uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_year_day_report_callback(){
+  return test_uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_year_day_report_callback;
+}
+static uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_daily_repeating_report_callback_t test_uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_daily_repeating_report_callback = NULL;
+uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_daily_repeating_report_callback_t get_uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_daily_repeating_report_callback(){
+  return test_uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_daily_repeating_report_callback;
+}
 static uic_mqtt_dotdot_unify_humidity_control_force_read_attributes_callback_t test_uic_mqtt_dotdot_unify_humidity_control_force_read_attributes_callback = NULL;
 static uic_mqtt_dotdot_unify_humidity_control_write_attributes_callback_t test_uic_mqtt_dotdot_unify_humidity_control_write_attributes_callback = NULL;
 
@@ -2931,6 +2953,31 @@ void set_uic_mqtt_dotdot_unify_thermostat_write_attributes_callback_stub(
 {
   test_uic_mqtt_dotdot_unify_thermostat_write_attributes_callback = callback;
 }
+void set_uic_mqtt_dotdot_unify_schedule_entry_lock_force_read_attributes_callback_stub(
+  const uic_mqtt_dotdot_unify_schedule_entry_lock_force_read_attributes_callback_t callback, int cmock_num_calls)
+{
+  test_uic_mqtt_dotdot_unify_schedule_entry_lock_force_read_attributes_callback = callback;
+}
+void set_uic_mqtt_dotdot_unify_schedule_entry_lock_write_attributes_callback_stub(
+  const uic_mqtt_dotdot_unify_schedule_entry_lock_write_attributes_callback_t callback, int cmock_num_calls)
+{
+  test_uic_mqtt_dotdot_unify_schedule_entry_lock_write_attributes_callback = callback;
+}
+void uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_week_day_report_callback_set_stub(
+  const uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_week_day_report_callback_t callback, int cmock_num_calls)
+{
+  test_uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_week_day_report_callback = callback;
+}
+void uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_year_day_report_callback_set_stub(
+  const uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_year_day_report_callback_t callback, int cmock_num_calls)
+{
+  test_uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_year_day_report_callback = callback;
+}
+void uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_daily_repeating_report_callback_set_stub(
+  const uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_daily_repeating_report_callback_t callback, int cmock_num_calls)
+{
+  test_uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_daily_repeating_report_callback = callback;
+}
 void set_uic_mqtt_dotdot_unify_humidity_control_force_read_attributes_callback_stub(
   const uic_mqtt_dotdot_unify_humidity_control_force_read_attributes_callback_t callback, int cmock_num_calls)
 {
@@ -3877,6 +3924,21 @@ void setUp()
   test_uic_mqtt_dotdot_unify_thermostat_write_attributes_callback = NULL;
   uic_mqtt_dotdot_set_unify_thermostat_write_attributes_callback_Stub(
     &set_uic_mqtt_dotdot_unify_thermostat_write_attributes_callback_stub);
+  test_uic_mqtt_dotdot_unify_schedule_entry_lock_force_read_attributes_callback = NULL;
+  uic_mqtt_dotdot_set_unify_schedule_entry_lock_force_read_attributes_callback_Stub(
+    &set_uic_mqtt_dotdot_unify_schedule_entry_lock_force_read_attributes_callback_stub);
+  test_uic_mqtt_dotdot_unify_schedule_entry_lock_write_attributes_callback = NULL;
+  uic_mqtt_dotdot_set_unify_schedule_entry_lock_write_attributes_callback_Stub(
+    &set_uic_mqtt_dotdot_unify_schedule_entry_lock_write_attributes_callback_stub);
+  test_uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_week_day_report_callback = NULL;
+  uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_week_day_report_callback_set_Stub(
+    &uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_week_day_report_callback_set_stub);
+  test_uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_year_day_report_callback = NULL;
+  uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_year_day_report_callback_set_Stub(
+    &uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_year_day_report_callback_set_stub);
+  test_uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_daily_repeating_report_callback = NULL;
+  uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_daily_repeating_report_callback_set_Stub(
+    &uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_daily_repeating_report_callback_set_stub);
   test_uic_mqtt_dotdot_unify_humidity_control_force_read_attributes_callback = NULL;
   uic_mqtt_dotdot_set_unify_humidity_control_force_read_attributes_callback_Stub(
     &set_uic_mqtt_dotdot_unify_humidity_control_force_read_attributes_callback_stub);
@@ -4640,6 +4702,14 @@ void test_automatic_deduction_of_supported_commands()
   TEST_ASSERT_EQUAL(SL_STATUS_OK, dotdot_create_unify_thermostat_thermostat_mode(expected_unid,expected_endpoint_id) );
   TEST_ASSERT_EQUAL(SL_STATUS_OK, dotdot_create_unify_thermostat_supported_thermostat_mode(expected_unid,expected_endpoint_id) );
   TEST_ASSERT_EQUAL(SL_STATUS_OK, dotdot_create_unify_thermostat_operating_state(expected_unid,expected_endpoint_id) );
+  TEST_ASSERT_EQUAL(SL_STATUS_OK, dotdot_create_unify_schedule_entry_lock_slots_week_day(expected_unid,expected_endpoint_id) );
+  TEST_ASSERT_EQUAL(SL_STATUS_OK, dotdot_create_unify_schedule_entry_lock_slots_year_day(expected_unid,expected_endpoint_id) );
+  TEST_ASSERT_EQUAL(SL_STATUS_OK, dotdot_create_unify_schedule_entry_lock_signtzo(expected_unid,expected_endpoint_id) );
+  TEST_ASSERT_EQUAL(SL_STATUS_OK, dotdot_create_unify_schedule_entry_lock_hourtzo(expected_unid,expected_endpoint_id) );
+  TEST_ASSERT_EQUAL(SL_STATUS_OK, dotdot_create_unify_schedule_entry_lock_minutetzo(expected_unid,expected_endpoint_id) );
+  TEST_ASSERT_EQUAL(SL_STATUS_OK, dotdot_create_unify_schedule_entry_lock_dst_offset_sign(expected_unid,expected_endpoint_id) );
+  TEST_ASSERT_EQUAL(SL_STATUS_OK, dotdot_create_unify_schedule_entry_lock_dst_offset_minute(expected_unid,expected_endpoint_id) );
+  TEST_ASSERT_EQUAL(SL_STATUS_OK, dotdot_create_unify_schedule_entry_lock_number_of_slots_daily_repeating(expected_unid,expected_endpoint_id) );
   TEST_ASSERT_EQUAL(SL_STATUS_OK, dotdot_create_unify_humidity_control_reporting_mode(expected_unid,expected_endpoint_id) );
   TEST_ASSERT_EQUAL(SL_STATUS_OK, dotdot_create_unify_humidity_control_supported_reporting_mode(expected_unid,expected_endpoint_id) );
   TEST_ASSERT_EQUAL(SL_STATUS_OK, dotdot_create_unify_humidity_control_current_state(expected_unid,expected_endpoint_id) );
@@ -7748,6 +7818,131 @@ void test_automatic_deduction_of_supported_commands()
       
       ));
   }
+  if (NULL != test_uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_week_day_report_callback) {
+    // Dummy command parameters
+      uint8_t user_identifier_value;
+      memset(&user_identifier_value, 0x00, sizeof(user_identifier_value));
+      uint8_t schedule_slotid_value;
+      memset(&schedule_slotid_value, 0x00, sizeof(schedule_slotid_value));
+      uint8_t day_of_week_value;
+      memset(&day_of_week_value, 0x00, sizeof(day_of_week_value));
+      uint8_t start_hour_value;
+      memset(&start_hour_value, 0x00, sizeof(start_hour_value));
+      uint8_t start_minute_value;
+      memset(&start_minute_value, 0x00, sizeof(start_minute_value));
+      uint8_t stop_hour_value;
+      memset(&stop_hour_value, 0x00, sizeof(stop_hour_value));
+      uint8_t stop_minute_value;
+      memset(&stop_minute_value, 0x00, sizeof(stop_minute_value));
+  // Invoke with support check
+    TEST_ASSERT_EQUAL(SL_STATUS_FAIL, test_uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_week_day_report_callback(expected_unid,expected_endpoint_id,UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
+      ,
+        user_identifier_value,
+      
+        schedule_slotid_value,
+      
+        day_of_week_value,
+      
+        start_hour_value,
+      
+        start_minute_value,
+      
+        stop_hour_value,
+      
+        stop_minute_value
+      
+      ));
+  }
+  if (NULL != test_uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_year_day_report_callback) {
+    // Dummy command parameters
+      uint8_t set_action_value;
+      memset(&set_action_value, 0x00, sizeof(set_action_value));
+      uint8_t user_identifier_value;
+      memset(&user_identifier_value, 0x00, sizeof(user_identifier_value));
+      uint8_t schedule_slotid_value;
+      memset(&schedule_slotid_value, 0x00, sizeof(schedule_slotid_value));
+      uint8_t start_year_value;
+      memset(&start_year_value, 0x00, sizeof(start_year_value));
+      uint8_t start_day_value;
+      memset(&start_day_value, 0x00, sizeof(start_day_value));
+      uint8_t start_hour_value;
+      memset(&start_hour_value, 0x00, sizeof(start_hour_value));
+      uint8_t start_minute_value;
+      memset(&start_minute_value, 0x00, sizeof(start_minute_value));
+      uint8_t stop_year_value;
+      memset(&stop_year_value, 0x00, sizeof(stop_year_value));
+      uint8_t stop_day_value;
+      memset(&stop_day_value, 0x00, sizeof(stop_day_value));
+      uint8_t stop_hour_value;
+      memset(&stop_hour_value, 0x00, sizeof(stop_hour_value));
+      uint8_t stop_minute_value;
+      memset(&stop_minute_value, 0x00, sizeof(stop_minute_value));
+  // Invoke with support check
+    TEST_ASSERT_EQUAL(SL_STATUS_FAIL, test_uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_year_day_report_callback(expected_unid,expected_endpoint_id,UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
+      ,
+        set_action_value,
+      
+        user_identifier_value,
+      
+        schedule_slotid_value,
+      
+        start_year_value,
+      
+        start_day_value,
+      
+        start_hour_value,
+      
+        start_minute_value,
+      
+        stop_year_value,
+      
+        stop_day_value,
+      
+        stop_hour_value,
+      
+        stop_minute_value
+      
+      ));
+  }
+  if (NULL != test_uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_daily_repeating_report_callback) {
+    // Dummy command parameters
+      uint8_t set_action_value;
+      memset(&set_action_value, 0x00, sizeof(set_action_value));
+      uint8_t user_identifier_value;
+      memset(&user_identifier_value, 0x00, sizeof(user_identifier_value));
+      uint8_t schedule_slotid_value;
+      memset(&schedule_slotid_value, 0x00, sizeof(schedule_slotid_value));
+      uint8_t week_day_bitmask_value;
+      memset(&week_day_bitmask_value, 0x00, sizeof(week_day_bitmask_value));
+      uint8_t start_hour_value;
+      memset(&start_hour_value, 0x00, sizeof(start_hour_value));
+      uint8_t start_minute_value;
+      memset(&start_minute_value, 0x00, sizeof(start_minute_value));
+      uint8_t duration_hour_value;
+      memset(&duration_hour_value, 0x00, sizeof(duration_hour_value));
+      uint8_t duration_minute_value;
+      memset(&duration_minute_value, 0x00, sizeof(duration_minute_value));
+  // Invoke with support check
+    TEST_ASSERT_EQUAL(SL_STATUS_FAIL, test_uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_daily_repeating_report_callback(expected_unid,expected_endpoint_id,UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
+      ,
+        set_action_value,
+      
+        user_identifier_value,
+      
+        schedule_slotid_value,
+      
+        week_day_bitmask_value,
+      
+        start_hour_value,
+      
+        start_minute_value,
+      
+        duration_hour_value,
+      
+        duration_minute_value
+      
+      ));
+  }
   if (NULL != test_uic_mqtt_dotdot_unify_humidity_control_mode_set_callback) {
     // Dummy command parameters
       ModeType mode_value;
@@ -10863,6 +11058,131 @@ void test_automatic_deduction_of_supported_commands()
       
       ));
   }
+  if (NULL != test_uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_week_day_report_callback) {
+    // Dummy command parameters
+      uint8_t user_identifier_value;
+      memset(&user_identifier_value, 0x00, sizeof(user_identifier_value));
+      uint8_t schedule_slotid_value;
+      memset(&schedule_slotid_value, 0x00, sizeof(schedule_slotid_value));
+      uint8_t day_of_week_value;
+      memset(&day_of_week_value, 0x00, sizeof(day_of_week_value));
+      uint8_t start_hour_value;
+      memset(&start_hour_value, 0x00, sizeof(start_hour_value));
+      uint8_t start_minute_value;
+      memset(&start_minute_value, 0x00, sizeof(start_minute_value));
+      uint8_t stop_hour_value;
+      memset(&stop_hour_value, 0x00, sizeof(stop_hour_value));
+      uint8_t stop_minute_value;
+      memset(&stop_minute_value, 0x00, sizeof(stop_minute_value));
+  // Invoke with support check
+    TEST_ASSERT_EQUAL(SL_STATUS_OK, test_uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_week_day_report_callback(expected_unid,expected_endpoint_id,UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
+      ,
+        user_identifier_value,
+      
+        schedule_slotid_value,
+      
+        day_of_week_value,
+      
+        start_hour_value,
+      
+        start_minute_value,
+      
+        stop_hour_value,
+      
+        stop_minute_value
+      
+      ));
+  }
+  if (NULL != test_uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_year_day_report_callback) {
+    // Dummy command parameters
+      uint8_t set_action_value;
+      memset(&set_action_value, 0x00, sizeof(set_action_value));
+      uint8_t user_identifier_value;
+      memset(&user_identifier_value, 0x00, sizeof(user_identifier_value));
+      uint8_t schedule_slotid_value;
+      memset(&schedule_slotid_value, 0x00, sizeof(schedule_slotid_value));
+      uint8_t start_year_value;
+      memset(&start_year_value, 0x00, sizeof(start_year_value));
+      uint8_t start_day_value;
+      memset(&start_day_value, 0x00, sizeof(start_day_value));
+      uint8_t start_hour_value;
+      memset(&start_hour_value, 0x00, sizeof(start_hour_value));
+      uint8_t start_minute_value;
+      memset(&start_minute_value, 0x00, sizeof(start_minute_value));
+      uint8_t stop_year_value;
+      memset(&stop_year_value, 0x00, sizeof(stop_year_value));
+      uint8_t stop_day_value;
+      memset(&stop_day_value, 0x00, sizeof(stop_day_value));
+      uint8_t stop_hour_value;
+      memset(&stop_hour_value, 0x00, sizeof(stop_hour_value));
+      uint8_t stop_minute_value;
+      memset(&stop_minute_value, 0x00, sizeof(stop_minute_value));
+  // Invoke with support check
+    TEST_ASSERT_EQUAL(SL_STATUS_OK, test_uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_year_day_report_callback(expected_unid,expected_endpoint_id,UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
+      ,
+        set_action_value,
+      
+        user_identifier_value,
+      
+        schedule_slotid_value,
+      
+        start_year_value,
+      
+        start_day_value,
+      
+        start_hour_value,
+      
+        start_minute_value,
+      
+        stop_year_value,
+      
+        stop_day_value,
+      
+        stop_hour_value,
+      
+        stop_minute_value
+      
+      ));
+  }
+  if (NULL != test_uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_daily_repeating_report_callback) {
+    // Dummy command parameters
+      uint8_t set_action_value;
+      memset(&set_action_value, 0x00, sizeof(set_action_value));
+      uint8_t user_identifier_value;
+      memset(&user_identifier_value, 0x00, sizeof(user_identifier_value));
+      uint8_t schedule_slotid_value;
+      memset(&schedule_slotid_value, 0x00, sizeof(schedule_slotid_value));
+      uint8_t week_day_bitmask_value;
+      memset(&week_day_bitmask_value, 0x00, sizeof(week_day_bitmask_value));
+      uint8_t start_hour_value;
+      memset(&start_hour_value, 0x00, sizeof(start_hour_value));
+      uint8_t start_minute_value;
+      memset(&start_minute_value, 0x00, sizeof(start_minute_value));
+      uint8_t duration_hour_value;
+      memset(&duration_hour_value, 0x00, sizeof(duration_hour_value));
+      uint8_t duration_minute_value;
+      memset(&duration_minute_value, 0x00, sizeof(duration_minute_value));
+  // Invoke with support check
+    TEST_ASSERT_EQUAL(SL_STATUS_OK, test_uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_daily_repeating_report_callback(expected_unid,expected_endpoint_id,UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
+      ,
+        set_action_value,
+      
+        user_identifier_value,
+      
+        schedule_slotid_value,
+      
+        week_day_bitmask_value,
+      
+        start_hour_value,
+      
+        start_minute_value,
+      
+        duration_hour_value,
+      
+        duration_minute_value
+      
+      ));
+  }
   if (NULL != test_uic_mqtt_dotdot_unify_humidity_control_mode_set_callback) {
     // Dummy command parameters
       ModeType mode_value;
diff --git a/components/unify_dotdot_attribute_store/zap-generated/test/unify_dotdot_attribute_store_test.h b/components/unify_dotdot_attribute_store/zap-generated/test/unify_dotdot_attribute_store_test.h
index 35ada30800..cf53259d15 100644
--- a/components/unify_dotdot_attribute_store/zap-generated/test/unify_dotdot_attribute_store_test.h
+++ b/components/unify_dotdot_attribute_store/zap-generated/test/unify_dotdot_attribute_store_test.h
@@ -798,6 +798,19 @@
   uic_mqtt_dotdot_unify_thermostat_write_attributes_callback_t get_uic_mqtt_dotdot_unify_thermostat_write_attributes_callback();
 
 
+  uic_mqtt_dotdot_unify_schedule_entry_lock_force_read_attributes_callback_t get_uic_mqtt_dotdot_unify_schedule_entry_lock_force_read_attributes_callback();
+  uic_mqtt_dotdot_unify_schedule_entry_lock_write_attributes_callback_t get_uic_mqtt_dotdot_unify_schedule_entry_lock_write_attributes_callback();
+
+
+  uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_week_day_report_callback_t get_uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_week_day_report_callback();
+
+
+  uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_year_day_report_callback_t get_uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_year_day_report_callback();
+
+
+  uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_daily_repeating_report_callback_t get_uic_mqtt_dotdot_unify_schedule_entry_lock_schedule_entry_lock_daily_repeating_report_callback();
+
+
   uic_mqtt_dotdot_unify_humidity_control_force_read_attributes_callback_t get_uic_mqtt_dotdot_unify_humidity_control_force_read_attributes_callback();
   uic_mqtt_dotdot_unify_humidity_control_write_attributes_callback_t get_uic_mqtt_dotdot_unify_humidity_control_write_attributes_callback();
 
-- 
2.39.5

