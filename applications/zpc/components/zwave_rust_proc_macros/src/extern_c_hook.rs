use once_cell::sync::OnceCell;
use proc_macro2::{Span, TokenStream};
use quote::ToTokens;
use std::sync::Mutex;

/// this is a list that contain tokens that need to be printed to the initialization hook function.
/// Other procedural macros can choose to push some code tokens to this list via [append_c_hook].
/// statement tokens are stored in this list as strings as actual statement tokens are not thread-safe ( required since this list is static)..
/// Note that tokens that are added to this list after the extern_c_hook is declared are not included in this list
static EXTERN_C_STMTS: OnceCell<Mutex<Vec<String>>> = OnceCell::new();

/// This function will output an extern c function called `zwave_command_class_init_rust_handlers`
/// the body of this function contains a list of all the registered statement tokens that where added during
/// the procedural macro phase.
/// Some proc macro's generate code that require an entry point.
/// The function that is generated by `build_extern_c_hook` provides in this need.
/// Statements can be added using [append_c_hook]
pub fn build_extern_c_hook() -> TokenStream {
    let mutex = EXTERN_C_STMTS.get_or_init(|| Mutex::new(Vec::new()));
    let mut stmts = match mutex.lock() {
        Ok(l) => l
            .iter()
            .map(String::as_str)
            .map(syn::parse_str::<syn::Stmt>)
            .filter_map(Result::ok)
            .collect::<Vec<syn::Stmt>>(),
        Err(_) => {
            return quote::quote! { compile_error!("error in init bookkeeping")}.into();
        }
    };

    let status_return: syn::Stmt = syn::parse_quote!(return 0u32;);
    stmts.push(status_return);

    let body: syn::Block = syn::Block {
        brace_token: syn::token::Brace(Span::call_site()),
        stmts: stmts,
    };

    quote::quote! {
        #[no_mangle]
        /// external hook to be connected inside C initialization. do not call this function
        /// Directly from rust. This crate expects this function to be called otherwise it will
        /// not function.
        pub unsafe extern "C" fn zwave_command_class_init_rust_handlers() -> u32
        #body
    }
}

/// Adds tokens that need to be called on initialization. This hook is called by c code on initialization.
pub fn append_c_hook(statement: syn::Stmt) {
    let mutex = EXTERN_C_STMTS.get_or_init(|| Mutex::new(Vec::new()));
    if let Ok(ref mut list) = mutex.try_lock() {
        (*list).push(statement.into_token_stream().to_string());
    }
}
