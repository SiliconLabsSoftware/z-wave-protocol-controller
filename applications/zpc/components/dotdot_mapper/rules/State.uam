// Maps the Z-Wave granted keys, Wake Up interval, etc to the UCL State topic.

// UCL Attributes
def DOTDOT_ATTRIBUTE_ID_STATE_NETWORK_STATUS 0xfd020001
def DOTDOT_ATTRIBUTE_ID_STATE_SECURITY 0xfd020002
def DOTDOT_ATTRIBUTE_ID_STATE_MAXIMUM_COMMAND_DELAY 0xfd020003

// Enum values for teh DOTDOT_ATTRIBUTE_ID_STATE_SECURITY attributes
def ZCL_NODE_STATE_SECURITY_NONE                        0
def ZCL_NODE_STATE_SECURITY_Z_WAVE_S0                   1
def ZCL_NODE_STATE_SECURITY_Z_WAVE_S2_UNAUTHENTICATED   2
def ZCL_NODE_STATE_SECURITY_Z_WAVE_S2_AUTHENTICATED     3
def ZCL_NODE_STATE_SECURITY_Z_WAVE_S2_ACCESS_CONTROL    4
def ZCL_NODE_STATE_SECURITY_ZIGBEE_Z3                   5
def ZCL_NODE_STATE_SECURITY_MATTER                      6

// Enum values for the DOTDOT_ATTRIBUTE_ID_STATE_SECURITY attributes
/*
  The mapper operates with FLOAT values. If we do:
  float value = 0xFFFFFFFF;
  uint32_t int_value = (uint32_t)round(value);

  cout << "Float value: " << value << "\n";
  cout << "Int value: " << int_value<< "\n";

  We get this:
  Float value: 4.29497e+09
  Int value: 0

  Therefore we changed the magic values for unknown and infinite to be
  compatible when a float gets rounded into uint32_t.
  */
// 0xFFFFFFFF
def MAX_COMMAND_DELAY_UNKNOWN -1
// 0xFFFFFFFE
def MAX_COMMAND_DELAY_INFINITE -2

// Z-Wave Granted keys, NIF Flags:
def ATTRIBUTE_GRANTED_SECURITY_KEYS 0x0005
def ATTRIBUTE_ZWAVE_PROTOCOL_LISTENING 0x0008
def ATTRIBUTE_ZWAVE_OPTIONAL_PROTOCOL 0x0009

def ZWAVE_NODE_INFO_LISTENING_PROTOCOL_LISTENING_MASK 0x80
def ZWAVE_NODE_INFO_OPTIONAL_PROTOCOL_SENSOR_1000MS_MASK 0x40
def ZWAVE_NODE_INFO_OPTIONAL_PROTOCOL_SENSOR_250MS_MASK  0x20

// Z-Wave security levels.
def ZWAVE_CONTROLLER_S2_ACCESS_KEY          0x04
def ZWAVE_CONTROLLER_S2_AUTHENTICATED_KEY   0x02
def ZWAVE_CONTROLLER_S2_UNAUTHENTICATED_KEY 0x01
def ZWAVE_CONTROLLER_S0_KEY                 0x80

// Wake up Command Class
def WAKE_UP             0x00008409
def INTERVAL            0x00008402
// Z-Wave Endpoint
def ENDPOINT            0x00000004

// These maps are done at NodeID level, type 3
scope 0 common_parent_type(3) {

  r'ENDPOINT[0].DOTDOT_ATTRIBUTE_ID_STATE_SECURITY =
      if (r'ATTRIBUTE_GRANTED_SECURITY_KEYS & ZWAVE_CONTROLLER_S2_ACCESS_KEY)          ZCL_NODE_STATE_SECURITY_Z_WAVE_S2_ACCESS_CONTROL
      if (r'ATTRIBUTE_GRANTED_SECURITY_KEYS & ZWAVE_CONTROLLER_S2_AUTHENTICATED_KEY)   ZCL_NODE_STATE_SECURITY_Z_WAVE_S2_AUTHENTICATED
      if (r'ATTRIBUTE_GRANTED_SECURITY_KEYS & ZWAVE_CONTROLLER_S2_UNAUTHENTICATED_KEY) ZCL_NODE_STATE_SECURITY_Z_WAVE_S2_UNAUTHENTICATED
      if (r'ATTRIBUTE_GRANTED_SECURITY_KEYS & ZWAVE_CONTROLLER_S0_KEY)                 ZCL_NODE_STATE_SECURITY_Z_WAVE_S0
      ZCL_NODE_STATE_SECURITY_NONE

  // ZPC has no NIF, no Wake up in the Attribute store.
  // We assume all nodes have this (NIF plus optional Wake Up), so we can safely
  // write that if none of this information exist, we use 0 in the last condition of the map.
  r'ENDPOINT[0].DOTDOT_ATTRIBUTE_ID_STATE_MAXIMUM_COMMAND_DELAY =
    if (r'ATTRIBUTE_ZWAVE_PROTOCOL_LISTENING & ZWAVE_NODE_INFO_LISTENING_PROTOCOL_LISTENING_MASK) 1
    if (r'ATTRIBUTE_ZWAVE_OPTIONAL_PROTOCOL & ZWAVE_NODE_INFO_OPTIONAL_PROTOCOL_SENSOR_1000MS_MASK) 5
    if (r'ATTRIBUTE_ZWAVE_OPTIONAL_PROTOCOL & ZWAVE_NODE_INFO_OPTIONAL_PROTOCOL_SENSOR_250MS_MASK)  5
    if (r'ENDPOINT[0].WAKE_UP.INTERVAL == 0) MAX_COMMAND_DELAY_UNKNOWN
    (r'ENDPOINT[0].WAKE_UP.INTERVAL or 0)

  // Copy for now the NetworkStatus from NodeID level to under Endpoint 0
  // r'ENDPOINT[0].DOTDOT_ATTRIBUTE_ID_STATE_NETWORK_STATUS = r'DOTDOT_ATTRIBUTE_ID_STATE_NETWORK_STATUS
}
