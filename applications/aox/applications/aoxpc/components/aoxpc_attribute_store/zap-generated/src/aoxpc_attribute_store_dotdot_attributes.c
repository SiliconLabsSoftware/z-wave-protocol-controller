/******************************************************************************
 * # License
 * <b>Copyright 2022 Silicon Laboratories Inc. www.silabs.com</b>
 ******************************************************************************
 * The licensor of this software is Silicon Laboratories Inc. Your use of this
 * software is governed by the terms of Silicon Labs Master Software License
 * Agreement (MSLA) available at
 * www.silabs.com/about-us/legal/master-software-license-agreement. This
 * software is distributed to you in Source Code format and is governed by the
 * sections of the MSLA applicable to Source Code.
 *
 *****************************************************************************/

// This file is generated by ZCL Advanced Platform generator. Please don't edit manually.

// Includes from this component
#include "aoxpc_attribute_store_network_helper.h"
#include "aoxpc_attribute_store_defined_attribute_types.h"

// Generic includes
#include <stdlib.h>
#include <string.h>

// Unify components
#include "sl_log.h"
#include "dotdot_mqtt.h"
#include "attribute_store_helper.h"

////////////////////////////////////////////////////////////////////////////////
// Start of cluster AoXLocator
////////////////////////////////////////////////////////////////////////////////


// IsSupported function for AoXLocator::ReportingMode
bool dotdot_is_supported_aox_locator_reporting_mode (
  const aoa_id_t unid, dotdot_endpoint_id_t endpoint) {
  attribute_store_node_t endpoint_node =
    aoxpc_attribute_store_network_helper_get_endpoint_node(unid, endpoint);

  attribute_store_node_t attribute_node =
    attribute_store_get_first_child_by_type(endpoint_node,
                                          DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_REPORTING_MODE);

  return (attribute_node != ATTRIBUTE_STORE_INVALID_NODE);
}

// Get function for AoXLocator::ReportingMode
sl_status_t dotdot_get_aox_locator_reporting_mode(
  const aoa_id_t unid,
  const dotdot_endpoint_id_t endpoint,
  uint8_t *value) {

  attribute_store_node_t endpoint_node =
    aoxpc_attribute_store_network_helper_get_endpoint_node(unid, endpoint);

  attribute_store_node_t attribute_node =
    attribute_store_get_first_child_by_type(endpoint_node,
                                          DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_REPORTING_MODE);

  return attribute_store_get_reported(attribute_node,
                                      value,
                                      sizeof(uint8_t));

}


// Set function for AoXLocator::ReportingMode
sl_status_t dotdot_set_aox_locator_reporting_mode(
  const aoa_id_t unid,
  const dotdot_endpoint_id_t endpoint,
  uint8_t new_reporting_mode) {

  attribute_store_node_t endpoint_node =
    aoxpc_attribute_store_network_helper_create_endpoint_node(unid, endpoint);

  attribute_store_node_t attribute_node =
    attribute_store_get_first_child_by_type(endpoint_node,
                                          DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_REPORTING_MODE);

  if (attribute_node == ATTRIBUTE_STORE_INVALID_NODE) {
    attribute_node = attribute_store_add_node(DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_REPORTING_MODE,
                                              endpoint_node);
  }
    return attribute_store_set_reported(attribute_node,
                                        (uint8_t *)&new_reporting_mode,
                                        sizeof(uint8_t));
}


// IsSupported function for AoXLocator::PositionAndOrientationValid
bool dotdot_is_supported_aox_locator_position_and_orientation_valid (
  const aoa_id_t unid, dotdot_endpoint_id_t endpoint) {
  attribute_store_node_t endpoint_node =
    aoxpc_attribute_store_network_helper_get_endpoint_node(unid, endpoint);

  attribute_store_node_t attribute_node =
    attribute_store_get_first_child_by_type(endpoint_node,
                                          DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_POSITION_AND_ORIENTATION_VALID);

  return (attribute_node != ATTRIBUTE_STORE_INVALID_NODE);
}

// Get function for AoXLocator::PositionAndOrientationValid
sl_status_t dotdot_get_aox_locator_position_and_orientation_valid(
  const aoa_id_t unid,
  const dotdot_endpoint_id_t endpoint,
  bool *value) {

  attribute_store_node_t endpoint_node =
    aoxpc_attribute_store_network_helper_get_endpoint_node(unid, endpoint);

  attribute_store_node_t attribute_node =
    attribute_store_get_first_child_by_type(endpoint_node,
                                          DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_POSITION_AND_ORIENTATION_VALID);

  return attribute_store_get_reported(attribute_node,
                                      value,
                                      sizeof(bool));

}


// Set function for AoXLocator::PositionAndOrientationValid
sl_status_t dotdot_set_aox_locator_position_and_orientation_valid(
  const aoa_id_t unid,
  const dotdot_endpoint_id_t endpoint,
  bool new_position_and_orientation_valid) {

  attribute_store_node_t endpoint_node =
    aoxpc_attribute_store_network_helper_create_endpoint_node(unid, endpoint);

  attribute_store_node_t attribute_node =
    attribute_store_get_first_child_by_type(endpoint_node,
                                          DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_POSITION_AND_ORIENTATION_VALID);

  if (attribute_node == ATTRIBUTE_STORE_INVALID_NODE) {
    attribute_node = attribute_store_add_node(DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_POSITION_AND_ORIENTATION_VALID,
                                              endpoint_node);
  }
    return attribute_store_set_reported(attribute_node,
                                        (uint8_t *)&new_position_and_orientation_valid,
                                        sizeof(bool));
}


// IsSupported function for AoXLocator::PositionAndOrientation
bool dotdot_is_supported_aox_locator_position_and_orientation (
  const aoa_id_t unid, dotdot_endpoint_id_t endpoint) {
  attribute_store_node_t endpoint_node =
    aoxpc_attribute_store_network_helper_get_endpoint_node(unid, endpoint);

  attribute_store_node_t attribute_node =
    attribute_store_get_first_child_by_type(endpoint_node,
                                          DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_POSITION_AND_ORIENTATION);

  return (attribute_node != ATTRIBUTE_STORE_INVALID_NODE);
}

// Get function for AoXLocator::PositionAndOrientation
sl_status_t dotdot_get_aox_locator_position_and_orientation(
  const aoa_id_t unid,
  const dotdot_endpoint_id_t endpoint,
  CoordinateAndOrientation *value) {

  attribute_store_node_t endpoint_node =
    aoxpc_attribute_store_network_helper_get_endpoint_node(unid, endpoint);

  attribute_store_node_t attribute_node =
    attribute_store_get_first_child_by_type(endpoint_node,
                                          DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_POSITION_AND_ORIENTATION);

  return attribute_store_get_reported(attribute_node,
                                      value,
                                      sizeof(CoordinateAndOrientation));

}


// Set function for AoXLocator::PositionAndOrientation
sl_status_t dotdot_set_aox_locator_position_and_orientation(
  const aoa_id_t unid,
  const dotdot_endpoint_id_t endpoint,
  CoordinateAndOrientation new_position_and_orientation) {

  attribute_store_node_t endpoint_node =
    aoxpc_attribute_store_network_helper_create_endpoint_node(unid, endpoint);

  attribute_store_node_t attribute_node =
    attribute_store_get_first_child_by_type(endpoint_node,
                                          DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_POSITION_AND_ORIENTATION);

  if (attribute_node == ATTRIBUTE_STORE_INVALID_NODE) {
    attribute_node = attribute_store_add_node(DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_POSITION_AND_ORIENTATION,
                                              endpoint_node);
  }
    return attribute_store_set_reported(attribute_node,
                                        (uint8_t *)&new_position_and_orientation,
                                        sizeof(CoordinateAndOrientation));
}


// IsSupported function for AoXLocator::AzimuthMask
bool dotdot_is_supported_aox_locator_azimuth_mask (
  const aoa_id_t unid, dotdot_endpoint_id_t endpoint) {
  attribute_store_node_t endpoint_node =
    aoxpc_attribute_store_network_helper_get_endpoint_node(unid, endpoint);

  attribute_store_node_t attribute_node =
    attribute_store_get_first_child_by_type(endpoint_node,
                                          DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_AZIMUTH_MASK);

  return (attribute_node != ATTRIBUTE_STORE_INVALID_NODE);
}

// Get count function for AoXLocator::AzimuthMask
size_t dotdot_get_aox_locator_azimuth_mask_count(
  const aoa_id_t unid,
  const dotdot_endpoint_id_t endpoint) {
  attribute_store_node_t endpoint_node =
    aoxpc_attribute_store_network_helper_get_endpoint_node(unid, endpoint);

  attribute_store_node_t attribute_node =
    attribute_store_get_first_child_by_type(endpoint_node,
                                          DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_AZIMUTH_MASK);

  // Assuming only the right type is stored under the attribute node.
  return attribute_store_get_node_child_count(attribute_node);
}

// Get function for AoXLocator::AzimuthMask single element in array.
sl_status_t dotdot_get_aox_locator_azimuth_mask(
  const aoa_id_t unid,
  const dotdot_endpoint_id_t endpoint,
  MinMaxPair *value,
  size_t index) {

  attribute_store_node_t endpoint_node =
    aoxpc_attribute_store_network_helper_get_endpoint_node(unid, endpoint);

  attribute_store_node_t attribute_node =
    attribute_store_get_first_child_by_type(endpoint_node,
                                          DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_AZIMUTH_MASK);

  attribute_store_node_t child_node =
    attribute_store_get_node_child_by_type(attribute_node,
                                          DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_AZIMUTH_MASK,
                                          index);

  return attribute_store_get_reported(child_node,
                                      value,
                                      sizeof(MinMaxPair));
}



// Set function for AoXLocator::AzimuthMask
sl_status_t dotdot_set_aox_locator_azimuth_mask(
  const aoa_id_t unid,
  const dotdot_endpoint_id_t endpoint,
  size_t new_azimuth_mask_count,
  MinMaxPair* new_azimuth_mask
  ) {

  attribute_store_node_t endpoint_node =
    aoxpc_attribute_store_network_helper_create_endpoint_node(unid, endpoint);

  attribute_store_node_t attribute_node =
    attribute_store_get_first_child_by_type(endpoint_node,
                                          DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_AZIMUTH_MASK);

  if (attribute_node == ATTRIBUTE_STORE_INVALID_NODE) {
    attribute_node = attribute_store_add_node(DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_AZIMUTH_MASK,
                                              endpoint_node);
  }
  // Wipe all the children under the array holder:
  attribute_store_delete_all_children(attribute_node);
  sl_status_t set_status = SL_STATUS_OK;
  for (size_t i = 0; i< new_azimuth_mask_count;i++){
    attribute_store_node_t child_node = attribute_store_add_node(
                                          DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_AZIMUTH_MASK,
                                          attribute_node);

    set_status = attribute_store_set_reported(child_node,
                                              (uint8_t *)&new_azimuth_mask[i],
                                              sizeof(MinMaxPair));

    if (set_status != SL_STATUS_OK) {
      return set_status;
    }
  }
  return set_status;

}


// IsSupported function for AoXLocator::ElevationMask
bool dotdot_is_supported_aox_locator_elevation_mask (
  const aoa_id_t unid, dotdot_endpoint_id_t endpoint) {
  attribute_store_node_t endpoint_node =
    aoxpc_attribute_store_network_helper_get_endpoint_node(unid, endpoint);

  attribute_store_node_t attribute_node =
    attribute_store_get_first_child_by_type(endpoint_node,
                                          DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ELEVATION_MASK);

  return (attribute_node != ATTRIBUTE_STORE_INVALID_NODE);
}

// Get count function for AoXLocator::ElevationMask
size_t dotdot_get_aox_locator_elevation_mask_count(
  const aoa_id_t unid,
  const dotdot_endpoint_id_t endpoint) {
  attribute_store_node_t endpoint_node =
    aoxpc_attribute_store_network_helper_get_endpoint_node(unid, endpoint);

  attribute_store_node_t attribute_node =
    attribute_store_get_first_child_by_type(endpoint_node,
                                          DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ELEVATION_MASK);

  // Assuming only the right type is stored under the attribute node.
  return attribute_store_get_node_child_count(attribute_node);
}

// Get function for AoXLocator::ElevationMask single element in array.
sl_status_t dotdot_get_aox_locator_elevation_mask(
  const aoa_id_t unid,
  const dotdot_endpoint_id_t endpoint,
  MinMaxPair *value,
  size_t index) {

  attribute_store_node_t endpoint_node =
    aoxpc_attribute_store_network_helper_get_endpoint_node(unid, endpoint);

  attribute_store_node_t attribute_node =
    attribute_store_get_first_child_by_type(endpoint_node,
                                          DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ELEVATION_MASK);

  attribute_store_node_t child_node =
    attribute_store_get_node_child_by_type(attribute_node,
                                          DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ELEVATION_MASK,
                                          index);

  return attribute_store_get_reported(child_node,
                                      value,
                                      sizeof(MinMaxPair));
}



// Set function for AoXLocator::ElevationMask
sl_status_t dotdot_set_aox_locator_elevation_mask(
  const aoa_id_t unid,
  const dotdot_endpoint_id_t endpoint,
  size_t new_elevation_mask_count,
  MinMaxPair* new_elevation_mask
  ) {

  attribute_store_node_t endpoint_node =
    aoxpc_attribute_store_network_helper_create_endpoint_node(unid, endpoint);

  attribute_store_node_t attribute_node =
    attribute_store_get_first_child_by_type(endpoint_node,
                                          DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ELEVATION_MASK);

  if (attribute_node == ATTRIBUTE_STORE_INVALID_NODE) {
    attribute_node = attribute_store_add_node(DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ELEVATION_MASK,
                                              endpoint_node);
  }
  // Wipe all the children under the array holder:
  attribute_store_delete_all_children(attribute_node);
  sl_status_t set_status = SL_STATUS_OK;
  for (size_t i = 0; i< new_elevation_mask_count;i++){
    attribute_store_node_t child_node = attribute_store_add_node(
                                          DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ELEVATION_MASK,
                                          attribute_node);

    set_status = attribute_store_set_reported(child_node,
                                              (uint8_t *)&new_elevation_mask[i],
                                              sizeof(MinMaxPair));

    if (set_status != SL_STATUS_OK) {
      return set_status;
    }
  }
  return set_status;

}


// IsSupported function for AoXLocator::AllowList
bool dotdot_is_supported_aox_locator_allow_list (
  const aoa_id_t unid, dotdot_endpoint_id_t endpoint) {
  attribute_store_node_t endpoint_node =
    aoxpc_attribute_store_network_helper_get_endpoint_node(unid, endpoint);

  attribute_store_node_t attribute_node =
    attribute_store_get_first_child_by_type(endpoint_node,
                                          DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ALLOW_LIST);

  return (attribute_node != ATTRIBUTE_STORE_INVALID_NODE);
}

// Get count function for AoXLocator::AllowList
size_t dotdot_get_aox_locator_allow_list_count(
  const aoa_id_t unid,
  const dotdot_endpoint_id_t endpoint) {
  attribute_store_node_t endpoint_node =
    aoxpc_attribute_store_network_helper_get_endpoint_node(unid, endpoint);

  attribute_store_node_t attribute_node =
    attribute_store_get_first_child_by_type(endpoint_node,
                                          DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ALLOW_LIST);

  // Assuming only the right type is stored under the attribute node.
  return attribute_store_get_node_child_count(attribute_node);
}

// Get function for AoXLocator::AllowList single element in array.
sl_status_t dotdot_get_aox_locator_allow_list(
  const aoa_id_t unid,
  const dotdot_endpoint_id_t endpoint,
  char* value,
  size_t index) {

  attribute_store_node_t endpoint_node =
    aoxpc_attribute_store_network_helper_get_endpoint_node(unid, endpoint);

  attribute_store_node_t attribute_node =
    attribute_store_get_first_child_by_type(endpoint_node,
                                          DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ALLOW_LIST);

  attribute_store_node_t child_node =
    attribute_store_get_node_child_by_type(attribute_node,
                                          DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ALLOW_LIST,
                                          index);

  return attribute_store_get_reported_string(child_node,
                                             value,
                                             ATTRIBUTE_STORE_MAXIMUM_VALUE_LENGTH);
}



// Set function for AoXLocator::AllowList
sl_status_t dotdot_set_aox_locator_allow_list(
  const aoa_id_t unid,
  const dotdot_endpoint_id_t endpoint,
  size_t new_allow_list_count,
  const char** new_allow_list
  ) {

  attribute_store_node_t endpoint_node =
    aoxpc_attribute_store_network_helper_create_endpoint_node(unid, endpoint);

  attribute_store_node_t attribute_node =
    attribute_store_get_first_child_by_type(endpoint_node,
                                          DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ALLOW_LIST);

  if (attribute_node == ATTRIBUTE_STORE_INVALID_NODE) {
    attribute_node = attribute_store_add_node(DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ALLOW_LIST,
                                              endpoint_node);
  }
  // Wipe all the children under the array holder:
  attribute_store_delete_all_children(attribute_node);
  sl_status_t set_status = SL_STATUS_OK;
  for (size_t i = 0; i< new_allow_list_count;i++){
    attribute_store_node_t child_node = attribute_store_add_node(
                                          DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ALLOW_LIST,
                                          attribute_node);
    set_status = attribute_store_set_reported_string(child_node,
                                                     new_allow_list[i]);

    if (set_status != SL_STATUS_OK) {
      return set_status;
    }
  }
  return set_status;

}


// IsSupported function for AoXLocator::AoXMode
bool dotdot_is_supported_aox_locator_aox_mode (
  const aoa_id_t unid, dotdot_endpoint_id_t endpoint) {
  attribute_store_node_t endpoint_node =
    aoxpc_attribute_store_network_helper_get_endpoint_node(unid, endpoint);

  attribute_store_node_t attribute_node =
    attribute_store_get_first_child_by_type(endpoint_node,
                                          DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_AOX_MODE);

  return (attribute_node != ATTRIBUTE_STORE_INVALID_NODE);
}

// Get function for AoXLocator::AoXMode
sl_status_t dotdot_get_aox_locator_aox_mode(
  const aoa_id_t unid,
  const dotdot_endpoint_id_t endpoint,
  uint8_t *value) {

  attribute_store_node_t endpoint_node =
    aoxpc_attribute_store_network_helper_get_endpoint_node(unid, endpoint);

  attribute_store_node_t attribute_node =
    attribute_store_get_first_child_by_type(endpoint_node,
                                          DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_AOX_MODE);

  return attribute_store_get_reported(attribute_node,
                                      value,
                                      sizeof(uint8_t));

}


// Set function for AoXLocator::AoXMode
sl_status_t dotdot_set_aox_locator_aox_mode(
  const aoa_id_t unid,
  const dotdot_endpoint_id_t endpoint,
  uint8_t new_aox_mode) {

  attribute_store_node_t endpoint_node =
    aoxpc_attribute_store_network_helper_create_endpoint_node(unid, endpoint);

  attribute_store_node_t attribute_node =
    attribute_store_get_first_child_by_type(endpoint_node,
                                          DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_AOX_MODE);

  if (attribute_node == ATTRIBUTE_STORE_INVALID_NODE) {
    attribute_node = attribute_store_add_node(DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_AOX_MODE,
                                              endpoint_node);
  }
    return attribute_store_set_reported(attribute_node,
                                        (uint8_t *)&new_aox_mode,
                                        sizeof(uint8_t));
}


// IsSupported function for AoXLocator::AntennaMode
bool dotdot_is_supported_aox_locator_antenna_mode (
  const aoa_id_t unid, dotdot_endpoint_id_t endpoint) {
  attribute_store_node_t endpoint_node =
    aoxpc_attribute_store_network_helper_get_endpoint_node(unid, endpoint);

  attribute_store_node_t attribute_node =
    attribute_store_get_first_child_by_type(endpoint_node,
                                          DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ANTENNA_MODE);

  return (attribute_node != ATTRIBUTE_STORE_INVALID_NODE);
}

// Get function for AoXLocator::AntennaMode
sl_status_t dotdot_get_aox_locator_antenna_mode(
  const aoa_id_t unid,
  const dotdot_endpoint_id_t endpoint,
  uint8_t *value) {

  attribute_store_node_t endpoint_node =
    aoxpc_attribute_store_network_helper_get_endpoint_node(unid, endpoint);

  attribute_store_node_t attribute_node =
    attribute_store_get_first_child_by_type(endpoint_node,
                                          DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ANTENNA_MODE);

  return attribute_store_get_reported(attribute_node,
                                      value,
                                      sizeof(uint8_t));

}


// Set function for AoXLocator::AntennaMode
sl_status_t dotdot_set_aox_locator_antenna_mode(
  const aoa_id_t unid,
  const dotdot_endpoint_id_t endpoint,
  uint8_t new_antenna_mode) {

  attribute_store_node_t endpoint_node =
    aoxpc_attribute_store_network_helper_create_endpoint_node(unid, endpoint);

  attribute_store_node_t attribute_node =
    attribute_store_get_first_child_by_type(endpoint_node,
                                          DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ANTENNA_MODE);

  if (attribute_node == ATTRIBUTE_STORE_INVALID_NODE) {
    attribute_node = attribute_store_add_node(DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ANTENNA_MODE,
                                              endpoint_node);
  }
    return attribute_store_set_reported(attribute_node,
                                        (uint8_t *)&new_antenna_mode,
                                        sizeof(uint8_t));
}


// IsSupported function for AoXLocator::AntennaArray
bool dotdot_is_supported_aox_locator_antenna_array (
  const aoa_id_t unid, dotdot_endpoint_id_t endpoint) {
  attribute_store_node_t endpoint_node =
    aoxpc_attribute_store_network_helper_get_endpoint_node(unid, endpoint);

  attribute_store_node_t attribute_node =
    attribute_store_get_first_child_by_type(endpoint_node,
                                          DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ANTENNA_ARRAY);

  return (attribute_node != ATTRIBUTE_STORE_INVALID_NODE);
}

// Get count function for AoXLocator::AntennaArray
size_t dotdot_get_aox_locator_antenna_array_count(
  const aoa_id_t unid,
  const dotdot_endpoint_id_t endpoint) {
  attribute_store_node_t endpoint_node =
    aoxpc_attribute_store_network_helper_get_endpoint_node(unid, endpoint);

  attribute_store_node_t attribute_node =
    attribute_store_get_first_child_by_type(endpoint_node,
                                          DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ANTENNA_ARRAY);

  // Assuming only the right type is stored under the attribute node.
  return attribute_store_get_node_child_count(attribute_node);
}

// Get function for AoXLocator::AntennaArray single element in array.
sl_status_t dotdot_get_aox_locator_antenna_array(
  const aoa_id_t unid,
  const dotdot_endpoint_id_t endpoint,
  int8_t *value,
  size_t index) {

  attribute_store_node_t endpoint_node =
    aoxpc_attribute_store_network_helper_get_endpoint_node(unid, endpoint);

  attribute_store_node_t attribute_node =
    attribute_store_get_first_child_by_type(endpoint_node,
                                          DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ANTENNA_ARRAY);

  attribute_store_node_t child_node =
    attribute_store_get_node_child_by_type(attribute_node,
                                          DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ANTENNA_ARRAY,
                                          index);

  return attribute_store_get_reported(child_node,
                                      value,
                                      sizeof(int8_t));
}



// Set function for AoXLocator::AntennaArray
sl_status_t dotdot_set_aox_locator_antenna_array(
  const aoa_id_t unid,
  const dotdot_endpoint_id_t endpoint,
  size_t new_antenna_array_count,
  int8_t* new_antenna_array
  ) {

  attribute_store_node_t endpoint_node =
    aoxpc_attribute_store_network_helper_create_endpoint_node(unid, endpoint);

  attribute_store_node_t attribute_node =
    attribute_store_get_first_child_by_type(endpoint_node,
                                          DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ANTENNA_ARRAY);

  if (attribute_node == ATTRIBUTE_STORE_INVALID_NODE) {
    attribute_node = attribute_store_add_node(DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ANTENNA_ARRAY,
                                              endpoint_node);
  }
  // Wipe all the children under the array holder:
  attribute_store_delete_all_children(attribute_node);
  sl_status_t set_status = SL_STATUS_OK;
  for (size_t i = 0; i< new_antenna_array_count;i++){
    attribute_store_node_t child_node = attribute_store_add_node(
                                          DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ANTENNA_ARRAY,
                                          attribute_node);

    set_status = attribute_store_set_reported(child_node,
                                              (uint8_t *)&new_antenna_array[i],
                                              sizeof(int8_t));

    if (set_status != SL_STATUS_OK) {
      return set_status;
    }
  }
  return set_status;

}


// IsSupported function for AoXLocator::PeriodSamples
bool dotdot_is_supported_aox_locator_period_samples (
  const aoa_id_t unid, dotdot_endpoint_id_t endpoint) {
  attribute_store_node_t endpoint_node =
    aoxpc_attribute_store_network_helper_get_endpoint_node(unid, endpoint);

  attribute_store_node_t attribute_node =
    attribute_store_get_first_child_by_type(endpoint_node,
                                          DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_PERIOD_SAMPLES);

  return (attribute_node != ATTRIBUTE_STORE_INVALID_NODE);
}

// Get function for AoXLocator::PeriodSamples
sl_status_t dotdot_get_aox_locator_period_samples(
  const aoa_id_t unid,
  const dotdot_endpoint_id_t endpoint,
  int8_t *value) {

  attribute_store_node_t endpoint_node =
    aoxpc_attribute_store_network_helper_get_endpoint_node(unid, endpoint);

  attribute_store_node_t attribute_node =
    attribute_store_get_first_child_by_type(endpoint_node,
                                          DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_PERIOD_SAMPLES);

  return attribute_store_get_reported(attribute_node,
                                      value,
                                      sizeof(int8_t));

}


// Set function for AoXLocator::PeriodSamples
sl_status_t dotdot_set_aox_locator_period_samples(
  const aoa_id_t unid,
  const dotdot_endpoint_id_t endpoint,
  int8_t new_period_samples) {

  attribute_store_node_t endpoint_node =
    aoxpc_attribute_store_network_helper_create_endpoint_node(unid, endpoint);

  attribute_store_node_t attribute_node =
    attribute_store_get_first_child_by_type(endpoint_node,
                                          DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_PERIOD_SAMPLES);

  if (attribute_node == ATTRIBUTE_STORE_INVALID_NODE) {
    attribute_node = attribute_store_add_node(DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_PERIOD_SAMPLES,
                                              endpoint_node);
  }
    return attribute_store_set_reported(attribute_node,
                                        (uint8_t *)&new_period_samples,
                                        sizeof(int8_t));
}


// IsSupported function for AoXLocator::AngleFiltering
bool dotdot_is_supported_aox_locator_angle_filtering (
  const aoa_id_t unid, dotdot_endpoint_id_t endpoint) {
  attribute_store_node_t endpoint_node =
    aoxpc_attribute_store_network_helper_get_endpoint_node(unid, endpoint);

  attribute_store_node_t attribute_node =
    attribute_store_get_first_child_by_type(endpoint_node,
                                          DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ANGLE_FILTERING);

  return (attribute_node != ATTRIBUTE_STORE_INVALID_NODE);
}

// Get function for AoXLocator::AngleFiltering
sl_status_t dotdot_get_aox_locator_angle_filtering(
  const aoa_id_t unid,
  const dotdot_endpoint_id_t endpoint,
  bool *value) {

  attribute_store_node_t endpoint_node =
    aoxpc_attribute_store_network_helper_get_endpoint_node(unid, endpoint);

  attribute_store_node_t attribute_node =
    attribute_store_get_first_child_by_type(endpoint_node,
                                          DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ANGLE_FILTERING);

  return attribute_store_get_reported(attribute_node,
                                      value,
                                      sizeof(bool));

}


// Set function for AoXLocator::AngleFiltering
sl_status_t dotdot_set_aox_locator_angle_filtering(
  const aoa_id_t unid,
  const dotdot_endpoint_id_t endpoint,
  bool new_angle_filtering) {

  attribute_store_node_t endpoint_node =
    aoxpc_attribute_store_network_helper_create_endpoint_node(unid, endpoint);

  attribute_store_node_t attribute_node =
    attribute_store_get_first_child_by_type(endpoint_node,
                                          DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ANGLE_FILTERING);

  if (attribute_node == ATTRIBUTE_STORE_INVALID_NODE) {
    attribute_node = attribute_store_add_node(DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ANGLE_FILTERING,
                                              endpoint_node);
  }
    return attribute_store_set_reported(attribute_node,
                                        (uint8_t *)&new_angle_filtering,
                                        sizeof(bool));
}


// IsSupported function for AoXLocator::AngleFilteringWeight
bool dotdot_is_supported_aox_locator_angle_filtering_weight (
  const aoa_id_t unid, dotdot_endpoint_id_t endpoint) {
  attribute_store_node_t endpoint_node =
    aoxpc_attribute_store_network_helper_get_endpoint_node(unid, endpoint);

  attribute_store_node_t attribute_node =
    attribute_store_get_first_child_by_type(endpoint_node,
                                          DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ANGLE_FILTERING_WEIGHT);

  return (attribute_node != ATTRIBUTE_STORE_INVALID_NODE);
}

// Get function for AoXLocator::AngleFilteringWeight
sl_status_t dotdot_get_aox_locator_angle_filtering_weight(
  const aoa_id_t unid,
  const dotdot_endpoint_id_t endpoint,
  double *value) {

  attribute_store_node_t endpoint_node =
    aoxpc_attribute_store_network_helper_get_endpoint_node(unid, endpoint);

  attribute_store_node_t attribute_node =
    attribute_store_get_first_child_by_type(endpoint_node,
                                          DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ANGLE_FILTERING_WEIGHT);

  return attribute_store_get_reported(attribute_node,
                                      value,
                                      sizeof(double));

}


// Set function for AoXLocator::AngleFilteringWeight
sl_status_t dotdot_set_aox_locator_angle_filtering_weight(
  const aoa_id_t unid,
  const dotdot_endpoint_id_t endpoint,
  double new_angle_filtering_weight) {

  attribute_store_node_t endpoint_node =
    aoxpc_attribute_store_network_helper_create_endpoint_node(unid, endpoint);

  attribute_store_node_t attribute_node =
    attribute_store_get_first_child_by_type(endpoint_node,
                                          DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ANGLE_FILTERING_WEIGHT);

  if (attribute_node == ATTRIBUTE_STORE_INVALID_NODE) {
    attribute_node = attribute_store_add_node(DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ANGLE_FILTERING_WEIGHT,
                                              endpoint_node);
  }
    return attribute_store_set_reported(attribute_node,
                                        (uint8_t *)&new_angle_filtering_weight,
                                        sizeof(double));
}


// IsSupported function for AoXLocator::AngleCorrectionTimeout
bool dotdot_is_supported_aox_locator_angle_correction_timeout (
  const aoa_id_t unid, dotdot_endpoint_id_t endpoint) {
  attribute_store_node_t endpoint_node =
    aoxpc_attribute_store_network_helper_get_endpoint_node(unid, endpoint);

  attribute_store_node_t attribute_node =
    attribute_store_get_first_child_by_type(endpoint_node,
                                          DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ANGLE_CORRECTION_TIMEOUT);

  return (attribute_node != ATTRIBUTE_STORE_INVALID_NODE);
}

// Get function for AoXLocator::AngleCorrectionTimeout
sl_status_t dotdot_get_aox_locator_angle_correction_timeout(
  const aoa_id_t unid,
  const dotdot_endpoint_id_t endpoint,
  int8_t *value) {

  attribute_store_node_t endpoint_node =
    aoxpc_attribute_store_network_helper_get_endpoint_node(unid, endpoint);

  attribute_store_node_t attribute_node =
    attribute_store_get_first_child_by_type(endpoint_node,
                                          DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ANGLE_CORRECTION_TIMEOUT);

  return attribute_store_get_reported(attribute_node,
                                      value,
                                      sizeof(int8_t));

}


// Set function for AoXLocator::AngleCorrectionTimeout
sl_status_t dotdot_set_aox_locator_angle_correction_timeout(
  const aoa_id_t unid,
  const dotdot_endpoint_id_t endpoint,
  int8_t new_angle_correction_timeout) {

  attribute_store_node_t endpoint_node =
    aoxpc_attribute_store_network_helper_create_endpoint_node(unid, endpoint);

  attribute_store_node_t attribute_node =
    attribute_store_get_first_child_by_type(endpoint_node,
                                          DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ANGLE_CORRECTION_TIMEOUT);

  if (attribute_node == ATTRIBUTE_STORE_INVALID_NODE) {
    attribute_node = attribute_store_add_node(DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ANGLE_CORRECTION_TIMEOUT,
                                              endpoint_node);
  }
    return attribute_store_set_reported(attribute_node,
                                        (uint8_t *)&new_angle_correction_timeout,
                                        sizeof(int8_t));
}


// IsSupported function for AoXLocator::AngleCorrectionDelay
bool dotdot_is_supported_aox_locator_angle_correction_delay (
  const aoa_id_t unid, dotdot_endpoint_id_t endpoint) {
  attribute_store_node_t endpoint_node =
    aoxpc_attribute_store_network_helper_get_endpoint_node(unid, endpoint);

  attribute_store_node_t attribute_node =
    attribute_store_get_first_child_by_type(endpoint_node,
                                          DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ANGLE_CORRECTION_DELAY);

  return (attribute_node != ATTRIBUTE_STORE_INVALID_NODE);
}

// Get function for AoXLocator::AngleCorrectionDelay
sl_status_t dotdot_get_aox_locator_angle_correction_delay(
  const aoa_id_t unid,
  const dotdot_endpoint_id_t endpoint,
  int8_t *value) {

  attribute_store_node_t endpoint_node =
    aoxpc_attribute_store_network_helper_get_endpoint_node(unid, endpoint);

  attribute_store_node_t attribute_node =
    attribute_store_get_first_child_by_type(endpoint_node,
                                          DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ANGLE_CORRECTION_DELAY);

  return attribute_store_get_reported(attribute_node,
                                      value,
                                      sizeof(int8_t));

}


// Set function for AoXLocator::AngleCorrectionDelay
sl_status_t dotdot_set_aox_locator_angle_correction_delay(
  const aoa_id_t unid,
  const dotdot_endpoint_id_t endpoint,
  int8_t new_angle_correction_delay) {

  attribute_store_node_t endpoint_node =
    aoxpc_attribute_store_network_helper_create_endpoint_node(unid, endpoint);

  attribute_store_node_t attribute_node =
    attribute_store_get_first_child_by_type(endpoint_node,
                                          DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ANGLE_CORRECTION_DELAY);

  if (attribute_node == ATTRIBUTE_STORE_INVALID_NODE) {
    attribute_node = attribute_store_add_node(DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_ANGLE_CORRECTION_DELAY,
                                              endpoint_node);
  }
    return attribute_store_set_reported(attribute_node,
                                        (uint8_t *)&new_angle_correction_delay,
                                        sizeof(int8_t));
}


// IsSupported function for AoXLocator::CTEMode
bool dotdot_is_supported_aox_locator_cte_mode (
  const aoa_id_t unid, dotdot_endpoint_id_t endpoint) {
  attribute_store_node_t endpoint_node =
    aoxpc_attribute_store_network_helper_get_endpoint_node(unid, endpoint);

  attribute_store_node_t attribute_node =
    attribute_store_get_first_child_by_type(endpoint_node,
                                          DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_CTE_MODE);

  return (attribute_node != ATTRIBUTE_STORE_INVALID_NODE);
}

// Get function for AoXLocator::CTEMode
sl_status_t dotdot_get_aox_locator_cte_mode(
  const aoa_id_t unid,
  const dotdot_endpoint_id_t endpoint,
  uint8_t *value) {

  attribute_store_node_t endpoint_node =
    aoxpc_attribute_store_network_helper_get_endpoint_node(unid, endpoint);

  attribute_store_node_t attribute_node =
    attribute_store_get_first_child_by_type(endpoint_node,
                                          DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_CTE_MODE);

  return attribute_store_get_reported(attribute_node,
                                      value,
                                      sizeof(uint8_t));

}


// Set function for AoXLocator::CTEMode
sl_status_t dotdot_set_aox_locator_cte_mode(
  const aoa_id_t unid,
  const dotdot_endpoint_id_t endpoint,
  uint8_t new_cte_mode) {

  attribute_store_node_t endpoint_node =
    aoxpc_attribute_store_network_helper_create_endpoint_node(unid, endpoint);

  attribute_store_node_t attribute_node =
    attribute_store_get_first_child_by_type(endpoint_node,
                                          DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_CTE_MODE);

  if (attribute_node == ATTRIBUTE_STORE_INVALID_NODE) {
    attribute_node = attribute_store_add_node(DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_CTE_MODE,
                                              endpoint_node);
  }
    return attribute_store_set_reported(attribute_node,
                                        (uint8_t *)&new_cte_mode,
                                        sizeof(uint8_t));
}


// IsSupported function for AoXLocator::CTESamplingInterval
bool dotdot_is_supported_aox_locator_cte_sampling_interval (
  const aoa_id_t unid, dotdot_endpoint_id_t endpoint) {
  attribute_store_node_t endpoint_node =
    aoxpc_attribute_store_network_helper_get_endpoint_node(unid, endpoint);

  attribute_store_node_t attribute_node =
    attribute_store_get_first_child_by_type(endpoint_node,
                                          DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_CTE_SAMPLING_INTERVAL);

  return (attribute_node != ATTRIBUTE_STORE_INVALID_NODE);
}

// Get function for AoXLocator::CTESamplingInterval
sl_status_t dotdot_get_aox_locator_cte_sampling_interval(
  const aoa_id_t unid,
  const dotdot_endpoint_id_t endpoint,
  int8_t *value) {

  attribute_store_node_t endpoint_node =
    aoxpc_attribute_store_network_helper_get_endpoint_node(unid, endpoint);

  attribute_store_node_t attribute_node =
    attribute_store_get_first_child_by_type(endpoint_node,
                                          DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_CTE_SAMPLING_INTERVAL);

  return attribute_store_get_reported(attribute_node,
                                      value,
                                      sizeof(int8_t));

}


// Set function for AoXLocator::CTESamplingInterval
sl_status_t dotdot_set_aox_locator_cte_sampling_interval(
  const aoa_id_t unid,
  const dotdot_endpoint_id_t endpoint,
  int8_t new_cte_sampling_interval) {

  attribute_store_node_t endpoint_node =
    aoxpc_attribute_store_network_helper_create_endpoint_node(unid, endpoint);

  attribute_store_node_t attribute_node =
    attribute_store_get_first_child_by_type(endpoint_node,
                                          DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_CTE_SAMPLING_INTERVAL);

  if (attribute_node == ATTRIBUTE_STORE_INVALID_NODE) {
    attribute_node = attribute_store_add_node(DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_CTE_SAMPLING_INTERVAL,
                                              endpoint_node);
  }
    return attribute_store_set_reported(attribute_node,
                                        (uint8_t *)&new_cte_sampling_interval,
                                        sizeof(int8_t));
}


// IsSupported function for AoXLocator::CTELength
bool dotdot_is_supported_aox_locator_cte_length (
  const aoa_id_t unid, dotdot_endpoint_id_t endpoint) {
  attribute_store_node_t endpoint_node =
    aoxpc_attribute_store_network_helper_get_endpoint_node(unid, endpoint);

  attribute_store_node_t attribute_node =
    attribute_store_get_first_child_by_type(endpoint_node,
                                          DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_CTE_LENGTH);

  return (attribute_node != ATTRIBUTE_STORE_INVALID_NODE);
}

// Get function for AoXLocator::CTELength
sl_status_t dotdot_get_aox_locator_cte_length(
  const aoa_id_t unid,
  const dotdot_endpoint_id_t endpoint,
  int8_t *value) {

  attribute_store_node_t endpoint_node =
    aoxpc_attribute_store_network_helper_get_endpoint_node(unid, endpoint);

  attribute_store_node_t attribute_node =
    attribute_store_get_first_child_by_type(endpoint_node,
                                          DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_CTE_LENGTH);

  return attribute_store_get_reported(attribute_node,
                                      value,
                                      sizeof(int8_t));

}


// Set function for AoXLocator::CTELength
sl_status_t dotdot_set_aox_locator_cte_length(
  const aoa_id_t unid,
  const dotdot_endpoint_id_t endpoint,
  int8_t new_cte_length) {

  attribute_store_node_t endpoint_node =
    aoxpc_attribute_store_network_helper_create_endpoint_node(unid, endpoint);

  attribute_store_node_t attribute_node =
    attribute_store_get_first_child_by_type(endpoint_node,
                                          DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_CTE_LENGTH);

  if (attribute_node == ATTRIBUTE_STORE_INVALID_NODE) {
    attribute_node = attribute_store_add_node(DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_CTE_LENGTH,
                                              endpoint_node);
  }
    return attribute_store_set_reported(attribute_node,
                                        (uint8_t *)&new_cte_length,
                                        sizeof(int8_t));
}


// IsSupported function for AoXLocator::SlotDuration
bool dotdot_is_supported_aox_locator_slot_duration (
  const aoa_id_t unid, dotdot_endpoint_id_t endpoint) {
  attribute_store_node_t endpoint_node =
    aoxpc_attribute_store_network_helper_get_endpoint_node(unid, endpoint);

  attribute_store_node_t attribute_node =
    attribute_store_get_first_child_by_type(endpoint_node,
                                          DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_SLOT_DURATION);

  return (attribute_node != ATTRIBUTE_STORE_INVALID_NODE);
}

// Get function for AoXLocator::SlotDuration
sl_status_t dotdot_get_aox_locator_slot_duration(
  const aoa_id_t unid,
  const dotdot_endpoint_id_t endpoint,
  int8_t *value) {

  attribute_store_node_t endpoint_node =
    aoxpc_attribute_store_network_helper_get_endpoint_node(unid, endpoint);

  attribute_store_node_t attribute_node =
    attribute_store_get_first_child_by_type(endpoint_node,
                                          DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_SLOT_DURATION);

  return attribute_store_get_reported(attribute_node,
                                      value,
                                      sizeof(int8_t));

}


// Set function for AoXLocator::SlotDuration
sl_status_t dotdot_set_aox_locator_slot_duration(
  const aoa_id_t unid,
  const dotdot_endpoint_id_t endpoint,
  int8_t new_slot_duration) {

  attribute_store_node_t endpoint_node =
    aoxpc_attribute_store_network_helper_create_endpoint_node(unid, endpoint);

  attribute_store_node_t attribute_node =
    attribute_store_get_first_child_by_type(endpoint_node,
                                          DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_SLOT_DURATION);

  if (attribute_node == ATTRIBUTE_STORE_INVALID_NODE) {
    attribute_node = attribute_store_add_node(DOTDOT_ATTRIBUTE_ID_AOX_LOCATOR_SLOT_DURATION,
                                              endpoint_node);
  }
    return attribute_store_set_reported(attribute_node,
                                        (uint8_t *)&new_slot_duration,
                                        sizeof(int8_t));
}

////////////////////////////////////////////////////////////////////////////////
// Start of cluster AoXPositionEstimation
////////////////////////////////////////////////////////////////////////////////


// IsSupported function for AoXPositionEstimation::Position
bool dotdot_is_supported_aox_position_estimation_position (
  const aoa_id_t unid, dotdot_endpoint_id_t endpoint) {
  attribute_store_node_t endpoint_node =
    aoxpc_attribute_store_network_helper_get_endpoint_node(unid, endpoint);

  attribute_store_node_t attribute_node =
    attribute_store_get_first_child_by_type(endpoint_node,
                                          DOTDOT_ATTRIBUTE_ID_AOX_POSITION_ESTIMATION_POSITION);

  return (attribute_node != ATTRIBUTE_STORE_INVALID_NODE);
}

// Get function for AoXPositionEstimation::Position
sl_status_t dotdot_get_aox_position_estimation_position(
  const aoa_id_t unid,
  const dotdot_endpoint_id_t endpoint,
  EstimatedPosition *value) {

  attribute_store_node_t endpoint_node =
    aoxpc_attribute_store_network_helper_get_endpoint_node(unid, endpoint);

  attribute_store_node_t attribute_node =
    attribute_store_get_first_child_by_type(endpoint_node,
                                          DOTDOT_ATTRIBUTE_ID_AOX_POSITION_ESTIMATION_POSITION);

  return attribute_store_get_reported(attribute_node,
                                      value,
                                      sizeof(EstimatedPosition));

}


// Set function for AoXPositionEstimation::Position
sl_status_t dotdot_set_aox_position_estimation_position(
  const aoa_id_t unid,
  const dotdot_endpoint_id_t endpoint,
  EstimatedPosition new_position) {

  attribute_store_node_t endpoint_node =
    aoxpc_attribute_store_network_helper_create_endpoint_node(unid, endpoint);

  attribute_store_node_t attribute_node =
    attribute_store_get_first_child_by_type(endpoint_node,
                                          DOTDOT_ATTRIBUTE_ID_AOX_POSITION_ESTIMATION_POSITION);

  if (attribute_node == ATTRIBUTE_STORE_INVALID_NODE) {
    attribute_node = attribute_store_add_node(DOTDOT_ATTRIBUTE_ID_AOX_POSITION_ESTIMATION_POSITION,
                                              endpoint_node);
  }
    return attribute_store_set_reported(attribute_node,
                                        (uint8_t *)&new_position,
                                        sizeof(EstimatedPosition));
}

