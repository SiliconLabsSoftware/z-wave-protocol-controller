<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />
<meta content="Protocol Controller Developer Guide" name="description" />
<meta content="Protocol, Controller, Developer, Guide" name="keywords" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>How to develop a Protocol Controller &mdash; Z-Wave-Protocol-Controller</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/custom_styles.css" type="text/css" />
    <link rel="canonical" href="https://SiliconLabsSoftware.github.io/z-wave-protocol-controller/doc/how_to_develop_a_protocol_controller.html" />
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/sphinx_highlight.js"></script>
        <script src="../_static/js/charenc.js"></script>
        <script src="../_static/js/crypt.js"></script>
        <script src="../_static/js/sha1.js"></script>
        <script src="../_static/js/html5-qrcode.min.js"></script>
        <script src="../_static/js/qr_code_scanner.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="introduction.html" class="icon icon-home">
            Z-Wave-Protocol-Controller
              <img src="../_static/silicon-labs-logo.png" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                ver_1.7.0-RC0-91-g5f779a0200
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../applications/zpc/readme_user.html">ZPC User’s Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../applications/zpc/readme_certification.html">ZPC - Z-Wave (certification) Information</a></li>
<li class="toctree-l1"><a class="reference internal" href="../applications/zpc/how_to_implement_zwave_command_classes.html">Guideline for implementing Command Classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../applications/zpc/how_to_write_uam_files_for_the_zpc.html">UAM maps for the ZPC</a></li>
<li class="toctree-l1"><a class="reference internal" href="../applications/zpc/how_to_interact_with_clusters.html">How to interact with clusters</a></li>
<li class="toctree-l1"><a class="reference internal" href="../applications/zpc/doc/supported_command_classes.html">Supported Z-Wave Command Classes</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="introduction.html">Z-Wave-Protocol-Controller Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="api.html">API documentation</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="standards/known-abbreviations.html">Known Abbreviations</a></li>
<li class="toctree-l1"><a class="reference internal" href="license.html">License</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="introduction.html">Z-Wave-Protocol-Controller</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <script>
    $(".wy-side-scroll").append("<div class='github-button'><iframe src='https://ghbtns.com/github-btn.html?user=SiliconLabsSoftware&repo=z-wave-protocol-controller&type=watch&count=true&size=large&v=2' allowtransparency='true' frameborder='0' scrolling='0' width='170' height='30'></iframe></div>");
</script>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="how-to-develop-a-protocol-controller">
<span id="how-to-develop-a-protocol-controller-section"></span><h1>How to develop a Protocol Controller<a class="headerlink" href="#how-to-develop-a-protocol-controller" title="Permalink to this heading"></a></h1>
<p>Note: For reference documentation please refer to related chapter of
[UnifySDK documentation](
<a class="reference external" href="https://siliconlabs.github.io/UnifySDK/">https://siliconlabs.github.io/UnifySDK/</a>
)</p>
<section id="networking-addresses-approach">
<h2>Networking addresses approach<a class="headerlink" href="#networking-addresses-approach" title="Permalink to this heading"></a></h2>
<p>The <strong>ZPC</strong> for example uses the networking address strategy, where it stores
Z-Wave addresses under the <strong>Attribute Store</strong> tree root. Application level
attributes are then placed under Endpoints.</p>
<p>Using this methodology, to publish the state of the OnOff attribute when updated,
the <strong>ZPC</strong> navigates up the <strong>Attribute Store</strong>, collects the value of the
Endpoint, NodeID, HomeID and derives the UNID (from the NodeID / HomeID) and
Endpoint. The <strong>ZPC</strong> can subsequently make these 2 publications:</p>
<div class="highlight-mqtt notranslate"><div class="highlight"><pre><span></span><span class="ow">ucl/by-unid/&lt;UNID&gt;/ep&lt;EndpointId&gt;/OnOff/Attributes/OnOff/Desired</span> - {<span class="w"> </span><span class="nt">&quot;value&quot;</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="w"> </span>}
<span class="ow">ucl/by-unid/&lt;UNID&gt;/ep&lt;EndpointId&gt;/OnOff/Attributes/OnOff/Reported</span> - {<span class="w"> </span><span class="nt">&quot;value&quot;</span><span class="p">:</span><span class="w"> </span><span class="kc">false</span><span class="w"> </span>}
</pre></div>
</div>
<p>If a frame is to be sent using the Protocol Controller networking protocol,
the addressing information (Endpoint, NodeID, HomeID) is also easy to collect
navigating up the <strong>Attribute Store</strong>.</p>
<p>This method is advantageous if there is a need to store more information
alongside netorking entities, like granted keys for a node, or shared
network properties under for example the HomeID.</p>
<section id="attribute-resolution">
<h3>Attribute resolution<a class="headerlink" href="#attribute-resolution" title="Permalink to this heading"></a></h3>
<p>When a Protocol Controller has defined its own proprietary atttributes
(both addressing and application-level attributes), it
can start using the <strong>Attribute Resolver</strong> to schedule and send frames.</p>
<p>Let’s assume a Protocol Controller using UNID addressing strategy in the
<strong>Attribute Store</strong>. To enable the <strong>Attribute Resolver</strong>, a few additional
components will be needed:</p>
<ul class="simple">
<li><p>An NCP component, that allows to send and/or receive frames over the networking protocol.</p></li>
<li><p>A frame/message handler, that writes down the state of the node</p></li>
<li><p>A frame/message generator, that generates an hexadecimal payload to send</p></li>
</ul>
<p>The mechanics of the <strong>Attribute Resolver</strong> is shown in the diagram below.</p>
<p>The <strong>Frame/Message Generator</strong> is a set of functions that allow the resolver
to generate a payload (i.e. byte stream). that will sent to the PAN node,
which in turn should Write or Read an attribute.</p>
<p><strong>Frame/Message Generator functions</strong> can return static frames at times,
or frames that depend on the attribute store values.
For example, in ZCL, to find out the reported value of an <em>OnOff</em> attribute should
always be the same payload (ZCL Read Attribute Command with the OnOff attribute ID).
To set the value of an OnOff attribute, the frame generator function would have
to read the value and return either an <em>On Command</em> or an <em>Off Command</em>.</p>
<p>The payload returned by the <strong>Frame/Message Generator</strong> is an application payload.
Other encapsulations layers (e.g. segmentation, encryption, addressing etc.)
are supposed to be added by the <strong>Addressing resolver</strong> and <strong>NCP</strong> components.</p>
<p>The <strong>Addressing resolver</strong> function is to take the paylaod generated by the
<strong>Frame/Message Generator</strong>, and navigate up the attribute store to find out
the full addressing information. For example, in Z-Wave, it would find out
what is the Endpoint, NodeID, Security Keys to use with the destination, before
it sends it forward to the <strong>NCP</strong>.</p>
</section>
<section id="attribute-mapping">
<h3>Attribute Mapping<a class="headerlink" href="#attribute-mapping" title="Permalink to this heading"></a></h3>
<p>Ultimately, the Protocol Controller needs to set the state of attributes
for the DotDot model, so that they can be published using the UCL language.</p>
<p>The <strong>Attribute Mapper</strong> is able to create attribute rules,
which allow to manipulate attributes. It can be configured using <em>.uam</em> files,
which describes relations between attributes.</p>
<p>For example, it is possible to as the <strong>Attribute Mapper</strong> to create an OnOff
attribute and set it to a certain value whenever a corresponding
Protocol Controller Specific attribute is updated.</p>
<p>The <strong>Attribute Mapper</strong> is a very versatile tool allowing to perform attribute
operations. It is used for mapping, but can also be used as information
database in some cases.</p>
<p>A tutorial and examples on how to create <em>.uam</em> files are given in the
<a class="reference internal" href="how_to_write_uam_files.html#how-to-write-uam-files-section"><span class="std std-ref">How to write UAM files</span></a>:</p>
<section id="connecting-the-attribute-store-and-mqtt">
<h4>Connecting the Attribute Store and MQTT<a class="headerlink" href="#connecting-the-attribute-store-and-mqtt" title="Permalink to this heading"></a></h4>
<p>When the attributes are set in the Attribute Store, it is time to advertise
them using MQTT.</p>
<p>There are a few things to set in place to get the Protocol Controller to follow the
<span class="xref std std-doc">Unify Framework Specifications</span>.</p>
</section>
</section>
<section id="listening-to-incoming-mqtt-commands">
<h3>Listening to incoming MQTT commands<a class="headerlink" href="#listening-to-incoming-mqtt-commands" title="Permalink to this heading"></a></h3>
<p>A large set of auto-generated files in the <strong>UIC DotDot MQTT</strong> components
provide a uniform way to subscribe and listen to incoming commands.
The component will take a callback function for each Cluster/Command combination,
and in turn will take care of publishing the list of SupportedCommands.</p>
<div class="highlight-mqtt notranslate"><div class="highlight"><pre><span></span><span class="ow">ucl/by-unid/&lt;UNID&gt;/ep&lt;EndpointId&gt;/Level/SupportedCommands</span> - {<span class="w"> </span><span class="nt">&quot;value&quot;</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">&quot;Move&quot;</span><span class="p">,</span><span class="s2">&quot;MoveToLevel&quot;</span><span class="p">]</span><span class="w"> </span>}
</pre></div>
</div>
<p>When such a publication to a command is received, e.g. :</p>
<div class="highlight-mqtt notranslate"><div class="highlight"><pre><span></span><span class="ow">ucl/by-unid/&lt;UNID&gt;/ep&lt;EndpointId&gt;/Level/Commands/MoveToLevel</span> -
{
<span class="w">  </span><span class="nt">&quot;Level&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">50</span><span class="p">,</span>
<span class="w">  </span><span class="nt">&quot;TransitionTime&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">  </span><span class="nt">&quot;OptionsMask&quot;</span><span class="p">:</span><span class="w"> </span>{
<span class="w">    </span><span class="nt">&quot;ExecuteIfOff&quot;</span><span class="p">:</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span>
<span class="w">    </span><span class="nt">&quot;CoupleColorTempToLevel&quot;</span><span class="p">:</span><span class="w"> </span><span class="kc">false</span>
<span class="w">  </span>}<span class="p">,</span>
<span class="w">  </span><span class="nt">&quot;OptionsOverride&quot;</span><span class="p">:</span><span class="w"> </span>{
<span class="w">    </span><span class="nt">&quot;ExecuteIfOff&quot;</span><span class="p">:</span><span class="w"> </span><span class="kc">false</span><span class="p">,</span>
<span class="w">    </span><span class="nt">&quot;CoupleColorTempToLevel&quot;</span><span class="p">:</span><span class="w"> </span><span class="kc">false</span>
<span class="w">  </span>}
}
</pre></div>
</div>
<p>It would parse the UNID, Endpoint, JSON payload, and dispatch it to to the
registered callback. An illustration of how the component works is shown below.</p>
<p>The Protocol Controller has to provide a component that registers callbacks
for a given DotDot Command. When this command is received, the callback
is expected to locate the UNID/Endpoint in the Attribute Store and perform
the attribute updates that the command effect have on the device.</p>
<p>For example, if the Protocol Controller wants to receive directly the commands
from the OnOff cluster:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;dotdot_mqtt.h&quot;</span>

<span class="kt">bool</span><span class="w"> </span><span class="nf">dotdot_command_dispatch_init</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">  </span><span class="c1">// We listen to OnOff cluster On, Off and Toggle command</span>
<span class="w">  </span><span class="n">uic_mqtt_dotdot_on_off_on_callback_set</span><span class="p">(</span><span class="n">on_on_off_cluster_on_command_received</span><span class="p">);</span>
<span class="w">  </span><span class="n">uic_mqtt_dotdot_on_off_off_callback_set</span><span class="p">(</span><span class="n">on_on_off_cluster_off_command_received</span><span class="p">);</span>
<span class="w">  </span><span class="n">uic_mqtt_dotdot_on_off_toggle_callback_set</span><span class="p">(</span><span class="n">on_on_off_cluster_toggle_command_received</span><span class="p">);</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Unless the Protocol Controller needs to do something specific with a command,
it can let the <strong>Unify DotDot Attribute Store</strong> component process them
automatically.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;unify_dotdot_attribute_store.h&quot;</span>

<span class="c1">// EPC Configuration for the Unify DotDot Attribute Store</span>
<span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">unify_dotdot_attribute_store_configuration_t</span><span class="w"> </span><span class="n">epc_configuration</span>
<span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="p">{.</span><span class="n">get_endpoint_node_function</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">attribute_store_network_helper_get_endpoint_node</span><span class="p">,</span>
<span class="w">     </span><span class="p">.</span><span class="n">get_unid_endpoint_function</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">attribute_store_network_helper_get_unid_endpoint_from_node</span><span class="p">,</span>
<span class="w">     </span><span class="p">.</span><span class="n">get_unid_function</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">attribute_store_network_helper_get_unid_from_node</span><span class="p">,</span>
<span class="w">     </span><span class="p">.</span><span class="n">update_attribute_desired_values_on_commands</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">,</span>
<span class="w">     </span><span class="p">.</span><span class="n">clear_reported_on_desired_updates</span><span class="w">           </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">,</span>
<span class="w">     </span><span class="p">.</span><span class="n">automatic_deduction_of_supported_commands</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">,</span>
<span class="w">     </span><span class="p">.</span><span class="n">force_read_attributes_enabled</span><span class="w">               </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">,</span>
<span class="w">     </span><span class="p">.</span><span class="n">write_attributes_enabled</span><span class="w">                    </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">,</span>
<span class="w">     </span><span class="p">.</span><span class="n">publish_attribute_values_to_mqtt</span><span class="w">            </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="w"> </span><span class="p">};</span>

<span class="n">sl_status_t</span><span class="w"> </span><span class="nf">epc_dotdot_attribute_store_init</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>

<span class="w">  </span><span class="c1">// Provide Unify DotDot Attribute Store with a function that locates Endpoint Attributes.</span>
<span class="w">  </span><span class="n">unify_dotdot_attribute_store_set_endpoint_node_function</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epc_attribute_store_get_endpoint_node</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// Configure Unify DotDot Attribute Store to do the work for us.</span>
<span class="w">  </span><span class="n">unify_dotdot_attribute_store_set_configuration</span><span class="p">(</span><span class="o">&amp;</span><span class="n">epc_configuration</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// Init Unify DotDot Attribute Store</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">unify_dotdot_attribute_store_init</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>If not using the <strong>Unify DotDot Attribute Store</strong> component, the Protocol
Controller is expected to find out the corresponding attributes in the
Attribute Store based on the UNID/Endpoint combination, and
update the value of the DotDot Attribute.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">sl_status_t</span>
<span class="w">  </span><span class="nf">on_on_off_cluster_on_command_received</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">dotdot_unid_t</span><span class="w"> </span><span class="n">unid</span><span class="p">,</span>
<span class="w">                                        </span><span class="k">const</span><span class="w"> </span><span class="n">dotdot_endpoint_id_t</span><span class="w"> </span><span class="n">endpoint</span><span class="p">,</span>
<span class="w">                                        </span><span class="n">uic_mqtt_dotdot_callback_call_type_t</span><span class="w"> </span><span class="n">callback_type</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="c1">// Take the UNID/Endpoint and locate the node in the attribute store.</span>
<span class="w">  </span><span class="n">attribute_store_node_t</span><span class="w"> </span><span class="n">endpoint_node</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_endpoint_node_from_unid_endpoint</span><span class="p">(</span><span class="n">unid</span><span class="p">,</span><span class="w"> </span><span class="n">endpoint</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// On Command will affect the OnOff attribute and set it to true</span>
<span class="w">  </span><span class="n">attribute_store_node_t</span><span class="w"> </span><span class="n">on_off_attribute_node</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="n">attribute_store_get_first_child_by_type</span><span class="p">(</span><span class="n">endpoint_node</span><span class="p">,</span>
<span class="w">                                            </span><span class="n">DOTDOT_ATTRIBUTE_ID_ON_OFF_ON_OFF</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// This is used by DotDot MQTT to publish SupportedCommands</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">callback_type</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">on_off_attribute_node</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">ATTRIBUTE_STORE_INVALID_NODE</span><span class="p">)</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="n">SL_STATUS_OK</span>
<span class="w">                                                                  </span><span class="o">:</span><span class="w"> </span><span class="n">SL_STATUS_FAIL</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// Else set the value to true.</span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">new_value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">attribute_store_set_desired</span><span class="p">(</span><span class="n">on_off_attribute_node</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">new_value</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">new_value</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
<p>At this point, if an IoT Service publishes a command such as</p>
<div class="highlight-mqtt notranslate"><div class="highlight"><pre><span></span><span class="ow">ucl/by-unid/&lt;UNID&gt;/ep&lt;EndpointId&gt;/OnOff/Commands/On</span> - {}
</pre></div>
</div>
<p>The command will be received, passed forward to the right command handler, and
the corresponding OnOff attribute in the <strong>Attribute Store</strong> will be updated to match
the wish of the IoT Service. Note that there is no official list of affected
Attributes for a received command. It is <strong>strongly</strong> recommended to use the
<strong>Unify DotDot Attribute Store</strong> component to provide a uniform behavior accross
protocol controllers</p>
<p>Using the <strong>Attribute Mapper</strong>, the update of the desired value OnOff attribute
should trigger an update of the desired value of the corresponding mapped
proprietary attribute.</p>
<p>Subsequently, the <strong>Attribute Resolver</strong>, will be notified that an update occured
and should determine if a frame is to be sent to the PAN node.</p>
<p>Finally, if the node reports that the corresponding proprietary attribute
reported value is updated back, an attribute map should ensure that the reported
value of the DotDot OnOff attribute gets in turn updated.</p>
</section>
<section id="publishing-the-dotdot-attribute-state-of-nodes">
<h3>Publishing the DotDot Attribute state of nodes<a class="headerlink" href="#publishing-the-dotdot-attribute-state-of-nodes" title="Permalink to this heading"></a></h3>
<p>Using the <strong>Attribute Store</strong> and the <strong>UIC DotDot MQTT</strong> components, a Protocol
Controller can easily publish the state of the DotDot attributes.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">sl_status_t</span><span class="w"> </span><span class="nf">dotdot_attribute_publisher_init</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">  </span><span class="c1">// For Each Cluster/Attribute that needs to be published</span>
<span class="w">  </span><span class="n">attribute_store_register_callback_by_type_and_state</span><span class="p">(</span>
<span class="w">    </span><span class="n">on_off_cluster_on_attribute_desired_state_publisher_callback</span><span class="p">,</span>
<span class="w">      </span><span class="n">DOTDOT_ATTRIBUTE_ID_ON_OFF_ON_OFF</span><span class="p">,</span>
<span class="w">      </span><span class="n">DESIRED_ATTRIBUTE</span><span class="p">);</span>
<span class="w">  </span><span class="n">attribute_store_register_callback_by_type_and_state</span><span class="p">(</span>
<span class="w">    </span><span class="n">on_off_cluster_on_attribute_reported_state_publisher_callback</span><span class="p">,</span>
<span class="w">      </span><span class="n">DOTDOT_ATTRIBUTE_ID_ON_OFF_ON_OFF</span><span class="p">,</span>
<span class="w">      </span><span class="n">REPORTED_ATTRIBUTE</span><span class="p">);</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">SL_STATUS_OK</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>With these callbacks set, the <strong>Attribute Store</strong> will invoke these function
when the values get updated. Subsequently, the functions can use <strong>UIC DotDot MQTT</strong>
to publish the updated state.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">on_off_cluster_on_attribute_desired_state_publisher_callback</span><span class="p">(</span>
<span class="w">  </span><span class="n">attribute_store_node_t</span><span class="w"> </span><span class="n">updated_node</span><span class="p">,</span><span class="w"> </span><span class="n">attribute_store_change_t</span><span class="w"> </span><span class="n">change</span><span class="p">)</span>

<span class="w">  </span><span class="c1">// Ignore creation and deletion events</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">change</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">ATTRIBUTE_DELETED</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">change</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">ATTRIBUTE_CREATED</span><span class="p">){</span>
<span class="w">    </span><span class="k">return</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// Take the attribute store node and determine the UNID/Endpoint from the attribute store.</span>
<span class="w">  </span><span class="n">dotdot_unid_t</span><span class="w"> </span><span class="n">unid</span><span class="p">;</span>
<span class="w">  </span><span class="n">dotdot_endpoint_id_t</span><span class="w"> </span><span class="n">endpoint_id</span><span class="p">;</span>
<span class="w">  </span><span class="n">get_unid_endpoint_from_attribute_store_node</span><span class="p">(</span><span class="n">updated_node</span><span class="p">,</span><span class="w"> </span><span class="n">unid</span><span class="p">,</span><span class="w"> </span><span class="n">endpoint</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// Prepare the basic topic</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">stringstream</span><span class="w"> </span><span class="n">base_topic</span><span class="p">;</span>
<span class="w">  </span><span class="n">base_topic</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;ucl/by-unid/&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="n">unid</span><span class="p">);</span>
<span class="w">  </span><span class="n">base_topic</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;/ep&quot;</span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="n">endpoint_id</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// Get the value of the attribute</span>
<span class="w">  </span><span class="kt">bool</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">  </span><span class="n">attribute_store_get_desired</span><span class="p">(</span><span class="n">updated_node</span><span class="p">,</span><span class="o">&amp;</span><span class="n">value</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">value</span><span class="p">));</span>

<span class="w">  </span><span class="c1">// Call the corresponding DotDot MQTT helper to make the publication</span>
<span class="w">  </span><span class="n">uic_mqtt_dotdot_on_off_on_off_publish</span><span class="p">(</span>
<span class="w">    </span><span class="n">base_topic</span><span class="p">.</span><span class="n">str</span><span class="p">().</span><span class="n">c_str</span><span class="p">(),</span>
<span class="w">    </span><span class="n">value</span><span class="p">,</span>
<span class="w">    </span><span class="n">UCL_MQTT_PUBLISH_TYPE_DESIRED</span><span class="p">);</span>
</pre></div>
</div>
<section id="ucl-node-state">
<h4>UCL node state<a class="headerlink" href="#ucl-node-state" title="Permalink to this heading"></a></h4>
</section>
</section>
<section id="ucl-node-state-overview">
<h3>UCL node state overview<a class="headerlink" href="#ucl-node-state-overview" title="Permalink to this heading"></a></h3>
<p>When the Protocol Controller is setup to publish attributes, process incoming
commands, map in between attribute spaces, resolve and/or send frames when
needed, there is one final step to set up: The UCL node state.</p>
<p>The node state topic is a special topic, which does not fully follow
the standard cluster attributes publications.
Refer to the <span class="xref std std-doc">Unify Framework Specifications</span>
for details.</p>
<p>Protocol Controllers must publish the node state for each node they can
access, so that IoT services can build up a list of entities.
If possible, the state should be published after publishing the list of
attributes/cluster functionalities, so that IoT Services have a full picture
of the node’s capabilities when it is announced to be <em>“Online Functional”</em>.</p>
<p>The Protocol Controller UCL node state component should listen
to its proprietary attributes and/or components to determine
when nodes are ready to be operated by IoT Services.</p>
<p>Additionally, the node state has to be republished every time one of the properties
change:</p>
<ul class="simple">
<li><p>NetworkStatus</p></li>
<li><p>Security</p></li>
<li><p>MaximumCommandDelay</p></li>
</ul>
<p>At the end, the component must be able to publish for all reachable nodes the
following topic:</p>
<div class="highlight-mqtt notranslate"><div class="highlight"><pre><span></span><span class="ow">ucl/by-unid/&lt;UNID&gt;/State</span> -
{
<span class="w">  </span><span class="nt">&quot;NetworkStatus&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;Online functional&quot;</span><span class="p">,</span>
<span class="w">  </span><span class="nt">&quot;Security&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;Z-Wave S2 Authenticated&quot;</span><span class="p">,</span>
<span class="w">  </span><span class="nt">&quot;MaximumCommandDelay&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span>
}
</pre></div>
</div>
<p>Some attributes may be located directly under the UNID for the network
status, but Endpoint 0 is also a good place to store such data.</p>
<p>A couple of helpers are available in the <strong>UIC DotDot MQTT</strong> component
to publish State related information, such as the state SupportedCommands.</p>
</section>
<section id="start-up-and-shutdown">
<h3>Start-up and shutdown<a class="headerlink" href="#start-up-and-shutdown" title="Permalink to this heading"></a></h3>
<p>A Protocol Controller is expected to unretain (almost) all topics that it
published during runtime when it is being shutdown. The node state topic
will be the only one that will stay after the Protocol Controller is shut down.</p>
<p>For example, the <strong>ZPC</strong> on shutdown iterates through its entire list of PAN nodes
and publish that they will be unavailable, right before removing all other
topics that have published for the PAN nodes.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">ucl_node_state_teardown</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">  </span><span class="c1">// get node list and publish the node state unavailable</span>
<span class="w">  </span><span class="n">attribute_store_node_t</span><span class="w"> </span><span class="n">home_id_node</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_zpc_network_node</span><span class="p">();</span>
<span class="w">  </span><span class="n">attribute_store_node_t</span><span class="w"> </span><span class="n">node_id_node</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ATTRIBUTE_STORE_INVALID_NODE</span><span class="p">;</span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">num_child</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">attribute_store_get_node_child_count</span><span class="p">(</span><span class="n">home_id_node</span><span class="p">);</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">num_child</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">node_id_node</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">attribute_store_get_node_child_by_type</span><span class="p">(</span><span class="n">home_id_node</span><span class="p">,</span>
<span class="w">                                                          </span><span class="n">ATTRIBUTE_NODE_ID</span><span class="p">,</span>
<span class="w">                                                          </span><span class="n">i</span><span class="p">);</span>
<span class="w">    </span><span class="n">publish_node_state</span><span class="p">(</span><span class="n">node_id_node</span><span class="p">,</span><span class="w"> </span><span class="nb">false</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">//Remove all retained topics except ucl/by-unid/&lt;xxxxx&gt;/State</span>
<span class="w">  </span><span class="n">uic_mqtt_unretain_by_regex</span><span class="p">(</span><span class="s">&quot;^(?!ucl</span><span class="se">\\</span><span class="s">/by-unid</span><span class="se">\\</span><span class="s">/.*</span><span class="se">\\</span><span class="s">/State$).*&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This will have the effect of publishing an unavailable state for all nodes:</p>
<div class="highlight-mqtt notranslate"><div class="highlight"><pre><span></span><span class="ow">ucl/by-unid/zw-D4BFAE7D-0001/State</span> - {<span class="nt">&quot;NetworkStatus&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;Unavailable&quot;</span><span class="p">,</span><span class="w"> </span><span class="nt">&quot;Security&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;Z-Wave S2 Access Control&quot;</span><span class="p">,</span><span class="w"> </span><span class="nt">&quot;MaximumCommandDelay&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">0</span>}
<span class="ow">ucl/by-unid/zw-D4BFAE7D-000C/State</span> - {<span class="nt">&quot;NetworkStatus&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;Unavailable&quot;</span><span class="p">,</span><span class="w"> </span><span class="nt">&quot;Security&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;None&quot;</span><span class="p">,</span><span class="w"> </span><span class="nt">&quot;MaximumCommandDelay&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">4200</span>}
<span class="ow">ucl/by-unid/zw-D4BFAE7D-000D/State</span> - {<span class="nt">&quot;NetworkStatus&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;Unavailable&quot;</span><span class="p">,</span><span class="w"> </span><span class="nt">&quot;Security&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;Z-Wave S2 Authenticated&quot;</span><span class="p">,</span><span class="w"> </span><span class="nt">&quot;MaximumCommandDelay&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span>}
</pre></div>
</div>
<p>Whenever the Protocol Controller starts again, it needs to iterate over the
list of nodes and publish their state, as well as the Dotdot attributes and commands.</p>
<p>An initialization function can use the <strong>Attribute Store</strong>
<em>attribute_store_refresh_node_and_children_callbacks</em> function, that will simulate
that all attributes just got updated in the Attribute Store and will trigger a
publication.</p>
<section id="general-recommendations">
<h4>General recommendations<a class="headerlink" href="#general-recommendations" title="Permalink to this heading"></a></h4>
</section>
</section>
<section id="mqtt-publications-vs-attribute-store-resolution-and-mapping">
<h3>MQTT publications vs Attribute Store resolution and mapping<a class="headerlink" href="#mqtt-publications-vs-attribute-store-resolution-and-mapping" title="Permalink to this heading"></a></h3>
<p>Whenever a component wants to publish the state of an attribute, it can
(and in certain cases should) verify if the <strong>Attribute Mapper</strong> and/or
<strong>Attribute Resolver</strong> are still working on the <strong>Attribute Store</strong> tree.</p>
<p>The <strong>Attribute Resolver</strong> can give notifications when a node and all
its children have been resolved. This can be used to move the UCL node
state from “Online interviewing” to “Online functional”.</p>
<p>The <strong>Attribute Mapper</strong> can indicate if it still is modifying the
<strong>Attribute Store</strong> due to pending evaluations.</p>
<p>Re-invoking the same function can be done with the <strong>Attribute Timeouts</strong>
component. Here is an example.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">on_zcl_attribute_update</span><span class="p">(</span><span class="n">attribute_store_node_t</span><span class="w"> </span><span class="n">updated_node</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="c1">// If the Mapper is still working, wait with the publication:</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">attribute_mapper_has_pending_evaluations</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Wait that the mapper has reached a final state.</span>
<span class="w">    </span><span class="c1">// Try again in 200 ms</span>
<span class="w">    </span><span class="n">sl_log_debug</span><span class="p">(</span><span class="n">LOG_TAG</span><span class="p">,</span>
<span class="w">                </span><span class="s">&quot;Mapper is still working. &quot;</span>
<span class="w">                </span><span class="s">&quot;Postponing DotDot attribute publications by 200ms.&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">attribute_timeout_set_callback</span><span class="p">(</span><span class="n">updated_node</span><span class="p">,</span>
<span class="w">                                  </span><span class="mi">200</span><span class="p">,</span>
<span class="w">                                  </span><span class="o">&amp;</span><span class="n">on_zcl_attribute_update</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// Else publish the ZCL attribute</span>
<span class="w">  </span><span class="c1">// [...]</span>
</pre></div>
</div>
<section id="network-management">
<h4>Network Management<a class="headerlink" href="#network-management" title="Permalink to this heading"></a></h4>
<p>Network management is an optional feature of Protocol Controllers, and should
be implemented only if their networking protocol allows them to
perform such operations.</p>
</section>
</section>
<section id="manual-network-management-operations">
<h3>Manual Network Management operations<a class="headerlink" href="#manual-network-management-operations" title="Permalink to this heading"></a></h3>
<p>If a Protocol Controller is able to join/leave a network or add/remove nodes
to a network, they are expected to implement the
<code class="docutils literal notranslate"><span class="pre">ucl/by-unid/&lt;UNID&gt;/ProtocolController/NetworkManagement</span></code> topic.</p>
<p>Protocol Controllers ables to perform network management functionalities
should implement a component publishing and subscribing to NetworkManagement
commands.</p>
<p>There is no shared component helping for this function at the moment.</p>
</section>
<section id="using-smartstart-for-network-inclusions">
<h3>Using SmartStart for network inclusions<a class="headerlink" href="#using-smartstart-for-network-inclusions" title="Permalink to this heading"></a></h3>
<p>A dedicated Unify component named <strong>UIC SmartStart Management</strong> is available
for Protocol Controller that would like to use SmartStart. It will enable
them to receive the SmartStart information automatically.</p>
<section id="additional-shared-components">
<h4>Additional shared components<a class="headerlink" href="#additional-shared-components" title="Permalink to this heading"></a></h4>
<p>In general, it is recommended to use components that are provided as part of the
<a class="reference internal" href="unify_library_overview.html"><span class="doc">Unify Library</span></a>. Not all of these shared components
are designed for Protocol Controllers in particular, but most will provide
some useful functionalities.</p>
<p>For example, the <strong>UIC OTA</strong> provides a simple interface to advertise, receive
and apply firmware updates to end nodes. <strong>Unify Attribute poll</strong> will manage
a list of attributes types that must be read periodically.</p>
</section>
</section>
</section>
</section>


           </div>
          </div>
          <footer>
    <hr/>
    <p>Copyright © 2025 Silicon Laboratories. All rights reserved.</p>
</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>