/******************************************************************************
 * # License
 * <b>Copyright 2021 Silicon Laboratories Inc. www.silabs.com</b>
 ******************************************************************************
 * The licensor of this software is Silicon Laboratories Inc. Your use of this
 * software is governed by the terms of Silicon Labs Master Software License
 * Agreement (MSLA) available at
 * www.silabs.com/about-us/legal/master-software-license-agreement. This
 * software is distributed to you in Source Code format and is governed by the
 * sections of the MSLA applicable to Source Code.
 *
 *****************************************************************************/

// This file is generated by ZCL Advanced Platform generator. Please don't edit manually.

// Includes from this component
#include "aox_locator_configuration.h"
#include "aox_locator_configuration_internal.h"

// Generic includes
#include <stdlib.h>
#include <string.h>

// Unify components
#include "sl_log.h"
#include "dotdot_mqtt.h"
#include "attribute_store.h"

// AoXPC components
#include "aoxpc_unid.h"
#include "aoxpc_attribute_store_defined_attribute_types.h"

#define LOG_TAG "aox_locator_configuration"
#define BASE_TOPIC_FORMAT "ucl/by-unid/%s/ep%d"
#define MAXIMUM_BASE_TOPIC_SIZE 200

// Private variables
static aox_locator_attributes_t attribute_configuration = {};

/**
 * @brief frees up the memory allocated previous for the AoXLocator AzimuthMask Attribute
 *
 */
static void aox_locator_clear_allocated_azimuth_mask(){
  if (attribute_configuration.azimuth_mask_count == 0) {
    return;
  }
  free(attribute_configuration.azimuth_mask);
  attribute_configuration.azimuth_mask_count = 0;
  attribute_configuration.azimuth_mask = NULL;
}
/**
 * @brief frees up the memory allocated previous for the AoXLocator ElevationMask Attribute
 *
 */
static void aox_locator_clear_allocated_elevation_mask(){
  if (attribute_configuration.elevation_mask_count == 0) {
    return;
  }
  free(attribute_configuration.elevation_mask);
  attribute_configuration.elevation_mask_count = 0;
  attribute_configuration.elevation_mask = NULL;
}
/**
 * @brief frees up the memory allocated previous for the AoXLocator AllowList Attribute
 *
 */
static void aox_locator_clear_allocated_allow_list(){
  if (attribute_configuration.allow_list_count == 0) {
    return;
  }
  for (size_t i = 0; i < attribute_configuration.allow_list_count; i++){
    free(attribute_configuration.allow_list[i]);
  }
  free(attribute_configuration.allow_list);
  attribute_configuration.allow_list_count = 0;
  attribute_configuration.allow_list = NULL;
}

sl_status_t aox_locator_write_attributes_callback(
  const dotdot_unid_t unid,
  const dotdot_endpoint_id_t endpoint,
  uic_mqtt_dotdot_callback_call_type_t call_type,
  uic_mqtt_dotdot_aox_locator_state_t state,
  uic_mqtt_dotdot_aox_locator_updated_state_t updated_state)
{
  // If dotdot MQTT asks if this command is supported, we say yes.
  if (call_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
    return SL_STATUS_OK;
  }

  // Addressing validation (UNID/EP)
  if (false == is_aoxpc_unid(unid)) {
    sl_log_debug(LOG_TAG,
                 "Received WriteAttributes not addressed to our "
                 "UNID (%s). Ignoring.",
                 unid);
    return SL_STATUS_FAIL;
  } else if (endpoint != AOXPC_ENDPOINT_ID) {
    sl_log_debug(LOG_TAG,
                 "Received WriteAttributes command for non-supported"
                 "Endpoint ID (%d). Ignoring.",
                 endpoint);
    return SL_STATUS_FAIL;
  }

  // Accept the new configuration
  bool configuration_updated = false;

  if (updated_state.reporting_mode == true) {
  sl_log_debug(LOG_TAG, "Received a WriteAttribute command for a non-supported "
                        "attribute: aox_locator::ReportingMode. Ignoring.");
  }
  if (updated_state.position_and_orientation_valid == true) {
    // Update our configuration
    configuration_updated = true;
    sl_log_debug(LOG_TAG,"Updating aox_locator::position_and_orientation_valid");
  attribute_configuration.position_and_orientation_valid = state.position_and_orientation_valid;
  }
  if (updated_state.position_and_orientation == true) {
    // Update our configuration
    configuration_updated = true;
    sl_log_debug(LOG_TAG,"Updating aox_locator::position_and_orientation");
  attribute_configuration.position_and_orientation = state.position_and_orientation;
  }
  if (updated_state.azimuth_mask == true) {
    // Update our configuration
    configuration_updated = true;
    sl_log_debug(LOG_TAG,"Updating aox_locator::azimuth_mask");
    aox_locator_clear_allocated_azimuth_mask();
    if (state.azimuth_mask_count != 0) {
      attribute_configuration.azimuth_mask = malloc(sizeof(MinMaxPair) * state.azimuth_mask_count);
      for (size_t i = 0; i < state.azimuth_mask_count; i++) {
        attribute_configuration.azimuth_mask[i] = state.azimuth_mask[i];
      }
    }
      attribute_configuration.azimuth_mask_count = state.azimuth_mask_count;
  }
  if (updated_state.elevation_mask == true) {
    // Update our configuration
    configuration_updated = true;
    sl_log_debug(LOG_TAG,"Updating aox_locator::elevation_mask");
    aox_locator_clear_allocated_elevation_mask();
    if (state.elevation_mask_count != 0) {
      attribute_configuration.elevation_mask = malloc(sizeof(MinMaxPair) * state.elevation_mask_count);
      for (size_t i = 0; i < state.elevation_mask_count; i++) {
        attribute_configuration.elevation_mask[i] = state.elevation_mask[i];
      }
    }
      attribute_configuration.elevation_mask_count = state.elevation_mask_count;
  }
  if (updated_state.allow_list == true) {
    // Update our configuration
    configuration_updated = true;
    sl_log_debug(LOG_TAG,"Updating aox_locator::allow_list");
    aox_locator_clear_allocated_allow_list();
    if (state.allow_list_count != 0) {
      attribute_configuration.allow_list = malloc(sizeof(const char*) * state.allow_list_count);
      for (size_t i = 0; i < state.allow_list_count; i++) {
        // String copy
        size_t string_size = strlen(state.allow_list[i])+1;
        attribute_configuration.allow_list[i]= NULL;
        attribute_configuration.allow_list[i] = malloc(string_size);
        strncpy(attribute_configuration.allow_list[i], state.allow_list[i], string_size);
        attribute_configuration.allow_list[i][string_size-1] = '\0';
      }
    }
      attribute_configuration.allow_list_count = state.allow_list_count;
  }
  if (updated_state.aox_mode == true) {
  sl_log_debug(LOG_TAG, "Received a WriteAttribute command for a non-supported "
                        "attribute: aox_locator::AoXMode. Ignoring.");
  }
  if (updated_state.antenna_mode == true) {
  sl_log_debug(LOG_TAG, "Received a WriteAttribute command for a non-supported "
                        "attribute: aox_locator::AntennaMode. Ignoring.");
  }
  if (updated_state.antenna_array == true) {
  sl_log_debug(LOG_TAG, "Received a WriteAttribute command for a non-supported "
                        "attribute: aox_locator::AntennaArray. Ignoring.");
  }
  if (updated_state.period_samples == true) {
  sl_log_debug(LOG_TAG, "Received a WriteAttribute command for a non-supported "
                        "attribute: aox_locator::PeriodSamples. Ignoring.");
  }
  if (updated_state.angle_filtering == true) {
  sl_log_debug(LOG_TAG, "Received a WriteAttribute command for a non-supported "
                        "attribute: aox_locator::AngleFiltering. Ignoring.");
  }
  if (updated_state.angle_filtering_weight == true) {
  sl_log_debug(LOG_TAG, "Received a WriteAttribute command for a non-supported "
                        "attribute: aox_locator::AngleFilteringWeight. Ignoring.");
  }
  if (updated_state.angle_correction_timeout == true) {
  sl_log_debug(LOG_TAG, "Received a WriteAttribute command for a non-supported "
                        "attribute: aox_locator::AngleCorrectionTimeout. Ignoring.");
  }
  if (updated_state.angle_correction_delay == true) {
  sl_log_debug(LOG_TAG, "Received a WriteAttribute command for a non-supported "
                        "attribute: aox_locator::AngleCorrectionDelay. Ignoring.");
  }
  if (updated_state.cte_mode == true) {
    // Update our configuration
    configuration_updated = true;
    sl_log_debug(LOG_TAG,"Updating aox_locator::cte_mode");
  attribute_configuration.cte_mode = state.cte_mode;
  }
  if (updated_state.cte_sampling_interval == true) {
  sl_log_debug(LOG_TAG, "Received a WriteAttribute command for a non-supported "
                        "attribute: aox_locator::CTESamplingInterval. Ignoring.");
  }
  if (updated_state.cte_length == true) {
  sl_log_debug(LOG_TAG, "Received a WriteAttribute command for a non-supported "
                        "attribute: aox_locator::CTELength. Ignoring.");
  }
  if (updated_state.slot_duration == true) {
  sl_log_debug(LOG_TAG, "Received a WriteAttribute command for a non-supported "
                        "attribute: aox_locator::SlotDuration. Ignoring.");
  }

  // Callback listeners, then push an MQTT update
  if (configuration_updated == true){
    aox_locator_notify_configuration_was_updated();
    publish_aox_locator_attributes_to_mqtt();
  }

  return SL_STATUS_OK;
}

sl_status_t publish_aox_locator_attributes_to_mqtt()
{
  char base_topic[MAXIMUM_BASE_TOPIC_SIZE];
  aoa_id_t unid = "";
  if (SL_STATUS_OK != get_aoxpc_unid(unid)) {
    sl_log_debug(LOG_TAG,
              "AoXPC UNID not known. Skipping MQTT publication of "
              "AoXLocator cluster attributes.");
    return SL_STATUS_FAIL;
  }
  snprintf(base_topic, sizeof(base_topic), BASE_TOPIC_FORMAT, unid, AOXPC_ENDPOINT_ID);

  sl_status_t publish_status = SL_STATUS_OK;


      publish_status |=
        uic_mqtt_dotdot_aox_locator_position_and_orientation_valid_publish(
          base_topic,
          attribute_configuration.position_and_orientation_valid,
          UCL_MQTT_PUBLISH_TYPE_ALL
      );
      publish_status |=
        uic_mqtt_dotdot_aox_locator_position_and_orientation_publish(
          base_topic,
          attribute_configuration.position_and_orientation,
          UCL_MQTT_PUBLISH_TYPE_ALL
      );
    publish_status |=
      uic_mqtt_dotdot_aox_locator_azimuth_mask_publish(
        base_topic,
        attribute_configuration.azimuth_mask_count,
        attribute_configuration.azimuth_mask,
        UCL_MQTT_PUBLISH_TYPE_ALL
      );
    publish_status |=
      uic_mqtt_dotdot_aox_locator_elevation_mask_publish(
        base_topic,
        attribute_configuration.elevation_mask_count,
        attribute_configuration.elevation_mask,
        UCL_MQTT_PUBLISH_TYPE_ALL
      );
    publish_status |=
      uic_mqtt_dotdot_aox_locator_allow_list_publish(
        base_topic,
        attribute_configuration.allow_list_count,
        (const char**)attribute_configuration.allow_list,
        UCL_MQTT_PUBLISH_TYPE_ALL
      );
      publish_status |=
        uic_mqtt_dotdot_aox_locator_cte_mode_publish(
          base_topic,
          attribute_configuration.cte_mode,
          UCL_MQTT_PUBLISH_TYPE_ALL
      );
  // Don't forget the special ClusterRevision attribute.
  uic_mqtt_dotdot_aox_locator_publish_cluster_revision(base_topic, 1);



  return publish_status;
}


// Load from attribute store
sl_status_t aox_locator_load_attributes_from_attribute_store(void) {
  aoa_id_t aoxpc_unid = {};
  if (SL_STATUS_OK != get_aoxpc_unid(aoxpc_unid)) {
    sl_log_error(LOG_TAG,
                 "Could not retrieve AoXPC UNID. "
                 "The AoXLocator configuration will not be loaded from the Attribute Store.");
    return SL_STATUS_FAIL;
  }
  if (true == dotdot_is_supported_aox_locator_position_and_orientation_valid(aoxpc_unid, AOXPC_ENDPOINT_ID)) {
    // It exists in the attribute store, load its value
 // Not a MonotonousArray
      bool value;
    sl_status_t load_status =
      dotdot_get_aox_locator_position_and_orientation_valid(aoxpc_unid,
                                                    AOXPC_ENDPOINT_ID,
                                                    &value);
    // Set it in the config:
    if (load_status == SL_STATUS_OK) {
      aox_locator_set_position_and_orientation_valid_attribute(value);
    }
  }
  if (true == dotdot_is_supported_aox_locator_position_and_orientation(aoxpc_unid, AOXPC_ENDPOINT_ID)) {
    // It exists in the attribute store, load its value
 // Not a MonotonousArray
      CoordinateAndOrientation value;
    sl_status_t load_status =
      dotdot_get_aox_locator_position_and_orientation(aoxpc_unid,
                                                    AOXPC_ENDPOINT_ID,
                                                    &value);
    // Set it in the config:
    if (load_status == SL_STATUS_OK) {
      aox_locator_set_position_and_orientation_attribute(value);
    }
  }
  if (true == dotdot_is_supported_aox_locator_azimuth_mask(aoxpc_unid, AOXPC_ENDPOINT_ID)) {
    // It exists in the attribute store, load its value
    // MonotonousArray
    sl_status_t load_status = SL_STATUS_OK;
    MinMaxPair* array = NULL;
    size_t array_size = dotdot_get_aox_locator_azimuth_mask_count(aoxpc_unid, AOXPC_ENDPOINT_ID);
    if (array_size > 0) {
      array = malloc(array_size * sizeof(MinMaxPair));
    }
    for (size_t i = 0 ; i < array_size ; i++) {
      load_status |= dotdot_get_aox_locator_azimuth_mask(aoxpc_unid,
                                                                  AOXPC_ENDPOINT_ID,
                                                                  &array[i],
                                                                  i);
    }
    // Set it in the config:
    if (load_status == SL_STATUS_OK) {
      aox_locator_set_azimuth_mask_attribute(
        array_size,
        array);
    }
    //Free the malloc'ed memory
    if (array_size > 0) {
      free(array);
    }

      }
  if (true == dotdot_is_supported_aox_locator_elevation_mask(aoxpc_unid, AOXPC_ENDPOINT_ID)) {
    // It exists in the attribute store, load its value
    // MonotonousArray
    sl_status_t load_status = SL_STATUS_OK;
    MinMaxPair* array = NULL;
    size_t array_size = dotdot_get_aox_locator_elevation_mask_count(aoxpc_unid, AOXPC_ENDPOINT_ID);
    if (array_size > 0) {
      array = malloc(array_size * sizeof(MinMaxPair));
    }
    for (size_t i = 0 ; i < array_size ; i++) {
      load_status |= dotdot_get_aox_locator_elevation_mask(aoxpc_unid,
                                                                  AOXPC_ENDPOINT_ID,
                                                                  &array[i],
                                                                  i);
    }
    // Set it in the config:
    if (load_status == SL_STATUS_OK) {
      aox_locator_set_elevation_mask_attribute(
        array_size,
        array);
    }
    //Free the malloc'ed memory
    if (array_size > 0) {
      free(array);
    }

      }
  if (true == dotdot_is_supported_aox_locator_allow_list(aoxpc_unid, AOXPC_ENDPOINT_ID)) {
    // It exists in the attribute store, load its value
    // MonotonousArray
    sl_status_t load_status = SL_STATUS_OK;
    char **array = NULL;
    size_t array_size = dotdot_get_aox_locator_allow_list_count(aoxpc_unid, AOXPC_ENDPOINT_ID);
    if (array_size > 0) {
      array = malloc(array_size * sizeof(char *));
    }
    for (size_t i = 0 ; i < array_size ; i++) {
      array[i] = malloc(sizeof(char)*ATTRIBUTE_STORE_MAXIMUM_VALUE_LENGTH);
      load_status |= dotdot_get_aox_locator_allow_list(aoxpc_unid,
                                                                  AOXPC_ENDPOINT_ID,
                                                                  array[i],
                                                                  i);
    }
    // Set it in the config:
    if (load_status == SL_STATUS_OK) {
      aox_locator_set_allow_list_attribute(
        array_size,
        (const char**)array);
    }
    //Free the malloc'ed memory
    for (size_t i = 0 ; i < array_size ; i++) {
      free(array[i]);
    }
    if (array_size > 0) {
      free(array);
    }

      }
  if (true == dotdot_is_supported_aox_locator_cte_mode(aoxpc_unid, AOXPC_ENDPOINT_ID)) {
    // It exists in the attribute store, load its value
 // Not a MonotonousArray
      uint8_t value;
    sl_status_t load_status =
      dotdot_get_aox_locator_cte_mode(aoxpc_unid,
                                                    AOXPC_ENDPOINT_ID,
                                                    &value);
    // Set it in the config:
    if (load_status == SL_STATUS_OK) {
      aox_locator_set_cte_mode_attribute(value);
    }
  }
  sl_log_debug(LOG_TAG,
              "Loaded AoXLocator configuration from the Attribute Store successfully.");
  return SL_STATUS_OK;
}

// Store in attribute store
sl_status_t aox_locator_store_attributes_in_attribute_store(void) {
  aoa_id_t aoxpc_unid = {};
  if (SL_STATUS_OK != get_aoxpc_unid(aoxpc_unid)) {
    sl_log_error(LOG_TAG,
                 "Could not retrieve AoXPC UNID. "
                 "The AoXLocator configuration will not be stored in the Attribute Store.");
    return SL_STATUS_FAIL;
  }
    // Save PositionAndOrientationValid in the Attribute Store
    dotdot_set_aox_locator_position_and_orientation_valid(
      aoxpc_unid,
      AOXPC_ENDPOINT_ID,
      
      attribute_configuration.position_and_orientation_valid);
    // Save PositionAndOrientation in the Attribute Store
    dotdot_set_aox_locator_position_and_orientation(
      aoxpc_unid,
      AOXPC_ENDPOINT_ID,
      
      attribute_configuration.position_and_orientation);
    // Save AzimuthMask in the Attribute Store
    dotdot_set_aox_locator_azimuth_mask(
      aoxpc_unid,
      AOXPC_ENDPOINT_ID,
      attribute_configuration.azimuth_mask_count,
      attribute_configuration.azimuth_mask);
    // Save ElevationMask in the Attribute Store
    dotdot_set_aox_locator_elevation_mask(
      aoxpc_unid,
      AOXPC_ENDPOINT_ID,
      attribute_configuration.elevation_mask_count,
      attribute_configuration.elevation_mask);
    // Save AllowList in the Attribute Store
    dotdot_set_aox_locator_allow_list(
      aoxpc_unid,
      AOXPC_ENDPOINT_ID,
      attribute_configuration.allow_list_count,
      (const char**)attribute_configuration.allow_list);
    // Save CTEMode in the Attribute Store
    dotdot_set_aox_locator_cte_mode(
      aoxpc_unid,
      AOXPC_ENDPOINT_ID,
      
      attribute_configuration.cte_mode);
  sl_log_debug(LOG_TAG,
              "Saved AoXLocator configuration to the Attribute Store successfully.");
  return SL_STATUS_OK;
}

/**
 * @brief Sets the AoXLocator PositionAndOrientationValid Attribute
 *
 * @returns SL_STATUS_OK if successful, any other status code in case of error
 */
sl_status_t aox_locator_set_position_and_orientation_valid_attribute(
  bool position_and_orientation_valid
){
  attribute_configuration.position_and_orientation_valid = position_and_orientation_valid;

  // Publish to MQTT (No need to give an update notification to the application)
  publish_aox_locator_attributes_to_mqtt();
  return SL_STATUS_OK;
}
/**
 * @brief Sets the AoXLocator PositionAndOrientation Attribute
 *
 * @returns SL_STATUS_OK if successful, any other status code in case of error
 */
sl_status_t aox_locator_set_position_and_orientation_attribute(
  CoordinateAndOrientation position_and_orientation
){
  attribute_configuration.position_and_orientation = position_and_orientation;

  // Publish to MQTT (No need to give an update notification to the application)
  publish_aox_locator_attributes_to_mqtt();
  return SL_STATUS_OK;
}
/**
 * @brief Sets the AoXLocator AzimuthMask Attribute
 *
 * @returns SL_STATUS_OK if successful, any other status code in case of error
 */
sl_status_t aox_locator_set_azimuth_mask_attribute(
  size_t azimuth_mask_count,
  const MinMaxPair* azimuth_mask
    ){
  aox_locator_clear_allocated_azimuth_mask();
  attribute_configuration.azimuth_mask_count = azimuth_mask_count;
  attribute_configuration.azimuth_mask = malloc(sizeof(MinMaxPair) * azimuth_mask_count);

  for (size_t i = 0; i<azimuth_mask_count;i++) {
    attribute_configuration.azimuth_mask[i] = azimuth_mask[i];
  }

  // Publish to MQTT (No need to give an update notification to the application)
  publish_aox_locator_attributes_to_mqtt();
  return SL_STATUS_OK;
}
/**
 * @brief Sets the AoXLocator ElevationMask Attribute
 *
 * @returns SL_STATUS_OK if successful, any other status code in case of error
 */
sl_status_t aox_locator_set_elevation_mask_attribute(
  size_t elevation_mask_count,
  const MinMaxPair* elevation_mask
    ){
  aox_locator_clear_allocated_elevation_mask();
  attribute_configuration.elevation_mask_count = elevation_mask_count;
  attribute_configuration.elevation_mask = malloc(sizeof(MinMaxPair) * elevation_mask_count);

  for (size_t i = 0; i<elevation_mask_count;i++) {
    attribute_configuration.elevation_mask[i] = elevation_mask[i];
  }

  // Publish to MQTT (No need to give an update notification to the application)
  publish_aox_locator_attributes_to_mqtt();
  return SL_STATUS_OK;
}
/**
 * @brief Sets the AoXLocator AllowList Attribute
 *
 * @returns SL_STATUS_OK if successful, any other status code in case of error
 */
sl_status_t aox_locator_set_allow_list_attribute(
  size_t allow_list_count,
  const char** allow_list
){
  aox_locator_clear_allocated_allow_list();
  attribute_configuration.allow_list_count = allow_list_count;
  attribute_configuration.allow_list = malloc(sizeof(const char*) * allow_list_count);

  for (size_t i = 0; i<allow_list_count;i++) {
    size_t string_size = strlen(allow_list[i])+1;
    attribute_configuration.allow_list[i]= NULL;
    attribute_configuration.allow_list[i] = malloc(string_size);
    strncpy(attribute_configuration.allow_list[i], allow_list[i], string_size);
    attribute_configuration.allow_list[i][string_size-1] = '\0';
  }

  // Publish to MQTT (No need to give an update notification to the application)
  publish_aox_locator_attributes_to_mqtt();
  return SL_STATUS_OK;
}
/**
 * @brief Sets the AoXLocator CTEMode Attribute
 *
 * @returns SL_STATUS_OK if successful, any other status code in case of error
 */
sl_status_t aox_locator_set_cte_mode_attribute(
  uint8_t cte_mode
){
  attribute_configuration.cte_mode = cte_mode;

  // Publish to MQTT (No need to give an update notification to the application)
  publish_aox_locator_attributes_to_mqtt();
  return SL_STATUS_OK;
}

sl_status_t aox_locator_reset_configuration() {
  // Free up already allocated memory, if any
  aox_locator_clear_allocated_azimuth_mask();
  aox_locator_clear_allocated_elevation_mask();
  aox_locator_clear_allocated_allow_list();

  // Set the variables to 0.
  memset(&attribute_configuration,0,sizeof(attribute_configuration));
  return SL_STATUS_OK;
}

const aox_locator_attributes_t *aox_locator_configuration_get_configuration(){
  return &attribute_configuration;
}
