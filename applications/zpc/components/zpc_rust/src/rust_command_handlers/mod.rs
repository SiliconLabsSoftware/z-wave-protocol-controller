///////////////////////////////////////////////////////////////////////////////
// # License
// <b>Copyright 2022  Silicon Laboratories Inc. www.silabs.com</b>
///////////////////////////////////////////////////////////////////////////////
// The licensor of this software is Silicon Laboratories Inc. Your use of this
// software is governed by the terms of Silicon Labs Master Software License
// Agreement (MSLA) available at
// www.silabs.com/about-us/legal/master-software-license-agreement. This
// software is distributed to you in Source Code format and is governed by the
// sections of the MSLA applicable to Source Code.
//
///////////////////////////////////////////////////////////////////////////////

//! This module description will take you step by step through the process of
//! implementing a command class in rust. If your fairly new to command classes
//! we recommend to first skim through the official documentation of the
//! UnifySDK before continuing. Implementing command classes in rust should be
//! quick and require minimal effort. We put in extra effort into abstracting
//! away as much as setup and boiler plate code as possible, so the implementor
//! can focus on implementing the actual business logic of the command class.
//!
//! # Context
//!
//! The zwave command handler is the component inside the ZPC that is
//! responsible for handling incoming zwave commands and deferring it to the
//! correct command class implementation. These command class implementations
//! consists out of a bunch of loose trait implementations. more about this
//! later. Secondly, they are said to be stateless, they merely describe what
//! action need to be executed on a given command. This zwave command handler is
//! able to register command class implementations in C as well as in Rust. In
//! this documentation we will focus on the rust command class implementations.
//! They are hooked into the zpc in the same way and therefore should behave in
//! a similar matter.
//!
//! # [`rust_command_class_frame_types`] library
//!
//! When we speak about the term `frame` we refer to the binary payload that is
//! send over the zwave network. In rust we specifically refer to the frames
//! that describe a command to control or manage a Z-Wave node. Command frames
//! all are associated with a specific command class. For instance, a
//! [SwitchBinaryGet](../../rust_command_class_frame_types/command_class_switch_binary/struct.SwitchBinaryGetFrame.html),
//! [SwitchBinarySet](../../rust_command_class_frame_types/command_class_switch_binary/struct.SwitchBinarySetFrame.html)
//! are both commands that are part of the [BinarySwitch command
//! class](../../rust_command_class_frame_types/command_class_switch_binary/enum.CommandClassSwitchBinaryFrame.html).
//!
//! Instead of some binary representation, we have an library containing typed
//! data structures that can convert from and to a binary array. The internal
//! workings is not relevant, but its useful to know how to navigate through
//! this library. We will use this library to look up corresponding data types
//! for the command class we want to implement. read more in the module
//! documentation of [rust_command_class_frame_types]
//!
//! # Crate structure
//!
//! This crate is split into 3 different modules:
//! *   [zwave_command_classes](crate::zwave_command_classes)  This module
//!     contains all command class implementations. This is the place where you
//!     want to append your new command class.
//! *   [zwave_command_class_interface](crate::zwave_command_class_interface)
//!     This module contains all trait- interfaces, or building blocks, that can
//!     be implemented by a command class.
//! *   [zwave_command_class_definitions](crate::zwave_command_class_definitions)
//!     This module contains classes to support the working of this library.
//!     This will not be of interest when you start out writing command classes
//!
//! # Intro
//!
//! As mentioned before a command class implementation is build up by
//! implementing several traits. These trait implementations describe the core
//! logic of your command class. The rest of the command class is generated by
//! procedural macro's. In the beginning this might be a bit confusing, as the
//! control flow is partly hidden. On the pro side, we gain speed of
//! implementation since were are not bothered with boilerplate. for instance
//! the binary switch command class ,
//! [CommandClassSwitchBinaryFrame](../../rust_command_class_frame_types/command_class_switch_binary/enum.CommandClassSwitchBinaryFrame.html)),
//! has 3 associated frames: `SwitchBinaryGetFrame`, `SwitchBinaryReportFrame`,
//! `SwitchBinarySetFrame`. By implementing logic for only
//! `SwitchBinarySetFrame` the compiler knows that only initialization code for
//! the `SwitchBinarySetFrame` will be generated. On the other commands code
//! will be generated that return an error code `NOT_SUPPORTED`
//!
//! # Implementing a command class
//!
//! the most important building block to build up your command class handler, is
//! the [CommandClassConfigurationTrait]. With this trait you configure your
//! command class and specify some other options. Read more at the [doc
//! page](CommandClassConfigurationTrait). After implementing the configuration
//! trait, we can start implementing handlers for specific frames. This is done
//! by looking up the data-type corresponding to that frame (in the
//! [`rust_command_class_frame_types`](../../rust_command_class_frame_types/index.html)
//! crate) and implement the [FrameControlSupportTrait] for it. For example, we
//! would want to implement an handler for the
//! [SwitchBinarySet](../../rust_command_class_frame_types/command_class_switch_binary/struct.SwitchBinarySetFrame.html).
//! All we have to do is implement the [FrameControlSupportTrait] trait for the
//! `SwitchBinarySet` frame. After this step you have a working command class
//! handler!
//!
//! Next to the [CommandClassConfigurationTrait] and the
//! [FrameControlSupportTrait] we have more traits that you use to decorate your
//! frame handling implementation with. Currently we have 3 traits to pick from:
//! <table>
//!     <thread>
//!         <tr>
//!             <th>trait</th>
//!             <th>command class</th>
//!             <th>frame</th>
//!             <th>mandatory</th>
//!             <th>requires macro</th>
//!         </tr>
//!     </thread>
//!     <tbody>
//!         <tr>
//!             <td>
//!                 <a href="zwave_command_class_interface/configuration_trait/trait.CommandClassConfigurationTrait.html">
//!                     CommandClassConfigurationTrait
//!                 </a>
//!             </td>
//!             <td>x</td>
//!             <td></td>
//!             <td>x</td>
//!             <td>x</td>
//!         </tr>
//!         <tr>
//!             <td>
//!                 <a href="zwave_command_class_interface/version_changed_trait/trait.ZwaveVersionChangedTrait.html">
//!                     ZwaveVersionChangedTrait
//!                 </a>
//!             </td>
//!             <td>x</td>
//!             <td></td>
//!             <td></td>
//!             <td>x</td>
//!         </tr>
//!         <tr>
//!            <td>
//!                 <a href="zwave_command_class_interface/frame_trait/trait.FrameControlSupportTrait.html">
//!                     FrameControlSupportTrait
//!                 </a>
//!             </td>
//!             <td></td>
//!             <td>x</td>
//!             <td></td>
//!             <td></td>
//!         </tr>
//!     </tbody>
//! </table>
//!
//! Notice that some need to be implemented on the **command class** others need
//! to be implemented on the **command frames**. Most of these trait are
//! accompanied by a
//! [zwave_command_classes](../../zwave_rust_proc_macros/attr.zwave_command_class.html)
//! macro. They are there to procedurally generate the necessary boilerplate
//! code. yeaay!
//!
//! To learn more about the specifics of these trait, go to their corresponding
//! doc page. Continue reading if you want to continue with implementing a new
//! command class.
//!

extern crate zwave_rust_proc_macros;
extern crate zwave_rust_proc_macros_legacy;
pub mod zwave_command_class_definitions;
pub mod zwave_command_class_interface;
pub mod zwave_command_classes;

#[doc(no_inline)]
pub use zwave_command_class_definitions::*;
#[doc(no_inline)]
pub use zwave_command_class_interface::*;
#[doc(no_inline)]
pub use zwave_command_classes::*;

include!(concat!(env!("OUT_DIR"), "/lib.rs"));
