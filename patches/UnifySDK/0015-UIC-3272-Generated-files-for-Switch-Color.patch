From 44fedc439961733d8ba06700d15975a0e4d45c41 Mon Sep 17 00:00:00 2001
From: Viet <Viet.Nguyen@silabs.com>
Date: Wed, 11 Sep 2024 18:06:50 +0700
Subject: [PATCH] UIC-3272: Generated files for Switch Color

---
 .../zap-generated/include/dotdot_mqtt.h       |  511 ++++++
 .../include/dotdot_mqtt_attributes.h          |  113 ++
 .../include/dotdot_mqtt_generated_commands.h  |   64 +
 .../include/dotdot_mqtt_group_commands.h      |   49 +
 .../include/dotdot_mqtt_send_commands.h       |   78 +
 ...dotdot_mqtt_supported_generated_commands.h |   30 +
 .../zap-generated/src/dotdot_mqtt.cpp         | 1462 +++++++++++++++++
 .../zap-generated/src/dotdot_mqtt.hpp         |   66 +
 .../src/dotdot_mqtt_attributes.cpp            |  707 ++++++++
 .../src/dotdot_mqtt_command_helpers.cpp       |  176 ++
 .../src/dotdot_mqtt_command_helpers.hpp       |   82 +
 .../src/dotdot_mqtt_generated_commands.cpp    |  112 ++
 .../src/dotdot_mqtt_group_commands.cpp        |  335 ++++
 .../zap-generated/src/dotdot_mqtt_helpers.cpp |  102 ++
 .../src/dotdot_mqtt_send_commands.cpp         |  148 ++
 ...tdot_mqtt_supported_generated_commands.cpp |   49 +
 .../test/dotdot_mqtt_test.include             |   49 +
 .../include/dotdot_attributes.uam             |   10 +
 .../include/dotdot_attributes_camel_case.uam  |   10 +
 .../unify_dotdot_attribute_store_helpers.h    |  876 ++++++++++
 .../unify_dotdot_defined_attribute_types.h    |    9 +
 ...ot_attribute_store_attribute_publisher.cpp |  481 ++++++
 ..._force_read_attributes_command_callbacks.c |   67 +
 .../unify_dotdot_attribute_store_helpers.cpp  |  931 +++++++++++
 ...fy_dotdot_attribute_store_registration.cpp |  192 +++
 ...store_write_attributes_command_callbacks.c |   33 +
 .../test/unify_dotdot_attribute_store_test.c  |  158 ++
 .../test/unify_dotdot_attribute_store_test.h  |   10 +
 28 files changed, 6910 insertions(+)

diff --git a/components/uic_dotdot_mqtt/zap-generated/include/dotdot_mqtt.h b/components/uic_dotdot_mqtt/zap-generated/include/dotdot_mqtt.h
index 7106f0f0fc..650ce8ed54 100644
--- a/components/uic_dotdot_mqtt/zap-generated/include/dotdot_mqtt.h
+++ b/components/uic_dotdot_mqtt/zap-generated/include/dotdot_mqtt.h
@@ -42337,6 +42337,517 @@ void uic_mqtt_dotdot_unify_humidity_control_publish_supported_commands(
 void uic_mqtt_dotdot_unify_humidity_control_publish_empty_supported_commands(
   const dotdot_unid_t unid
   ,dotdot_endpoint_id_t endpoint);
+// Callback types used by the unify_switch_color cluster
+typedef sl_status_t (*uic_mqtt_dotdot_unify_switch_color_set_color_callback_t)(
+    dotdot_unid_t unid,
+    dotdot_endpoint_id_t endpoint,
+    uic_mqtt_dotdot_callback_call_type_t call_type,
+    uint8_t color_component_id,
+
+    uint8_t value,
+
+    uint32_t duration
+
+);
+typedef sl_status_t (*uic_mqtt_dotdot_unify_switch_color_start_stop_change_callback_t)(
+    dotdot_unid_t unid,
+    dotdot_endpoint_id_t endpoint,
+    uic_mqtt_dotdot_callback_call_type_t call_type,
+    bool start_stop,
+
+    bool up_down,
+
+    bool ignor_start_level,
+
+    uint8_t color_component_id,
+
+    uint8_t start_level,
+
+    uint32_t duration
+
+);
+
+typedef struct {
+  uint8_t warm_white;
+  uint8_t cold_white;
+  uint8_t red;
+  uint8_t green;
+  uint8_t blue;
+  uint8_t amber;
+  uint8_t cyan;
+  uint8_t purple;
+} uic_mqtt_dotdot_unify_switch_color_state_t;
+
+typedef struct {
+  bool warm_white;
+  bool cold_white;
+  bool red;
+  bool green;
+  bool blue;
+  bool amber;
+  bool cyan;
+  bool purple;
+} uic_mqtt_dotdot_unify_switch_color_updated_state_t;
+
+typedef sl_status_t (*uic_mqtt_dotdot_unify_switch_color_write_attributes_callback_t)(
+    const dotdot_unid_t unid,
+    const dotdot_endpoint_id_t endpoint,
+    uic_mqtt_dotdot_callback_call_type_t call_type,
+    uic_mqtt_dotdot_unify_switch_color_state_t,
+    uic_mqtt_dotdot_unify_switch_color_updated_state_t
+);
+
+typedef sl_status_t (*uic_mqtt_dotdot_unify_switch_color_force_read_attributes_callback_t)(
+    const dotdot_unid_t unid,
+    const dotdot_endpoint_id_t endpoint,
+    uic_mqtt_dotdot_callback_call_type_t call_type,
+    uic_mqtt_dotdot_unify_switch_color_updated_state_t
+);
+
+
+/**
+ * @brief Command fields for UnifySwitchColor/SetColor
+ */
+typedef struct {
+  uint8_t color_component_id;
+
+  uint8_t value;
+
+  uint32_t duration;
+} uic_mqtt_dotdot_unify_switch_color_command_set_color_fields_t;
+
+/**
+ * @brief Command fields for UnifySwitchColor/StartStopChange
+ */
+typedef struct {
+  bool start_stop;
+
+  bool up_down;
+
+  bool ignor_start_level;
+
+  uint8_t color_component_id;
+
+  uint8_t start_level;
+
+  uint32_t duration;
+} uic_mqtt_dotdot_unify_switch_color_command_start_stop_change_fields_t;
+
+
+/**
+ * @brief Setup callback to be called when a
+ * UnifySwitchColor/Commands/set_color is received.
+ *
+ * Setting this callback will not overwrite the previous set callback
+ * @param callback      Function to be called on command reception
+ */
+void uic_mqtt_dotdot_unify_switch_color_set_color_callback_set(const uic_mqtt_dotdot_unify_switch_color_set_color_callback_t callback);
+/**
+ * @brief Unsets callback to be called when a
+ * UnifySwitchColor/Commands/set_color is received.
+ *
+ * @param callback      Function to be no longer called on command reception
+ */
+void uic_mqtt_dotdot_unify_switch_color_set_color_callback_unset(const uic_mqtt_dotdot_unify_switch_color_set_color_callback_t callback);
+/**
+ * @brief Clears all callbacks registered for when
+ * UnifySwitchColor/Commands/set_color is received.
+ */
+void uic_mqtt_dotdot_unify_switch_color_set_color_callback_clear();
+
+/**
+ * @brief Setup callback to be called when a
+ * +/UnifySwitchColor/GeneratedCommands/set_color is received.
+ *
+ * Setting this callback will not overwrite the previous set callback
+ * @param callback      Function to be called on command reception
+ */
+void uic_mqtt_dotdot_unify_switch_color_generated_set_color_callback_set(const uic_mqtt_dotdot_unify_switch_color_set_color_callback_t callback);
+/**
+ * @brief Unsets callback to be called when a
+ * +/UnifySwitchColor/GeneratedCommands/set_color is received.
+ * @param callback      Function to be no longer called on command reception
+ */
+void uic_mqtt_dotdot_unify_switch_color_generated_set_color_callback_unset(const uic_mqtt_dotdot_unify_switch_color_set_color_callback_t callback);
+/**
+ * @brief Clears all callbacks registered for when
+ * +/UnifySwitchColor/GeneratedCommands/set_color is received.
+ */
+void uic_mqtt_dotdot_unify_switch_color_generated_set_color_callback_clear();
+/**
+ * @brief Setup callback to be called when a
+ * UnifySwitchColor/Commands/start_stop_change is received.
+ *
+ * Setting this callback will not overwrite the previous set callback
+ * @param callback      Function to be called on command reception
+ */
+void uic_mqtt_dotdot_unify_switch_color_start_stop_change_callback_set(const uic_mqtt_dotdot_unify_switch_color_start_stop_change_callback_t callback);
+/**
+ * @brief Unsets callback to be called when a
+ * UnifySwitchColor/Commands/start_stop_change is received.
+ *
+ * @param callback      Function to be no longer called on command reception
+ */
+void uic_mqtt_dotdot_unify_switch_color_start_stop_change_callback_unset(const uic_mqtt_dotdot_unify_switch_color_start_stop_change_callback_t callback);
+/**
+ * @brief Clears all callbacks registered for when
+ * UnifySwitchColor/Commands/start_stop_change is received.
+ */
+void uic_mqtt_dotdot_unify_switch_color_start_stop_change_callback_clear();
+
+/**
+ * @brief Setup callback to be called when a
+ * +/UnifySwitchColor/GeneratedCommands/start_stop_change is received.
+ *
+ * Setting this callback will not overwrite the previous set callback
+ * @param callback      Function to be called on command reception
+ */
+void uic_mqtt_dotdot_unify_switch_color_generated_start_stop_change_callback_set(const uic_mqtt_dotdot_unify_switch_color_start_stop_change_callback_t callback);
+/**
+ * @brief Unsets callback to be called when a
+ * +/UnifySwitchColor/GeneratedCommands/start_stop_change is received.
+ * @param callback      Function to be no longer called on command reception
+ */
+void uic_mqtt_dotdot_unify_switch_color_generated_start_stop_change_callback_unset(const uic_mqtt_dotdot_unify_switch_color_start_stop_change_callback_t callback);
+/**
+ * @brief Clears all callbacks registered for when
+ * +/UnifySwitchColor/GeneratedCommands/start_stop_change is received.
+ */
+void uic_mqtt_dotdot_unify_switch_color_generated_start_stop_change_callback_clear();
+
+/**
+ * @brief Setup a callback for WriteAttribute to be called when a
+ * +/unify_switch_color/Commands/WriteAttributes is received.
+ *
+ * Setting this callback will not overwrite the previous set callback
+ * @param callback      Function to be called on command reception
+ */
+void uic_mqtt_dotdot_set_unify_switch_color_write_attributes_callback(
+  const uic_mqtt_dotdot_unify_switch_color_write_attributes_callback_t callback
+);
+/**
+ * @brief Unsets a callback for WriteAttribute to be called when a
+ * +/unify_switch_color/Commands/WriteAttributes is received.
+ * @param callback      Function to be no longer called on command reception
+ */
+void uic_mqtt_dotdot_unset_unify_switch_color_write_attributes_callback(
+  const uic_mqtt_dotdot_unify_switch_color_write_attributes_callback_t callback
+);
+/**
+ * @brief Clears all callbacks registered for when
+ * +/unify_switch_color/Commands/WriteAttributes is received.
+ */
+void uic_mqtt_dotdot_clear_unify_switch_color_write_attributes_callbacks();
+
+/**
+ * @brief Setup a callback for ForceReadAttributes to be called when a
+ * +/unify_switch_color/Commands/ForceReadAttributes is received.
+ *
+ * Setting this callback will not overwrite the previous set callback
+ * @param callback      Function to be called on command reception
+ */
+void uic_mqtt_dotdot_set_unify_switch_color_force_read_attributes_callback(
+  const uic_mqtt_dotdot_unify_switch_color_force_read_attributes_callback_t callback
+);
+/**
+ * @brief Unsets a callback for ForceReadAttributes to be called when a
+ * +/unify_switch_color/Commands/ForceReadAttributes is received.
+ *
+ * @param callback      Function to be no longer called on command reception
+ */
+void uic_mqtt_dotdot_unset_unify_switch_color_force_read_attributes_callback(
+  const uic_mqtt_dotdot_unify_switch_color_force_read_attributes_callback_t callback
+);
+/**
+ * @brief Clears all callbacks registered for when
+ * +/unify_switch_color/Commands/ForceReadAttributes is received.
+ */
+void uic_mqtt_dotdot_clear_unify_switch_color_force_read_attributes_callbacks();
+
+/**
+ * @brief Publish the attribute; UnifySwitchColor/Attributes/WarmWhite
+ *
+ * @param base_topic    topic prefix to publish, /warm_white
+ *                      will be appended
+ * @param value         Value to publish
+ * @param publish_type  Whether to publish as Desired, Reported, or Both.
+ *
+ * @returns SL_STATUS_OK on success
+ */
+sl_status_t uic_mqtt_dotdot_unify_switch_color_warm_white_publish(
+  const char *base_topic,
+  uint8_t value,
+  uic_mqtt_dotdot_attribute_publish_type_t publish_type
+);
+
+/**
+ * @brief Unretains a published attribute; UnifySwitchColor/Attributes/WarmWhite
+ *
+ * @param base_topic    topic prefix to publish, /warm_white
+ *                      will be appended
+ * @param publish_type  Whether to publish as Desired, Reported, or Both.
+ *
+ * @returns SL_STATUS_OK on success
+ */
+sl_status_t uic_mqtt_dotdot_unify_switch_color_warm_white_unretain(
+  const char *base_topic,
+  uic_mqtt_dotdot_attribute_publish_type_t publish_type
+);
+
+/**
+ * @brief Publish the attribute; UnifySwitchColor/Attributes/ColdWhite
+ *
+ * @param base_topic    topic prefix to publish, /cold_white
+ *                      will be appended
+ * @param value         Value to publish
+ * @param publish_type  Whether to publish as Desired, Reported, or Both.
+ *
+ * @returns SL_STATUS_OK on success
+ */
+sl_status_t uic_mqtt_dotdot_unify_switch_color_cold_white_publish(
+  const char *base_topic,
+  uint8_t value,
+  uic_mqtt_dotdot_attribute_publish_type_t publish_type
+);
+
+/**
+ * @brief Unretains a published attribute; UnifySwitchColor/Attributes/ColdWhite
+ *
+ * @param base_topic    topic prefix to publish, /cold_white
+ *                      will be appended
+ * @param publish_type  Whether to publish as Desired, Reported, or Both.
+ *
+ * @returns SL_STATUS_OK on success
+ */
+sl_status_t uic_mqtt_dotdot_unify_switch_color_cold_white_unretain(
+  const char *base_topic,
+  uic_mqtt_dotdot_attribute_publish_type_t publish_type
+);
+
+/**
+ * @brief Publish the attribute; UnifySwitchColor/Attributes/Red
+ *
+ * @param base_topic    topic prefix to publish, /red
+ *                      will be appended
+ * @param value         Value to publish
+ * @param publish_type  Whether to publish as Desired, Reported, or Both.
+ *
+ * @returns SL_STATUS_OK on success
+ */
+sl_status_t uic_mqtt_dotdot_unify_switch_color_red_publish(
+  const char *base_topic,
+  uint8_t value,
+  uic_mqtt_dotdot_attribute_publish_type_t publish_type
+);
+
+/**
+ * @brief Unretains a published attribute; UnifySwitchColor/Attributes/Red
+ *
+ * @param base_topic    topic prefix to publish, /red
+ *                      will be appended
+ * @param publish_type  Whether to publish as Desired, Reported, or Both.
+ *
+ * @returns SL_STATUS_OK on success
+ */
+sl_status_t uic_mqtt_dotdot_unify_switch_color_red_unretain(
+  const char *base_topic,
+  uic_mqtt_dotdot_attribute_publish_type_t publish_type
+);
+
+/**
+ * @brief Publish the attribute; UnifySwitchColor/Attributes/Green
+ *
+ * @param base_topic    topic prefix to publish, /green
+ *                      will be appended
+ * @param value         Value to publish
+ * @param publish_type  Whether to publish as Desired, Reported, or Both.
+ *
+ * @returns SL_STATUS_OK on success
+ */
+sl_status_t uic_mqtt_dotdot_unify_switch_color_green_publish(
+  const char *base_topic,
+  uint8_t value,
+  uic_mqtt_dotdot_attribute_publish_type_t publish_type
+);
+
+/**
+ * @brief Unretains a published attribute; UnifySwitchColor/Attributes/Green
+ *
+ * @param base_topic    topic prefix to publish, /green
+ *                      will be appended
+ * @param publish_type  Whether to publish as Desired, Reported, or Both.
+ *
+ * @returns SL_STATUS_OK on success
+ */
+sl_status_t uic_mqtt_dotdot_unify_switch_color_green_unretain(
+  const char *base_topic,
+  uic_mqtt_dotdot_attribute_publish_type_t publish_type
+);
+
+/**
+ * @brief Publish the attribute; UnifySwitchColor/Attributes/Blue
+ *
+ * @param base_topic    topic prefix to publish, /blue
+ *                      will be appended
+ * @param value         Value to publish
+ * @param publish_type  Whether to publish as Desired, Reported, or Both.
+ *
+ * @returns SL_STATUS_OK on success
+ */
+sl_status_t uic_mqtt_dotdot_unify_switch_color_blue_publish(
+  const char *base_topic,
+  uint8_t value,
+  uic_mqtt_dotdot_attribute_publish_type_t publish_type
+);
+
+/**
+ * @brief Unretains a published attribute; UnifySwitchColor/Attributes/Blue
+ *
+ * @param base_topic    topic prefix to publish, /blue
+ *                      will be appended
+ * @param publish_type  Whether to publish as Desired, Reported, or Both.
+ *
+ * @returns SL_STATUS_OK on success
+ */
+sl_status_t uic_mqtt_dotdot_unify_switch_color_blue_unretain(
+  const char *base_topic,
+  uic_mqtt_dotdot_attribute_publish_type_t publish_type
+);
+
+/**
+ * @brief Publish the attribute; UnifySwitchColor/Attributes/Amber
+ *
+ * @param base_topic    topic prefix to publish, /amber
+ *                      will be appended
+ * @param value         Value to publish
+ * @param publish_type  Whether to publish as Desired, Reported, or Both.
+ *
+ * @returns SL_STATUS_OK on success
+ */
+sl_status_t uic_mqtt_dotdot_unify_switch_color_amber_publish(
+  const char *base_topic,
+  uint8_t value,
+  uic_mqtt_dotdot_attribute_publish_type_t publish_type
+);
+
+/**
+ * @brief Unretains a published attribute; UnifySwitchColor/Attributes/Amber
+ *
+ * @param base_topic    topic prefix to publish, /amber
+ *                      will be appended
+ * @param publish_type  Whether to publish as Desired, Reported, or Both.
+ *
+ * @returns SL_STATUS_OK on success
+ */
+sl_status_t uic_mqtt_dotdot_unify_switch_color_amber_unretain(
+  const char *base_topic,
+  uic_mqtt_dotdot_attribute_publish_type_t publish_type
+);
+
+/**
+ * @brief Publish the attribute; UnifySwitchColor/Attributes/Cyan
+ *
+ * @param base_topic    topic prefix to publish, /cyan
+ *                      will be appended
+ * @param value         Value to publish
+ * @param publish_type  Whether to publish as Desired, Reported, or Both.
+ *
+ * @returns SL_STATUS_OK on success
+ */
+sl_status_t uic_mqtt_dotdot_unify_switch_color_cyan_publish(
+  const char *base_topic,
+  uint8_t value,
+  uic_mqtt_dotdot_attribute_publish_type_t publish_type
+);
+
+/**
+ * @brief Unretains a published attribute; UnifySwitchColor/Attributes/Cyan
+ *
+ * @param base_topic    topic prefix to publish, /cyan
+ *                      will be appended
+ * @param publish_type  Whether to publish as Desired, Reported, or Both.
+ *
+ * @returns SL_STATUS_OK on success
+ */
+sl_status_t uic_mqtt_dotdot_unify_switch_color_cyan_unretain(
+  const char *base_topic,
+  uic_mqtt_dotdot_attribute_publish_type_t publish_type
+);
+
+/**
+ * @brief Publish the attribute; UnifySwitchColor/Attributes/Purple
+ *
+ * @param base_topic    topic prefix to publish, /purple
+ *                      will be appended
+ * @param value         Value to publish
+ * @param publish_type  Whether to publish as Desired, Reported, or Both.
+ *
+ * @returns SL_STATUS_OK on success
+ */
+sl_status_t uic_mqtt_dotdot_unify_switch_color_purple_publish(
+  const char *base_topic,
+  uint8_t value,
+  uic_mqtt_dotdot_attribute_publish_type_t publish_type
+);
+
+/**
+ * @brief Unretains a published attribute; UnifySwitchColor/Attributes/Purple
+ *
+ * @param base_topic    topic prefix to publish, /purple
+ *                      will be appended
+ * @param publish_type  Whether to publish as Desired, Reported, or Both.
+ *
+ * @returns SL_STATUS_OK on success
+ */
+sl_status_t uic_mqtt_dotdot_unify_switch_color_purple_unretain(
+  const char *base_topic,
+  uic_mqtt_dotdot_attribute_publish_type_t publish_type
+);
+
+
+/**
+ * @brief Publish the UnifySwitchColor/ClusterRevision attribute
+ *
+ * @param base_topic    topic prefix to publish, /UnifySwitchColor/Attributes/ClusterRevision
+ *                      will be appended.
+ * @param value         Value to publish.
+ */
+void uic_mqtt_dotdot_unify_switch_color_publish_cluster_revision(const char* base_topic, uint16_t value);
+
+/**
+ * @brief Unretain a publication to UnifySwitchColor/ClusterRevision attribute
+ *
+ * @param base_topic    topic prefix to publish, /UnifySwitchColor/Attributes/ClusterRevision
+ *                      will be appended.
+ */
+void uic_mqtt_dotdot_unify_switch_color_unretain_cluster_revision(const char* base_topic);
+
+/**
+ * @brief Publish the SupportedCommands for UNID/EndPoint for the UnifySwitchColor Cluster
+ *
+ * This function will iterate over all Commands in the UnifySwitchColor Cluster and
+ * call all registered callback functions with UNID/endpoint, and
+ * callback_type = UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK.
+ * All Cluster Command callback functions that return SL_STATUS_OK
+ * will be added to the list of supported commands and published.
+ *
+ * @param unid
+ * @param endpoint
+ */
+void uic_mqtt_dotdot_unify_switch_color_publish_supported_commands(
+  const dotdot_unid_t unid,
+  dotdot_endpoint_id_t endpoint);
+
+/**
+ * @brief Publish an empty array of SupportedCommands for UNID/EndPoint for
+ * the UnifySwitchColor Cluster
+ *
+ * @param unid
+ * @param endpoint )
+ */
+void uic_mqtt_dotdot_unify_switch_color_publish_empty_supported_commands(
+  const dotdot_unid_t unid
+  ,dotdot_endpoint_id_t endpoint);
 
 /**
  * @brief Publish the SupportedCommands for UNID/EndPoint
diff --git a/components/uic_dotdot_mqtt/zap-generated/include/dotdot_mqtt_attributes.h b/components/uic_dotdot_mqtt/zap-generated/include/dotdot_mqtt_attributes.h
index 9f094654e3..8cba2ecb59 100644
--- a/components/uic_dotdot_mqtt/zap-generated/include/dotdot_mqtt_attributes.h
+++ b/components/uic_dotdot_mqtt/zap-generated/include/dotdot_mqtt_attributes.h
@@ -5230,6 +5230,63 @@ typedef sl_status_t (*uic_mqtt_dotdot_unify_humidity_control_attribute_auto_setp
   uic_mqtt_dotdot_attribute_update_type_t update_type,
   uint8_t auto_setpoint_precision
 );
+// Callback types used by the unify_switch_color cluster
+typedef sl_status_t (*uic_mqtt_dotdot_unify_switch_color_attribute_warm_white_callback_t)(
+  dotdot_unid_t unid,
+  dotdot_endpoint_id_t endpoint,
+  bool unretained,
+  uic_mqtt_dotdot_attribute_update_type_t update_type,
+  uint8_t warm_white
+);
+typedef sl_status_t (*uic_mqtt_dotdot_unify_switch_color_attribute_cold_white_callback_t)(
+  dotdot_unid_t unid,
+  dotdot_endpoint_id_t endpoint,
+  bool unretained,
+  uic_mqtt_dotdot_attribute_update_type_t update_type,
+  uint8_t cold_white
+);
+typedef sl_status_t (*uic_mqtt_dotdot_unify_switch_color_attribute_red_callback_t)(
+  dotdot_unid_t unid,
+  dotdot_endpoint_id_t endpoint,
+  bool unretained,
+  uic_mqtt_dotdot_attribute_update_type_t update_type,
+  uint8_t red
+);
+typedef sl_status_t (*uic_mqtt_dotdot_unify_switch_color_attribute_green_callback_t)(
+  dotdot_unid_t unid,
+  dotdot_endpoint_id_t endpoint,
+  bool unretained,
+  uic_mqtt_dotdot_attribute_update_type_t update_type,
+  uint8_t green
+);
+typedef sl_status_t (*uic_mqtt_dotdot_unify_switch_color_attribute_blue_callback_t)(
+  dotdot_unid_t unid,
+  dotdot_endpoint_id_t endpoint,
+  bool unretained,
+  uic_mqtt_dotdot_attribute_update_type_t update_type,
+  uint8_t blue
+);
+typedef sl_status_t (*uic_mqtt_dotdot_unify_switch_color_attribute_amber_callback_t)(
+  dotdot_unid_t unid,
+  dotdot_endpoint_id_t endpoint,
+  bool unretained,
+  uic_mqtt_dotdot_attribute_update_type_t update_type,
+  uint8_t amber
+);
+typedef sl_status_t (*uic_mqtt_dotdot_unify_switch_color_attribute_cyan_callback_t)(
+  dotdot_unid_t unid,
+  dotdot_endpoint_id_t endpoint,
+  bool unretained,
+  uic_mqtt_dotdot_attribute_update_type_t update_type,
+  uint8_t cyan
+);
+typedef sl_status_t (*uic_mqtt_dotdot_unify_switch_color_attribute_purple_callback_t)(
+  dotdot_unid_t unid,
+  dotdot_endpoint_id_t endpoint,
+  bool unretained,
+  uic_mqtt_dotdot_attribute_update_type_t update_type,
+  uint8_t purple
+);
 
 #ifdef __cplusplus
 extern "C" {
@@ -10054,6 +10111,62 @@ void uic_mqtt_dotdot_unify_humidity_control_attribute_auto_setpoint_scale_callba
 void uic_mqtt_dotdot_unify_humidity_control_attribute_auto_setpoint_precision_callback_set(const uic_mqtt_dotdot_unify_humidity_control_attribute_auto_setpoint_precision_callback_t callback);
 
 
+/**
+ *  Initializes the attributes features for the UnifySwitchColor cluster,
+ *  allowing to receive attribute updates from other UNIDs.
+ */
+sl_status_t uic_mqtt_dotdot_unify_switch_color_attributes_init();
+
+/**
+ * Setup callback to be called when a
+ * UnifySwitchColor/Attributes/warm_white/# is received. Setting
+ * this callback will overwrite the previous set callback
+ */
+void uic_mqtt_dotdot_unify_switch_color_attribute_warm_white_callback_set(const uic_mqtt_dotdot_unify_switch_color_attribute_warm_white_callback_t callback);
+/**
+ * Setup callback to be called when a
+ * UnifySwitchColor/Attributes/cold_white/# is received. Setting
+ * this callback will overwrite the previous set callback
+ */
+void uic_mqtt_dotdot_unify_switch_color_attribute_cold_white_callback_set(const uic_mqtt_dotdot_unify_switch_color_attribute_cold_white_callback_t callback);
+/**
+ * Setup callback to be called when a
+ * UnifySwitchColor/Attributes/red/# is received. Setting
+ * this callback will overwrite the previous set callback
+ */
+void uic_mqtt_dotdot_unify_switch_color_attribute_red_callback_set(const uic_mqtt_dotdot_unify_switch_color_attribute_red_callback_t callback);
+/**
+ * Setup callback to be called when a
+ * UnifySwitchColor/Attributes/green/# is received. Setting
+ * this callback will overwrite the previous set callback
+ */
+void uic_mqtt_dotdot_unify_switch_color_attribute_green_callback_set(const uic_mqtt_dotdot_unify_switch_color_attribute_green_callback_t callback);
+/**
+ * Setup callback to be called when a
+ * UnifySwitchColor/Attributes/blue/# is received. Setting
+ * this callback will overwrite the previous set callback
+ */
+void uic_mqtt_dotdot_unify_switch_color_attribute_blue_callback_set(const uic_mqtt_dotdot_unify_switch_color_attribute_blue_callback_t callback);
+/**
+ * Setup callback to be called when a
+ * UnifySwitchColor/Attributes/amber/# is received. Setting
+ * this callback will overwrite the previous set callback
+ */
+void uic_mqtt_dotdot_unify_switch_color_attribute_amber_callback_set(const uic_mqtt_dotdot_unify_switch_color_attribute_amber_callback_t callback);
+/**
+ * Setup callback to be called when a
+ * UnifySwitchColor/Attributes/cyan/# is received. Setting
+ * this callback will overwrite the previous set callback
+ */
+void uic_mqtt_dotdot_unify_switch_color_attribute_cyan_callback_set(const uic_mqtt_dotdot_unify_switch_color_attribute_cyan_callback_t callback);
+/**
+ * Setup callback to be called when a
+ * UnifySwitchColor/Attributes/purple/# is received. Setting
+ * this callback will overwrite the previous set callback
+ */
+void uic_mqtt_dotdot_unify_switch_color_attribute_purple_callback_set(const uic_mqtt_dotdot_unify_switch_color_attribute_purple_callback_t callback);
+
+
 #ifdef __cplusplus
 }
 #endif // __cplusplus
diff --git a/components/uic_dotdot_mqtt/zap-generated/include/dotdot_mqtt_generated_commands.h b/components/uic_dotdot_mqtt/zap-generated/include/dotdot_mqtt_generated_commands.h
index 96e33e47d2..e1f17dad77 100644
--- a/components/uic_dotdot_mqtt/zap-generated/include/dotdot_mqtt_generated_commands.h
+++ b/components/uic_dotdot_mqtt/zap-generated/include/dotdot_mqtt_generated_commands.h
@@ -5461,6 +5461,70 @@ void uic_mqtt_dotdot_unify_humidity_control_publish_generated_write_attributes_c
   uic_mqtt_dotdot_unify_humidity_control_updated_state_t attribute_list
 );
 
+/**
+ * @brief Publishes an incoming/generated SetColor command for
+ * the UnifySwitchColor cluster.
+ *
+ * Publication will be made at the following topic
+ * ucl/by-unid/UNID/epID/UnifySwitchColor/GeneratedCommands/SetColor
+ *
+ * @param unid      The UNID of the node that sent us the command.
+ * 
+ * @param endpoint  The Endpoint ID of the node that sent us the command.
+ * 
+ * 
+ * @param fields                Struct pointer with the fields value of the command
+ * 
+ */
+void uic_mqtt_dotdot_unify_switch_color_publish_generated_set_color_command(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint,
+  const uic_mqtt_dotdot_unify_switch_color_command_set_color_fields_t *fields
+  
+);
+/**
+ * @brief Publishes an incoming/generated StartStopChange command for
+ * the UnifySwitchColor cluster.
+ *
+ * Publication will be made at the following topic
+ * ucl/by-unid/UNID/epID/UnifySwitchColor/GeneratedCommands/StartStopChange
+ *
+ * @param unid      The UNID of the node that sent us the command.
+ * 
+ * @param endpoint  The Endpoint ID of the node that sent us the command.
+ * 
+ * 
+ * @param fields                Struct pointer with the fields value of the command
+ * 
+ */
+void uic_mqtt_dotdot_unify_switch_color_publish_generated_start_stop_change_command(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint,
+  const uic_mqtt_dotdot_unify_switch_color_command_start_stop_change_fields_t *fields
+  
+);
+
+/**
+ * @brief Publishes an incoming/generated WriteAttributes command for
+ * the UnifySwitchColor cluster.
+ *
+ * Publication will be made at the following topic
+ * ucl/by-unid/UNID/epID/UnifySwitchColor/GeneratedCommands/WriteAttributes
+ *
+ * @param unid      The UNID of the node that sent us the command.
+ * 
+ * @param endpoint  The Endpoint ID of the node that sent us the command.
+ * 
+ * @param attribute_values  Values to assign to the attributes
+ * @param attribute_list    List of attributes that are written
+ */
+void uic_mqtt_dotdot_unify_switch_color_publish_generated_write_attributes_command(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint,
+  uic_mqtt_dotdot_unify_switch_color_state_t attribute_values,
+  uic_mqtt_dotdot_unify_switch_color_updated_state_t attribute_list
+);
+
 
 #ifdef __cplusplus
 }
diff --git a/components/uic_dotdot_mqtt/zap-generated/include/dotdot_mqtt_group_commands.h b/components/uic_dotdot_mqtt/zap-generated/include/dotdot_mqtt_group_commands.h
index e052483320..6bf8346dae 100644
--- a/components/uic_dotdot_mqtt/zap-generated/include/dotdot_mqtt_group_commands.h
+++ b/components/uic_dotdot_mqtt/zap-generated/include/dotdot_mqtt_group_commands.h
@@ -4073,6 +4073,55 @@ void uic_mqtt_dotdot_by_group_unify_humidity_control_write_attributes_callback_s
 
 
 
+/**
+ * @brief Callback signature for by-group UnifySwitchColor::SetColor command.
+ */
+typedef void (*uic_mqtt_dotdot_by_group_unify_switch_color_set_color_callback_t)(
+    const dotdot_group_id_t group_id,
+    const uic_mqtt_dotdot_unify_switch_color_command_set_color_fields_t *fields
+);
+
+/**
+ * Setup handler to be called when a
+ * ucl/by-group/+/UnifySwitchColor/set_color is received.
+ * Setting this callback will overwrite the previous set callback.
+ *
+ */
+void uic_mqtt_dotdot_by_group_unify_switch_color_set_color_callback_set(const uic_mqtt_dotdot_by_group_unify_switch_color_set_color_callback_t callback);
+
+/**
+ * @brief Callback signature for by-group UnifySwitchColor::StartStopChange command.
+ */
+typedef void (*uic_mqtt_dotdot_by_group_unify_switch_color_start_stop_change_callback_t)(
+    const dotdot_group_id_t group_id,
+    const uic_mqtt_dotdot_unify_switch_color_command_start_stop_change_fields_t *fields
+);
+
+/**
+ * Setup handler to be called when a
+ * ucl/by-group/+/UnifySwitchColor/start_stop_change is received.
+ * Setting this callback will overwrite the previous set callback.
+ *
+ */
+void uic_mqtt_dotdot_by_group_unify_switch_color_start_stop_change_callback_set(const uic_mqtt_dotdot_by_group_unify_switch_color_start_stop_change_callback_t callback);
+
+typedef void (*uic_mqtt_dotdot_by_group_unify_switch_color_write_attributes_callback_t)(
+    const dotdot_group_id_t group_id,
+    uic_mqtt_dotdot_unify_switch_color_state_t,
+    uic_mqtt_dotdot_unify_switch_color_updated_state_t
+);
+
+/**
+ * Setup a callback for WriteAttribute to be called when a
+ * ucl/by-group/+/unify_switch_color/Commands/WriteAttributes is received.
+ * Setting this callback will overwrite any previously set callback.
+ */
+void uic_mqtt_dotdot_by_group_unify_switch_color_write_attributes_callback_set(
+  const uic_mqtt_dotdot_by_group_unify_switch_color_write_attributes_callback_t callback
+);
+
+
+
 #ifdef __cplusplus
 }
 #endif // __cplusplus
diff --git a/components/uic_dotdot_mqtt/zap-generated/include/dotdot_mqtt_send_commands.h b/components/uic_dotdot_mqtt/zap-generated/include/dotdot_mqtt_send_commands.h
index 3d8d69ac9e..fdbeda4042 100644
--- a/components/uic_dotdot_mqtt/zap-generated/include/dotdot_mqtt_send_commands.h
+++ b/components/uic_dotdot_mqtt/zap-generated/include/dotdot_mqtt_send_commands.h
@@ -7926,6 +7926,84 @@ void uic_mqtt_dotdot_unify_humidity_control_publish_setpoint_set_command_to_grou
   const uic_mqtt_dotdot_unify_humidity_control_command_setpoint_set_fields_t *fields
   
 );
+/**
+ * @brief Sends/Publishes a SetColor command for
+ * the UnifySwitchColor cluster to a destination.
+ *
+ * Publication will be made at the following topic
+ * ucl/by-unid/UNID/epID/UnifySwitchColor/Commands/SetColor
+ *
+ * @param destination_unid      The UNID of the node that should receive the command.
+ * 
+ * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
+ * 
+ * 
+ * @param fields                Struct pointer with the fields value of the command
+ * 
+ */
+void uic_mqtt_dotdot_unify_switch_color_publish_set_color_command(
+  const dotdot_unid_t destination_unid,
+  const dotdot_endpoint_id_t destination_endpoint,
+  const uic_mqtt_dotdot_unify_switch_color_command_set_color_fields_t *fields
+  
+);
+
+/**
+ * @brief Sends/Publishes a SetColor command for
+ * the UnifySwitchColor cluster to a group.
+ *
+ * Publication will be made at the following topic
+ * ucl/by-group/GroupID/UnifySwitchColor/Commands/SetColor
+ *
+ * @param destination_group_id  The GroupID that should receive the command.
+ * 
+ * @param fields                Struct pointer with the fields value of the command
+ * 
+ */
+void uic_mqtt_dotdot_unify_switch_color_publish_set_color_command_to_group(
+  uint16_t destination_group_id,
+  const uic_mqtt_dotdot_unify_switch_color_command_set_color_fields_t *fields
+  
+);
+/**
+ * @brief Sends/Publishes a StartStopChange command for
+ * the UnifySwitchColor cluster to a destination.
+ *
+ * Publication will be made at the following topic
+ * ucl/by-unid/UNID/epID/UnifySwitchColor/Commands/StartStopChange
+ *
+ * @param destination_unid      The UNID of the node that should receive the command.
+ * 
+ * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
+ * 
+ * 
+ * @param fields                Struct pointer with the fields value of the command
+ * 
+ */
+void uic_mqtt_dotdot_unify_switch_color_publish_start_stop_change_command(
+  const dotdot_unid_t destination_unid,
+  const dotdot_endpoint_id_t destination_endpoint,
+  const uic_mqtt_dotdot_unify_switch_color_command_start_stop_change_fields_t *fields
+  
+);
+
+/**
+ * @brief Sends/Publishes a StartStopChange command for
+ * the UnifySwitchColor cluster to a group.
+ *
+ * Publication will be made at the following topic
+ * ucl/by-group/GroupID/UnifySwitchColor/Commands/StartStopChange
+ *
+ * @param destination_group_id  The GroupID that should receive the command.
+ * 
+ * @param fields                Struct pointer with the fields value of the command
+ * 
+ */
+void uic_mqtt_dotdot_unify_switch_color_publish_start_stop_change_command_to_group(
+  uint16_t destination_group_id,
+  const uic_mqtt_dotdot_unify_switch_color_command_start_stop_change_fields_t *fields
+  
+);
 
 
 #ifdef __cplusplus
diff --git a/components/uic_dotdot_mqtt/zap-generated/include/dotdot_mqtt_supported_generated_commands.h b/components/uic_dotdot_mqtt/zap-generated/include/dotdot_mqtt_supported_generated_commands.h
index 4c1c15b4eb..7872bdcec3 100644
--- a/components/uic_dotdot_mqtt/zap-generated/include/dotdot_mqtt_supported_generated_commands.h
+++ b/components/uic_dotdot_mqtt/zap-generated/include/dotdot_mqtt_supported_generated_commands.h
@@ -1742,6 +1742,36 @@ void uic_mqtt_dotdot_unify_humidity_control_publish_supported_generated_commands
 );
 
 
+/**
+ * @brief Struct containing the list of commands for UnifySwitchColor
+ */
+typedef struct _uic_mqtt_dotdot_unify_switch_color_supported_commands_ {
+  bool set_color;
+  bool start_stop_change;
+  bool write_attributes;
+} uic_mqtt_dotdot_unify_switch_color_supported_commands_t;
+
+/**
+ * @brief Sends/Publishes a the SupportedGenerated commands for
+ * the UnifySwitchColor cluster for a UNID/Endpoint
+ *
+ * Publication will be made at the following topic
+ * ucl/by-unid/UNID/epID/UnifySwitchColor/SupportedGeneratedCommands
+ *
+ * @param unid      The UNID of the node on behalf of which the advertisment is made
+ * 
+ * @param endpoint  The Endpoint ID of the node on behalf of which the advertisment is made
+ * 
+ * @param command_list      Struct pointer with the fields value indicating if
+ *                          individual commands can be generated.
+ */
+void uic_mqtt_dotdot_unify_switch_color_publish_supported_generated_commands(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint,
+  const uic_mqtt_dotdot_unify_switch_color_supported_commands_t *command_list
+);
+
+
 
 #ifdef __cplusplus
 }
diff --git a/components/uic_dotdot_mqtt/zap-generated/src/dotdot_mqtt.cpp b/components/uic_dotdot_mqtt/zap-generated/src/dotdot_mqtt.cpp
index 2ad8e173db..0a2f0bbdb7 100644
--- a/components/uic_dotdot_mqtt/zap-generated/src/dotdot_mqtt.cpp
+++ b/components/uic_dotdot_mqtt/zap-generated/src/dotdot_mqtt.cpp
@@ -99777,6 +99777,1164 @@ sl_status_t uic_mqtt_dotdot_unify_humidity_control_init()
   return SL_STATUS_OK;
 }
 
+// Callbacks pointers
+static std::set<uic_mqtt_dotdot_unify_switch_color_set_color_callback_t> uic_mqtt_dotdot_unify_switch_color_set_color_callback;
+static std::set<uic_mqtt_dotdot_unify_switch_color_set_color_callback_t> uic_mqtt_dotdot_unify_switch_color_generated_set_color_callback;
+static std::set<uic_mqtt_dotdot_unify_switch_color_start_stop_change_callback_t> uic_mqtt_dotdot_unify_switch_color_start_stop_change_callback;
+static std::set<uic_mqtt_dotdot_unify_switch_color_start_stop_change_callback_t> uic_mqtt_dotdot_unify_switch_color_generated_start_stop_change_callback;
+static std::set<uic_mqtt_dotdot_unify_switch_color_write_attributes_callback_t> uic_mqtt_dotdot_unify_switch_color_write_attributes_callback;
+static std::set<uic_mqtt_dotdot_unify_switch_color_force_read_attributes_callback_t> uic_mqtt_dotdot_unify_switch_color_force_read_attributes_callback;
+
+// Callbacks setters
+void uic_mqtt_dotdot_unify_switch_color_set_color_callback_set(const uic_mqtt_dotdot_unify_switch_color_set_color_callback_t callback)
+{
+  if (callback != nullptr) {
+    uic_mqtt_dotdot_unify_switch_color_set_color_callback.insert(callback);
+  }
+}
+void uic_mqtt_dotdot_unify_switch_color_set_color_callback_unset(const uic_mqtt_dotdot_unify_switch_color_set_color_callback_t callback)
+{
+  uic_mqtt_dotdot_unify_switch_color_set_color_callback.erase(callback);
+}
+void uic_mqtt_dotdot_unify_switch_color_set_color_callback_clear()
+{
+  uic_mqtt_dotdot_unify_switch_color_set_color_callback.clear();
+}
+std::set<uic_mqtt_dotdot_unify_switch_color_set_color_callback_t>& get_uic_mqtt_dotdot_unify_switch_color_set_color_callback()
+{
+  return uic_mqtt_dotdot_unify_switch_color_set_color_callback;
+}
+
+void uic_mqtt_dotdot_unify_switch_color_generated_set_color_callback_set(const uic_mqtt_dotdot_unify_switch_color_set_color_callback_t callback)
+{
+  if (callback != nullptr) {
+    uic_mqtt_dotdot_unify_switch_color_generated_set_color_callback.insert(callback);
+  }
+}
+void uic_mqtt_dotdot_unify_switch_color_generated_set_color_callback_unset(const uic_mqtt_dotdot_unify_switch_color_set_color_callback_t callback)
+{
+  uic_mqtt_dotdot_unify_switch_color_generated_set_color_callback.erase(callback);
+}
+void uic_mqtt_dotdot_unify_switch_color_generated_set_color_callback_clear()
+{
+  uic_mqtt_dotdot_unify_switch_color_generated_set_color_callback.clear();
+}
+void uic_mqtt_dotdot_unify_switch_color_start_stop_change_callback_set(const uic_mqtt_dotdot_unify_switch_color_start_stop_change_callback_t callback)
+{
+  if (callback != nullptr) {
+    uic_mqtt_dotdot_unify_switch_color_start_stop_change_callback.insert(callback);
+  }
+}
+void uic_mqtt_dotdot_unify_switch_color_start_stop_change_callback_unset(const uic_mqtt_dotdot_unify_switch_color_start_stop_change_callback_t callback)
+{
+  uic_mqtt_dotdot_unify_switch_color_start_stop_change_callback.erase(callback);
+}
+void uic_mqtt_dotdot_unify_switch_color_start_stop_change_callback_clear()
+{
+  uic_mqtt_dotdot_unify_switch_color_start_stop_change_callback.clear();
+}
+std::set<uic_mqtt_dotdot_unify_switch_color_start_stop_change_callback_t>& get_uic_mqtt_dotdot_unify_switch_color_start_stop_change_callback()
+{
+  return uic_mqtt_dotdot_unify_switch_color_start_stop_change_callback;
+}
+
+void uic_mqtt_dotdot_unify_switch_color_generated_start_stop_change_callback_set(const uic_mqtt_dotdot_unify_switch_color_start_stop_change_callback_t callback)
+{
+  if (callback != nullptr) {
+    uic_mqtt_dotdot_unify_switch_color_generated_start_stop_change_callback.insert(callback);
+  }
+}
+void uic_mqtt_dotdot_unify_switch_color_generated_start_stop_change_callback_unset(const uic_mqtt_dotdot_unify_switch_color_start_stop_change_callback_t callback)
+{
+  uic_mqtt_dotdot_unify_switch_color_generated_start_stop_change_callback.erase(callback);
+}
+void uic_mqtt_dotdot_unify_switch_color_generated_start_stop_change_callback_clear()
+{
+  uic_mqtt_dotdot_unify_switch_color_generated_start_stop_change_callback.clear();
+}
+
+void uic_mqtt_dotdot_set_unify_switch_color_write_attributes_callback(
+  const uic_mqtt_dotdot_unify_switch_color_write_attributes_callback_t callback)
+{
+  if (callback != nullptr) {
+    uic_mqtt_dotdot_unify_switch_color_write_attributes_callback.insert(callback);
+  }
+}
+void uic_mqtt_dotdot_unset_unify_switch_color_write_attributes_callback(
+  const uic_mqtt_dotdot_unify_switch_color_write_attributes_callback_t callback)
+{
+  uic_mqtt_dotdot_unify_switch_color_write_attributes_callback.erase(callback);
+}
+void uic_mqtt_dotdot_clear_unify_switch_color_write_attributes_callbacks()
+{
+  uic_mqtt_dotdot_unify_switch_color_write_attributes_callback.clear();
+}
+std::set<uic_mqtt_dotdot_unify_switch_color_write_attributes_callback_t>& get_uic_mqtt_dotdot_unify_switch_color_write_attributes_callback()
+{
+  return uic_mqtt_dotdot_unify_switch_color_write_attributes_callback;
+}
+
+void uic_mqtt_dotdot_set_unify_switch_color_force_read_attributes_callback(
+  const uic_mqtt_dotdot_unify_switch_color_force_read_attributes_callback_t callback)
+{
+  if (callback != nullptr) {
+    uic_mqtt_dotdot_unify_switch_color_force_read_attributes_callback.insert(callback);
+  }
+}
+void uic_mqtt_dotdot_unset_unify_switch_color_force_read_attributes_callback(
+  const uic_mqtt_dotdot_unify_switch_color_force_read_attributes_callback_t callback)
+{
+  uic_mqtt_dotdot_unify_switch_color_force_read_attributes_callback.erase(callback);
+}
+void uic_mqtt_dotdot_clear_unify_switch_color_force_read_attributes_callbacks()
+{
+  uic_mqtt_dotdot_unify_switch_color_force_read_attributes_callback.clear();
+}
+
+
+// Callback function for incoming publications on ucl/by-unid/+/+/UnifySwitchColor/Commands/SetColor
+void uic_mqtt_dotdot_on_unify_switch_color_set_color(
+  const char *topic,
+  const char *message,
+  const size_t message_length)
+{
+  if (message_length == 0 || (uic_mqtt_dotdot_unify_switch_color_set_color_callback.empty())) {
+    return;
+  }
+
+  std::string unid;
+  uint8_t endpoint = 0; // Default value for endpoint-less topics.
+  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
+    sl_log_debug(LOG_TAG,
+                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
+                topic);
+    return;
+  }
+
+  uint8_t color_component_id = {};
+  uint8_t value = {};
+  uint32_t duration = {};
+
+
+  nlohmann::json jsn;
+  try {
+    jsn = nlohmann::json::parse(std::string(message));
+
+  
+    uic_mqtt_dotdot_parse_unify_switch_color_set_color(
+      jsn,
+      color_component_id,
+
+      value,
+
+      duration
+      );
+
+  } catch (const nlohmann::json::parse_error& e) {
+    // Catch JSON object field parsing errors
+    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "UnifySwitchColor", "SetColor");
+    return;
+  } catch (const nlohmann::json::exception& e) {
+    // Catch JSON object field parsing errors
+    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "UnifySwitchColor", "SetColor", e.what());
+    return;
+  } catch (const std::exception& e) {
+    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "UnifySwitchColor", "SetColor", "");
+    return;
+  }
+
+
+
+  for (const auto& callback: uic_mqtt_dotdot_unify_switch_color_set_color_callback){
+    callback(
+      static_cast<dotdot_unid_t>(unid.c_str()),
+      endpoint,
+      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
+      color_component_id,
+  
+      value,
+  
+      duration
+  
+    );
+  }
+
+}
+
+// Callback function for incoming publications on ucl/by-unid/+/+/UnifySwitchColor/GeneratedCommands/SetColor
+static void uic_mqtt_dotdot_on_generated_unify_switch_color_set_color(
+  const char *topic,
+  const char *message,
+  const size_t message_length)
+{
+  if (message_length == 0 || (uic_mqtt_dotdot_unify_switch_color_generated_set_color_callback.empty())) {
+    return;
+  }
+
+  std::string unid;
+  uint8_t endpoint = 0; // Default value for endpoint-less topics.
+  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
+    sl_log_debug(LOG_TAG,
+                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
+                topic);
+    return;
+  }
+
+  uint8_t color_component_id = {};
+  uint8_t value = {};
+  uint32_t duration = {};
+
+
+  nlohmann::json jsn;
+  try {
+    jsn = nlohmann::json::parse(std::string(message));
+
+  
+    uic_mqtt_dotdot_parse_unify_switch_color_set_color(
+      jsn,
+      color_component_id,
+
+      value,
+
+      duration
+      );
+
+  } catch (const nlohmann::json::parse_error& e) {
+    // Catch JSON object field parsing errors
+    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "UnifySwitchColor", "SetColor");
+    return;
+  } catch (const nlohmann::json::exception& e) {
+    // Catch JSON object field parsing errors
+    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "UnifySwitchColor", "SetColor", e.what());
+    return;
+  } catch (const std::exception& e) {
+    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "UnifySwitchColor", "SetColor", "");
+    return;
+  }
+
+
+
+
+  for (const auto& callback: uic_mqtt_dotdot_unify_switch_color_generated_set_color_callback){
+    callback(
+      static_cast<dotdot_unid_t>(unid.c_str()),
+      endpoint,
+      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
+      color_component_id,
+  
+      value,
+  
+      duration
+  
+    );
+  }
+}
+
+
+// Callback function for incoming publications on ucl/by-unid/+/+/UnifySwitchColor/Commands/StartStopChange
+void uic_mqtt_dotdot_on_unify_switch_color_start_stop_change(
+  const char *topic,
+  const char *message,
+  const size_t message_length)
+{
+  if (message_length == 0 || (uic_mqtt_dotdot_unify_switch_color_start_stop_change_callback.empty())) {
+    return;
+  }
+
+  std::string unid;
+  uint8_t endpoint = 0; // Default value for endpoint-less topics.
+  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
+    sl_log_debug(LOG_TAG,
+                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
+                topic);
+    return;
+  }
+
+  bool start_stop = {};
+  bool up_down = {};
+  bool ignor_start_level = {};
+  uint8_t color_component_id = {};
+  uint8_t start_level = {};
+  uint32_t duration = {};
+
+
+  nlohmann::json jsn;
+  try {
+    jsn = nlohmann::json::parse(std::string(message));
+
+  
+    uic_mqtt_dotdot_parse_unify_switch_color_start_stop_change(
+      jsn,
+      start_stop,
+
+      up_down,
+
+      ignor_start_level,
+
+      color_component_id,
+
+      start_level,
+
+      duration
+      );
+
+  } catch (const nlohmann::json::parse_error& e) {
+    // Catch JSON object field parsing errors
+    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "UnifySwitchColor", "StartStopChange");
+    return;
+  } catch (const nlohmann::json::exception& e) {
+    // Catch JSON object field parsing errors
+    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "UnifySwitchColor", "StartStopChange", e.what());
+    return;
+  } catch (const std::exception& e) {
+    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "UnifySwitchColor", "StartStopChange", "");
+    return;
+  }
+
+
+
+  for (const auto& callback: uic_mqtt_dotdot_unify_switch_color_start_stop_change_callback){
+    callback(
+      static_cast<dotdot_unid_t>(unid.c_str()),
+      endpoint,
+      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
+      start_stop,
+  
+      up_down,
+  
+      ignor_start_level,
+  
+      color_component_id,
+  
+      start_level,
+  
+      duration
+  
+    );
+  }
+
+}
+
+// Callback function for incoming publications on ucl/by-unid/+/+/UnifySwitchColor/GeneratedCommands/StartStopChange
+static void uic_mqtt_dotdot_on_generated_unify_switch_color_start_stop_change(
+  const char *topic,
+  const char *message,
+  const size_t message_length)
+{
+  if (message_length == 0 || (uic_mqtt_dotdot_unify_switch_color_generated_start_stop_change_callback.empty())) {
+    return;
+  }
+
+  std::string unid;
+  uint8_t endpoint = 0; // Default value for endpoint-less topics.
+  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
+    sl_log_debug(LOG_TAG,
+                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
+                topic);
+    return;
+  }
+
+  bool start_stop = {};
+  bool up_down = {};
+  bool ignor_start_level = {};
+  uint8_t color_component_id = {};
+  uint8_t start_level = {};
+  uint32_t duration = {};
+
+
+  nlohmann::json jsn;
+  try {
+    jsn = nlohmann::json::parse(std::string(message));
+
+  
+    uic_mqtt_dotdot_parse_unify_switch_color_start_stop_change(
+      jsn,
+      start_stop,
+
+      up_down,
+
+      ignor_start_level,
+
+      color_component_id,
+
+      start_level,
+
+      duration
+      );
+
+  } catch (const nlohmann::json::parse_error& e) {
+    // Catch JSON object field parsing errors
+    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "UnifySwitchColor", "StartStopChange");
+    return;
+  } catch (const nlohmann::json::exception& e) {
+    // Catch JSON object field parsing errors
+    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "UnifySwitchColor", "StartStopChange", e.what());
+    return;
+  } catch (const std::exception& e) {
+    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "UnifySwitchColor", "StartStopChange", "");
+    return;
+  }
+
+
+
+
+  for (const auto& callback: uic_mqtt_dotdot_unify_switch_color_generated_start_stop_change_callback){
+    callback(
+      static_cast<dotdot_unid_t>(unid.c_str()),
+      endpoint,
+      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
+      start_stop,
+  
+      up_down,
+  
+      ignor_start_level,
+  
+      color_component_id,
+  
+      start_level,
+  
+      duration
+  
+    );
+  }
+}
+
+
+// Callback function for incoming publications on ucl/by-unid/+/+/UnifySwitchColor/Commands/WriteAttributes
+void uic_mqtt_dotdot_on_unify_switch_color_WriteAttributes(
+  const char *topic,
+  const char *message,
+  const size_t message_length)
+{
+  if (uic_mqtt_dotdot_unify_switch_color_write_attributes_callback.empty()) {
+    return;
+  }
+
+  if (message_length == 0) {
+    return;
+  }
+
+  std::string unid;
+  uint8_t endpoint = 0; // Default value for endpoint-less topics.
+  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
+    sl_log_debug(LOG_TAG,
+                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
+                topic);
+    return;
+  }
+
+  uic_mqtt_dotdot_unify_switch_color_state_t new_state = {};
+  uic_mqtt_dotdot_unify_switch_color_updated_state_t new_updated_state = {};
+
+
+  nlohmann::json jsn;
+  try {
+    jsn = nlohmann::json::parse(std::string(message));
+
+    uic_mqtt_dotdot_parse_unify_switch_color_write_attributes(
+      jsn,
+      new_state,
+      new_updated_state
+    );
+  } catch (const nlohmann::json::parse_error& e) {
+    // Catch JSON object field parsing errors
+    sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "UnifySwitchColor", "WriteAttributes");
+    return;
+  } catch (const nlohmann::json::exception& e) {
+    // Catch JSON object field parsing errors
+    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "UnifySwitchColor", "WriteAttributes", e.what());
+    return;
+  } catch (const std::exception& e) {
+    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "UnifySwitchColor", "WriteAttributes", "");
+    return;
+  }
+
+  for (const auto& callback: uic_mqtt_dotdot_unify_switch_color_write_attributes_callback){
+    callback(
+      static_cast<dotdot_unid_t>(unid.c_str()),
+      endpoint,
+      UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
+      new_state,
+      new_updated_state
+    );
+  }
+
+}
+
+static void uic_mqtt_dotdot_on_unify_switch_color_force_read_attributes(
+  const char *topic,
+  const char *message,
+  const size_t message_length)
+{
+  uint8_t endpoint = 0;
+  std::string unid;
+
+  if ((message_length == 0) || (uic_mqtt_dotdot_unify_switch_color_force_read_attributes_callback.empty())) {
+    return;
+  }
+
+  if(! uic_dotdot_mqtt::parse_topic(topic, unid, endpoint)) {
+    sl_log_debug(LOG_TAG,
+                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
+                topic);
+    return;
+  }
+
+  try {
+    uic_mqtt_dotdot_unify_switch_color_updated_state_t force_update = {0};
+    bool trigger_handler = false;
+
+    nlohmann::json jsn = nlohmann::json::parse(std::string(message));
+    std::vector<std::string> attributes = jsn["value"].get<std::vector<std::string>>();
+
+    // Assume all attributes to be read on empty array received
+    if (attributes.size() == 0) {
+      force_update.warm_white = true;
+      force_update.cold_white = true;
+      force_update.red = true;
+      force_update.green = true;
+      force_update.blue = true;
+      force_update.amber = true;
+      force_update.cyan = true;
+      force_update.purple = true;
+      trigger_handler = true;
+    } else {
+      std::unordered_map<std::string, bool *> supported_attrs = {
+        {"WarmWhite", &force_update.warm_white },
+        {"ColdWhite", &force_update.cold_white },
+        {"Red", &force_update.red },
+        {"Green", &force_update.green },
+        {"Blue", &force_update.blue },
+        {"Amber", &force_update.amber },
+        {"Cyan", &force_update.cyan },
+        {"Purple", &force_update.purple },
+      };
+
+      for (auto& attribute : attributes) {
+        auto found_attr = supported_attrs.find(attribute);
+        if (found_attr != supported_attrs.end()) {
+          *(found_attr->second) = true;
+          trigger_handler = true;
+        }
+      }
+    }
+
+    if (trigger_handler == true) {
+      for (const auto& callback: uic_mqtt_dotdot_unify_switch_color_force_read_attributes_callback) {
+        callback(
+          static_cast<dotdot_unid_t>(unid.c_str()),
+          endpoint,
+          UIC_MQTT_DOTDOT_CALLBACK_TYPE_NORMAL,
+          force_update
+        );
+      }
+    }
+  } catch (...) {
+    sl_log_debug(LOG_TAG, "UnifySwitchColor/Commands/ForceReadAttributes: Unable to parse JSON payload");
+    return;
+  }
+}
+
+sl_status_t uic_mqtt_dotdot_unify_switch_color_warm_white_publish(
+  const char *base_topic,
+  uint8_t value,
+  uic_mqtt_dotdot_attribute_publish_type_t publish_type
+)
+{
+  nlohmann::json jsn;
+
+  // This is a single value
+
+  if (true == uic_dotdot_has_attribute_value_a_name(65441,0,value)) {
+    jsn["value"] = uic_dotdot_get_attribute_value_name(65441,0,value);
+  }else{
+    jsn["value"] = value;
+  }
+
+
+  std::string payload_str;
+  try {
+    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
+    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
+  } catch (const nlohmann::json::exception& e) {
+    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "UnifySwitchColor/Attributes/WarmWhite", e.what());
+    return SL_STATUS_OK;
+  }
+
+
+  std::string topic = std::string(base_topic) + "/UnifySwitchColor/Attributes/WarmWhite";
+  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
+  {
+    std::string topic_desired = topic + "/Desired";
+    uic_mqtt_publish(topic_desired.c_str(),
+              payload_str.c_str(),
+              payload_str.length(),
+              true);
+  }
+  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
+  {
+    std::string topic_reported = topic + "/Reported";
+    uic_mqtt_publish(topic_reported.c_str(),
+              payload_str.c_str(),
+              payload_str.length(),
+              true);
+  }
+  return SL_STATUS_OK;
+}
+
+sl_status_t uic_mqtt_dotdot_unify_switch_color_warm_white_unretain(
+  const char *base_topic,
+  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
+{
+  // clang-format on
+  std::string topic
+    = std::string(base_topic)
+      + "/UnifySwitchColor/Attributes/WarmWhite";
+
+  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
+      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
+    std::string topic_desired = topic + "/Desired";
+    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
+  }
+  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
+      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
+    std::string topic_reported = topic + "/Reported";
+    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
+  }
+  return SL_STATUS_OK;
+}
+// clang-format off
+
+sl_status_t uic_mqtt_dotdot_unify_switch_color_cold_white_publish(
+  const char *base_topic,
+  uint8_t value,
+  uic_mqtt_dotdot_attribute_publish_type_t publish_type
+)
+{
+  nlohmann::json jsn;
+
+  // This is a single value
+
+  if (true == uic_dotdot_has_attribute_value_a_name(65441,1,value)) {
+    jsn["value"] = uic_dotdot_get_attribute_value_name(65441,1,value);
+  }else{
+    jsn["value"] = value;
+  }
+
+
+  std::string payload_str;
+  try {
+    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
+    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
+  } catch (const nlohmann::json::exception& e) {
+    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "UnifySwitchColor/Attributes/ColdWhite", e.what());
+    return SL_STATUS_OK;
+  }
+
+
+  std::string topic = std::string(base_topic) + "/UnifySwitchColor/Attributes/ColdWhite";
+  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
+  {
+    std::string topic_desired = topic + "/Desired";
+    uic_mqtt_publish(topic_desired.c_str(),
+              payload_str.c_str(),
+              payload_str.length(),
+              true);
+  }
+  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
+  {
+    std::string topic_reported = topic + "/Reported";
+    uic_mqtt_publish(topic_reported.c_str(),
+              payload_str.c_str(),
+              payload_str.length(),
+              true);
+  }
+  return SL_STATUS_OK;
+}
+
+sl_status_t uic_mqtt_dotdot_unify_switch_color_cold_white_unretain(
+  const char *base_topic,
+  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
+{
+  // clang-format on
+  std::string topic
+    = std::string(base_topic)
+      + "/UnifySwitchColor/Attributes/ColdWhite";
+
+  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
+      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
+    std::string topic_desired = topic + "/Desired";
+    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
+  }
+  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
+      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
+    std::string topic_reported = topic + "/Reported";
+    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
+  }
+  return SL_STATUS_OK;
+}
+// clang-format off
+
+sl_status_t uic_mqtt_dotdot_unify_switch_color_red_publish(
+  const char *base_topic,
+  uint8_t value,
+  uic_mqtt_dotdot_attribute_publish_type_t publish_type
+)
+{
+  nlohmann::json jsn;
+
+  // This is a single value
+
+  if (true == uic_dotdot_has_attribute_value_a_name(65441,2,value)) {
+    jsn["value"] = uic_dotdot_get_attribute_value_name(65441,2,value);
+  }else{
+    jsn["value"] = value;
+  }
+
+
+  std::string payload_str;
+  try {
+    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
+    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
+  } catch (const nlohmann::json::exception& e) {
+    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "UnifySwitchColor/Attributes/Red", e.what());
+    return SL_STATUS_OK;
+  }
+
+
+  std::string topic = std::string(base_topic) + "/UnifySwitchColor/Attributes/Red";
+  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
+  {
+    std::string topic_desired = topic + "/Desired";
+    uic_mqtt_publish(topic_desired.c_str(),
+              payload_str.c_str(),
+              payload_str.length(),
+              true);
+  }
+  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
+  {
+    std::string topic_reported = topic + "/Reported";
+    uic_mqtt_publish(topic_reported.c_str(),
+              payload_str.c_str(),
+              payload_str.length(),
+              true);
+  }
+  return SL_STATUS_OK;
+}
+
+sl_status_t uic_mqtt_dotdot_unify_switch_color_red_unretain(
+  const char *base_topic,
+  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
+{
+  // clang-format on
+  std::string topic
+    = std::string(base_topic)
+      + "/UnifySwitchColor/Attributes/Red";
+
+  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
+      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
+    std::string topic_desired = topic + "/Desired";
+    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
+  }
+  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
+      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
+    std::string topic_reported = topic + "/Reported";
+    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
+  }
+  return SL_STATUS_OK;
+}
+// clang-format off
+
+sl_status_t uic_mqtt_dotdot_unify_switch_color_green_publish(
+  const char *base_topic,
+  uint8_t value,
+  uic_mqtt_dotdot_attribute_publish_type_t publish_type
+)
+{
+  nlohmann::json jsn;
+
+  // This is a single value
+
+  if (true == uic_dotdot_has_attribute_value_a_name(65441,3,value)) {
+    jsn["value"] = uic_dotdot_get_attribute_value_name(65441,3,value);
+  }else{
+    jsn["value"] = value;
+  }
+
+
+  std::string payload_str;
+  try {
+    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
+    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
+  } catch (const nlohmann::json::exception& e) {
+    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "UnifySwitchColor/Attributes/Green", e.what());
+    return SL_STATUS_OK;
+  }
+
+
+  std::string topic = std::string(base_topic) + "/UnifySwitchColor/Attributes/Green";
+  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
+  {
+    std::string topic_desired = topic + "/Desired";
+    uic_mqtt_publish(topic_desired.c_str(),
+              payload_str.c_str(),
+              payload_str.length(),
+              true);
+  }
+  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
+  {
+    std::string topic_reported = topic + "/Reported";
+    uic_mqtt_publish(topic_reported.c_str(),
+              payload_str.c_str(),
+              payload_str.length(),
+              true);
+  }
+  return SL_STATUS_OK;
+}
+
+sl_status_t uic_mqtt_dotdot_unify_switch_color_green_unretain(
+  const char *base_topic,
+  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
+{
+  // clang-format on
+  std::string topic
+    = std::string(base_topic)
+      + "/UnifySwitchColor/Attributes/Green";
+
+  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
+      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
+    std::string topic_desired = topic + "/Desired";
+    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
+  }
+  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
+      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
+    std::string topic_reported = topic + "/Reported";
+    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
+  }
+  return SL_STATUS_OK;
+}
+// clang-format off
+
+sl_status_t uic_mqtt_dotdot_unify_switch_color_blue_publish(
+  const char *base_topic,
+  uint8_t value,
+  uic_mqtt_dotdot_attribute_publish_type_t publish_type
+)
+{
+  nlohmann::json jsn;
+
+  // This is a single value
+
+  if (true == uic_dotdot_has_attribute_value_a_name(65441,4,value)) {
+    jsn["value"] = uic_dotdot_get_attribute_value_name(65441,4,value);
+  }else{
+    jsn["value"] = value;
+  }
+
+
+  std::string payload_str;
+  try {
+    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
+    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
+  } catch (const nlohmann::json::exception& e) {
+    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "UnifySwitchColor/Attributes/Blue", e.what());
+    return SL_STATUS_OK;
+  }
+
+
+  std::string topic = std::string(base_topic) + "/UnifySwitchColor/Attributes/Blue";
+  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
+  {
+    std::string topic_desired = topic + "/Desired";
+    uic_mqtt_publish(topic_desired.c_str(),
+              payload_str.c_str(),
+              payload_str.length(),
+              true);
+  }
+  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
+  {
+    std::string topic_reported = topic + "/Reported";
+    uic_mqtt_publish(topic_reported.c_str(),
+              payload_str.c_str(),
+              payload_str.length(),
+              true);
+  }
+  return SL_STATUS_OK;
+}
+
+sl_status_t uic_mqtt_dotdot_unify_switch_color_blue_unretain(
+  const char *base_topic,
+  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
+{
+  // clang-format on
+  std::string topic
+    = std::string(base_topic)
+      + "/UnifySwitchColor/Attributes/Blue";
+
+  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
+      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
+    std::string topic_desired = topic + "/Desired";
+    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
+  }
+  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
+      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
+    std::string topic_reported = topic + "/Reported";
+    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
+  }
+  return SL_STATUS_OK;
+}
+// clang-format off
+
+sl_status_t uic_mqtt_dotdot_unify_switch_color_amber_publish(
+  const char *base_topic,
+  uint8_t value,
+  uic_mqtt_dotdot_attribute_publish_type_t publish_type
+)
+{
+  nlohmann::json jsn;
+
+  // This is a single value
+
+  if (true == uic_dotdot_has_attribute_value_a_name(65441,5,value)) {
+    jsn["value"] = uic_dotdot_get_attribute_value_name(65441,5,value);
+  }else{
+    jsn["value"] = value;
+  }
+
+
+  std::string payload_str;
+  try {
+    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
+    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
+  } catch (const nlohmann::json::exception& e) {
+    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "UnifySwitchColor/Attributes/Amber", e.what());
+    return SL_STATUS_OK;
+  }
+
+
+  std::string topic = std::string(base_topic) + "/UnifySwitchColor/Attributes/Amber";
+  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
+  {
+    std::string topic_desired = topic + "/Desired";
+    uic_mqtt_publish(topic_desired.c_str(),
+              payload_str.c_str(),
+              payload_str.length(),
+              true);
+  }
+  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
+  {
+    std::string topic_reported = topic + "/Reported";
+    uic_mqtt_publish(topic_reported.c_str(),
+              payload_str.c_str(),
+              payload_str.length(),
+              true);
+  }
+  return SL_STATUS_OK;
+}
+
+sl_status_t uic_mqtt_dotdot_unify_switch_color_amber_unretain(
+  const char *base_topic,
+  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
+{
+  // clang-format on
+  std::string topic
+    = std::string(base_topic)
+      + "/UnifySwitchColor/Attributes/Amber";
+
+  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
+      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
+    std::string topic_desired = topic + "/Desired";
+    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
+  }
+  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
+      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
+    std::string topic_reported = topic + "/Reported";
+    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
+  }
+  return SL_STATUS_OK;
+}
+// clang-format off
+
+sl_status_t uic_mqtt_dotdot_unify_switch_color_cyan_publish(
+  const char *base_topic,
+  uint8_t value,
+  uic_mqtt_dotdot_attribute_publish_type_t publish_type
+)
+{
+  nlohmann::json jsn;
+
+  // This is a single value
+
+  if (true == uic_dotdot_has_attribute_value_a_name(65441,6,value)) {
+    jsn["value"] = uic_dotdot_get_attribute_value_name(65441,6,value);
+  }else{
+    jsn["value"] = value;
+  }
+
+
+  std::string payload_str;
+  try {
+    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
+    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
+  } catch (const nlohmann::json::exception& e) {
+    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "UnifySwitchColor/Attributes/Cyan", e.what());
+    return SL_STATUS_OK;
+  }
+
+
+  std::string topic = std::string(base_topic) + "/UnifySwitchColor/Attributes/Cyan";
+  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
+  {
+    std::string topic_desired = topic + "/Desired";
+    uic_mqtt_publish(topic_desired.c_str(),
+              payload_str.c_str(),
+              payload_str.length(),
+              true);
+  }
+  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
+  {
+    std::string topic_reported = topic + "/Reported";
+    uic_mqtt_publish(topic_reported.c_str(),
+              payload_str.c_str(),
+              payload_str.length(),
+              true);
+  }
+  return SL_STATUS_OK;
+}
+
+sl_status_t uic_mqtt_dotdot_unify_switch_color_cyan_unretain(
+  const char *base_topic,
+  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
+{
+  // clang-format on
+  std::string topic
+    = std::string(base_topic)
+      + "/UnifySwitchColor/Attributes/Cyan";
+
+  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
+      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
+    std::string topic_desired = topic + "/Desired";
+    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
+  }
+  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
+      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
+    std::string topic_reported = topic + "/Reported";
+    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
+  }
+  return SL_STATUS_OK;
+}
+// clang-format off
+
+sl_status_t uic_mqtt_dotdot_unify_switch_color_purple_publish(
+  const char *base_topic,
+  uint8_t value,
+  uic_mqtt_dotdot_attribute_publish_type_t publish_type
+)
+{
+  nlohmann::json jsn;
+
+  // This is a single value
+
+  if (true == uic_dotdot_has_attribute_value_a_name(65441,7,value)) {
+    jsn["value"] = uic_dotdot_get_attribute_value_name(65441,7,value);
+  }else{
+    jsn["value"] = value;
+  }
+
+
+  std::string payload_str;
+  try {
+    // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
+    payload_str = jsn.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
+  } catch (const nlohmann::json::exception& e) {
+    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "UnifySwitchColor/Attributes/Purple", e.what());
+    return SL_STATUS_OK;
+  }
+
+
+  std::string topic = std::string(base_topic) + "/UnifySwitchColor/Attributes/Purple";
+  if (publish_type & UCL_MQTT_PUBLISH_TYPE_DESIRED)
+  {
+    std::string topic_desired = topic + "/Desired";
+    uic_mqtt_publish(topic_desired.c_str(),
+              payload_str.c_str(),
+              payload_str.length(),
+              true);
+  }
+  if (publish_type & UCL_MQTT_PUBLISH_TYPE_REPORTED)
+  {
+    std::string topic_reported = topic + "/Reported";
+    uic_mqtt_publish(topic_reported.c_str(),
+              payload_str.c_str(),
+              payload_str.length(),
+              true);
+  }
+  return SL_STATUS_OK;
+}
+
+sl_status_t uic_mqtt_dotdot_unify_switch_color_purple_unretain(
+  const char *base_topic,
+  uic_mqtt_dotdot_attribute_publish_type_t publish_type)
+{
+  // clang-format on
+  std::string topic
+    = std::string(base_topic)
+      + "/UnifySwitchColor/Attributes/Purple";
+
+  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_DESIRED)
+      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
+    std::string topic_desired = topic + "/Desired";
+    uic_mqtt_publish(topic_desired.c_str(), NULL, 0, true);
+  }
+  if ((publish_type == UCL_MQTT_PUBLISH_TYPE_REPORTED)
+      || (publish_type == UCL_MQTT_PUBLISH_TYPE_ALL)) {
+    std::string topic_reported = topic + "/Reported";
+    uic_mqtt_publish(topic_reported.c_str(), NULL, 0, true);
+  }
+  return SL_STATUS_OK;
+}
+// clang-format off
+
+
+sl_status_t uic_mqtt_dotdot_unify_switch_color_init()
+{
+  std::string base_topic = "ucl/by-unid/+/+/";
+
+  std::string subscription_topic;
+  if(!uic_mqtt_dotdot_unify_switch_color_write_attributes_callback.empty()) {
+    subscription_topic = base_topic + "UnifySwitchColor/Commands/WriteAttributes";
+    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_unify_switch_color_WriteAttributes);
+  }
+
+  if(!uic_mqtt_dotdot_unify_switch_color_force_read_attributes_callback.empty()) {
+    subscription_topic = base_topic + "UnifySwitchColor/Commands/ForceReadAttributes";
+    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_unify_switch_color_force_read_attributes);
+  }
+  if (!uic_mqtt_dotdot_unify_switch_color_set_color_callback.empty()) {
+    subscription_topic = base_topic + "UnifySwitchColor/Commands/SetColor";
+    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_unify_switch_color_set_color);
+  }
+  if (!uic_mqtt_dotdot_unify_switch_color_generated_set_color_callback.empty()) {
+    subscription_topic = base_topic + "UnifySwitchColor/GeneratedCommands/SetColor";
+    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_unify_switch_color_set_color);
+  }
+  if (!uic_mqtt_dotdot_unify_switch_color_start_stop_change_callback.empty()) {
+    subscription_topic = base_topic + "UnifySwitchColor/Commands/StartStopChange";
+    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_unify_switch_color_start_stop_change);
+  }
+  if (!uic_mqtt_dotdot_unify_switch_color_generated_start_stop_change_callback.empty()) {
+    subscription_topic = base_topic + "UnifySwitchColor/GeneratedCommands/StartStopChange";
+    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_generated_unify_switch_color_start_stop_change);
+  }
+
+  // Init the attributes for that cluster
+  uic_mqtt_dotdot_unify_switch_color_attributes_init();
+
+  uic_mqtt_dotdot_by_group_unify_switch_color_init();
+
+  return SL_STATUS_OK;
+}
+
 
 sl_status_t uic_mqtt_dotdot_init() {
 
@@ -99998,6 +101156,10 @@ sl_status_t uic_mqtt_dotdot_init() {
     status_flag = uic_mqtt_dotdot_unify_humidity_control_init();
   }
 
+  if (status_flag == SL_STATUS_OK) {
+    status_flag = uic_mqtt_dotdot_unify_switch_color_init();
+  }
+
 
   return status_flag;
 }
@@ -100061,6 +101223,7 @@ void uic_mqtt_dotdot_publish_supported_commands(
   uic_mqtt_dotdot_unify_fan_control_publish_supported_commands(unid, endpoint_id);
   uic_mqtt_dotdot_unify_thermostat_publish_supported_commands(unid, endpoint_id);
   uic_mqtt_dotdot_unify_humidity_control_publish_supported_commands(unid, endpoint_id);
+  uic_mqtt_dotdot_unify_switch_color_publish_supported_commands(unid, endpoint_id);
 }
 
 void uic_mqtt_dotdot_publish_empty_supported_commands(
@@ -100121,6 +101284,7 @@ void uic_mqtt_dotdot_publish_empty_supported_commands(
   uic_mqtt_dotdot_unify_fan_control_publish_empty_supported_commands(unid, endpoint_id);
   uic_mqtt_dotdot_unify_thermostat_publish_empty_supported_commands(unid, endpoint_id);
   uic_mqtt_dotdot_unify_humidity_control_publish_empty_supported_commands(unid, endpoint_id);
+  uic_mqtt_dotdot_unify_switch_color_publish_empty_supported_commands(unid, endpoint_id);
 }
 
 // Publishing Cluster Revision for Basic Cluster
@@ -114499,6 +115663,232 @@ void uic_mqtt_dotdot_unify_humidity_control_publish_empty_supported_commands(
   }
 }
 
+// Publishing Cluster Revision for UnifySwitchColor Cluster
+void uic_mqtt_dotdot_unify_switch_color_publish_cluster_revision(const char* base_topic, uint16_t value)
+{
+  std::string cluster_topic = std::string(base_topic) + "/UnifySwitchColor/Attributes/ClusterRevision";
+  // Publish Desired
+  std::string pub_topic_des = cluster_topic + "/Desired";
+  std::string payload = std::string(R"({"value": )")
+    + std::to_string(value) + std::string("}");
+  uic_mqtt_publish(pub_topic_des.c_str(),
+                    payload.c_str(),
+                    payload.size(),
+                    true);
+  // Publish Reported
+  std::string pub_topic_rep = cluster_topic + "/Reported";
+  uic_mqtt_publish(pub_topic_rep.c_str(),
+                    payload.c_str(),
+                    payload.size(),
+                    true);
+}
+
+// Unretain Cluster Revision for UnifySwitchColor Cluster
+void uic_mqtt_dotdot_unify_switch_color_unretain_cluster_revision(const char* base_topic)
+{
+  // clang-format on
+  std::string cluster_topic
+    = std::string(base_topic)
+      + "/UnifySwitchColor/Attributes/ClusterRevision";
+  // Publish Desired
+  std::string desired_topic = cluster_topic + "/Desired";
+  uic_mqtt_publish(desired_topic.c_str(), NULL, 0, true);
+  // Publish Reported
+  std::string reported_topic = cluster_topic + "/Reported";
+  uic_mqtt_publish(reported_topic.c_str(), NULL, 0, true);
+  // clang-format off
+}
+
+static inline bool uic_mqtt_dotdot_unify_switch_color_set_color_is_supported(
+  const dotdot_unid_t unid,
+  dotdot_endpoint_id_t endpoint_id)
+{
+    uint8_t color_component_id_value;
+    memset(&color_component_id_value, 0x00, sizeof(color_component_id_value));
+    uint8_t value_value;
+    memset(&value_value, 0x00, sizeof(value_value));
+    uint32_t duration_value;
+    memset(&duration_value, 0x00, sizeof(duration_value));
+    for (const auto& callback: uic_mqtt_dotdot_unify_switch_color_set_color_callback) {
+      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
+    ,
+        color_component_id_value,
+    
+        value_value,
+    
+        duration_value
+    
+        ) == SL_STATUS_OK) {
+      return true;
+    }
+  }
+
+  return false;
+}
+static inline bool uic_mqtt_dotdot_unify_switch_color_start_stop_change_is_supported(
+  const dotdot_unid_t unid,
+  dotdot_endpoint_id_t endpoint_id)
+{
+    bool start_stop_value;
+    memset(&start_stop_value, 0x00, sizeof(start_stop_value));
+    bool up_down_value;
+    memset(&up_down_value, 0x00, sizeof(up_down_value));
+    bool ignor_start_level_value;
+    memset(&ignor_start_level_value, 0x00, sizeof(ignor_start_level_value));
+    uint8_t color_component_id_value;
+    memset(&color_component_id_value, 0x00, sizeof(color_component_id_value));
+    uint8_t start_level_value;
+    memset(&start_level_value, 0x00, sizeof(start_level_value));
+    uint32_t duration_value;
+    memset(&duration_value, 0x00, sizeof(duration_value));
+    for (const auto& callback: uic_mqtt_dotdot_unify_switch_color_start_stop_change_callback) {
+      if (callback( unid, endpoint_id, UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
+    ,
+        start_stop_value,
+    
+        up_down_value,
+    
+        ignor_start_level_value,
+    
+        color_component_id_value,
+    
+        start_level_value,
+    
+        duration_value
+    
+        ) == SL_STATUS_OK) {
+      return true;
+    }
+  }
+
+  return false;
+}
+
+static inline bool uic_mqtt_dotdot_unify_switch_color_write_attributes_is_supported(
+  const dotdot_unid_t unid,
+  dotdot_endpoint_id_t endpoint_id)
+{
+  for (const auto& callback: uic_mqtt_dotdot_unify_switch_color_write_attributes_callback) {
+    uic_mqtt_dotdot_unify_switch_color_state_t unify_switch_color_new_state = {};
+    uic_mqtt_dotdot_unify_switch_color_updated_state_t unify_switch_color_new_updated_state = {};
+
+    if (callback(
+          unid,
+          endpoint_id,
+          UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
+          unify_switch_color_new_state,
+          unify_switch_color_new_updated_state
+      ) == SL_STATUS_OK) {
+      return true;
+    }
+  }
+  return false;
+}
+
+static inline bool uic_mqtt_dotdot_unify_switch_color_force_read_attributes_is_supported(
+  const dotdot_unid_t unid,
+  dotdot_endpoint_id_t endpoint_id)
+{
+  for (const auto& callback: uic_mqtt_dotdot_unify_switch_color_force_read_attributes_callback) {
+    uic_mqtt_dotdot_unify_switch_color_updated_state_t unify_switch_color_force_update = {0};
+    if (callback(
+          unid,
+          endpoint_id,
+          UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK,
+          unify_switch_color_force_update
+      ) == SL_STATUS_OK) {
+      return true;
+    }
+  }
+  return false;
+}
+
+// Publishing Supported Commands for UnifySwitchColor Cluster
+void uic_mqtt_dotdot_unify_switch_color_publish_supported_commands(
+  const dotdot_unid_t unid,
+  dotdot_endpoint_id_t endpoint_id)
+{
+  std::stringstream ss;
+  bool first_command = true;
+  ss.str("");
+
+  // check if there is callback for each command
+  if (uic_mqtt_dotdot_unify_switch_color_set_color_is_supported(unid, endpoint_id)) {
+    if (first_command == false) {
+      ss << ", ";
+    }
+    first_command = false;
+    ss << R"("SetColor")";
+  }
+  if (uic_mqtt_dotdot_unify_switch_color_start_stop_change_is_supported(unid, endpoint_id)) {
+    if (first_command == false) {
+      ss << ", ";
+    }
+    first_command = false;
+    ss << R"("StartStopChange")";
+  }
+
+  // Check for a WriteAttributes Callback
+  if(uic_mqtt_dotdot_unify_switch_color_write_attributes_is_supported(unid, endpoint_id)) {
+    if (first_command == false) {
+      ss << ", ";
+    }
+    first_command = false;
+    ss << R"("WriteAttributes")";
+  }
+
+  // Check for a ForceReadAttributes Callback
+  if (uic_mqtt_dotdot_unify_switch_color_force_read_attributes_is_supported(unid, endpoint_id)) {
+    if (first_command == false) {
+      ss << ", ";
+    }
+    first_command = false;
+    ss << R"("ForceReadAttributes")";
+  }
+
+  // Publish supported commands
+  std::string topic = "ucl/by-unid/" + std::string(unid);
+  topic +=  "/ep"+ std::to_string(endpoint_id);
+  topic +=  "/UnifySwitchColor/SupportedCommands";
+  std::string payload_str("{\"value\": [" + ss.str() + "]" + "}");
+  if (first_command == false) {
+    uic_mqtt_publish(topic.c_str(),
+                      payload_str.c_str(),
+                      payload_str.length(),
+                      true);
+  } else if (uic_mqtt_count_topics(topic.c_str()) == 0) {
+    // There are no supported commands, but make sure we publish some
+    // SupportedCommands = [] if any attribute has been published for a cluster.
+    std::string attributes_topic = "ucl/by-unid/" + std::string(unid);
+    attributes_topic +=  "/ep"+ std::to_string(endpoint_id);
+    attributes_topic += "/UnifySwitchColor/Attributes";
+
+    if (uic_mqtt_count_topics(attributes_topic.c_str()) > 0) {
+      uic_mqtt_publish(topic.c_str(),
+                      EMPTY_VALUE_ARRAY,
+                      strlen(EMPTY_VALUE_ARRAY),
+                      true);
+    }
+  }
+}
+
+// Publishing empty/no Supported Commands for UnifySwitchColor Cluster
+void uic_mqtt_dotdot_unify_switch_color_publish_empty_supported_commands(
+  const dotdot_unid_t unid
+  , dotdot_endpoint_id_t endpoint_id)
+{
+  std::string topic = "ucl/by-unid/" + std::string(unid);
+  topic +=  "/ep"+ std::to_string(endpoint_id);
+  topic +=  "/UnifySwitchColor/SupportedCommands";
+
+  if (uic_mqtt_count_topics(topic.c_str()) > 0) {
+    uic_mqtt_publish(topic.c_str(),
+                     EMPTY_VALUE_ARRAY,
+                     strlen(EMPTY_VALUE_ARRAY),
+                     true);
+  }
+}
+
 
 ////////////////////////////////////////////////////////////////////////////////
 // Generated Commands publications functions
@@ -121907,3 +123297,75 @@ void uic_mqtt_dotdot_unify_humidity_control_publish_generated_setpoint_set_comma
                     payload.size(),
                     false);
 }
+/**
+ * @brief Publishes an incoming/generated SetColor command for
+ * the UnifySwitchColor cluster.
+ *
+ * Publication will be made at the following topic
+ * ucl/by-unid/UNID/epID/UnifySwitchColor/GeneratedCommands/SetColor
+ *
+ * @param unid      The UNID of the node that sent us the command.
+ * 
+ * @param endpoint  The Endpoint ID of the node that sent us the command.
+ * 
+ * 
+ * @param fields                Struct pointer with the fields value of the command
+ * 
+ */
+void uic_mqtt_dotdot_unify_switch_color_publish_generated_set_color_command(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint,
+  const uic_mqtt_dotdot_unify_switch_color_command_set_color_fields_t *fields
+  
+) {
+  // Create the topic
+  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
+                      std::to_string(endpoint) + "/";
+  topic += "UnifySwitchColor/GeneratedCommands/SetColor";
+
+  std::string payload =
+    get_json_payload_for_unify_switch_color_set_color_command(
+    fields);
+
+  // Publish our command
+  uic_mqtt_publish(topic.c_str(),
+                    payload.c_str(),
+                    payload.size(),
+                    false);
+}
+/**
+ * @brief Publishes an incoming/generated StartStopChange command for
+ * the UnifySwitchColor cluster.
+ *
+ * Publication will be made at the following topic
+ * ucl/by-unid/UNID/epID/UnifySwitchColor/GeneratedCommands/StartStopChange
+ *
+ * @param unid      The UNID of the node that sent us the command.
+ * 
+ * @param endpoint  The Endpoint ID of the node that sent us the command.
+ * 
+ * 
+ * @param fields                Struct pointer with the fields value of the command
+ * 
+ */
+void uic_mqtt_dotdot_unify_switch_color_publish_generated_start_stop_change_command(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint,
+  const uic_mqtt_dotdot_unify_switch_color_command_start_stop_change_fields_t *fields
+  
+) {
+  // Create the topic
+  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
+                      std::to_string(endpoint) + "/";
+  topic += "UnifySwitchColor/GeneratedCommands/StartStopChange";
+
+  std::string payload =
+    get_json_payload_for_unify_switch_color_start_stop_change_command(
+    fields);
+
+  // Publish our command
+  uic_mqtt_publish(topic.c_str(),
+                    payload.c_str(),
+                    payload.size(),
+                    false);
+}
diff --git a/components/uic_dotdot_mqtt/zap-generated/src/dotdot_mqtt.hpp b/components/uic_dotdot_mqtt/zap-generated/src/dotdot_mqtt.hpp
index cef2277e5a..626983fca7 100644
--- a/components/uic_dotdot_mqtt/zap-generated/src/dotdot_mqtt.hpp
+++ b/components/uic_dotdot_mqtt/zap-generated/src/dotdot_mqtt.hpp
@@ -378,6 +378,13 @@ sl_status_t uic_mqtt_dotdot_by_group_unify_thermostat_init();
  */
 sl_status_t uic_mqtt_dotdot_by_group_unify_humidity_control_init();
 
+/**
+ * @brief Initialize UnifySwitchColor dotdot bygroup command handlers
+ *
+ * @returns SL_STATUS_OK on success, error otherwise.
+ */
+sl_status_t uic_mqtt_dotdot_by_group_unify_switch_color_init();
+
 
 
 // clang-format on
@@ -5523,6 +5530,65 @@ void uic_mqtt_dotdot_on_unify_humidity_control_WriteAttributes(
   const size_t message_length);
 
 
+// clang-format on
+
+/**
+ * @brief Retrieves the container with callbacks pointer for
+ * by-unid UnifySwitchColor/Commands/SetColor messages
+ *
+ * @returns std::set of callbacks.
+ */
+std::set<uic_mqtt_dotdot_unify_switch_color_set_color_callback_t> &get_uic_mqtt_dotdot_unify_switch_color_set_color_callback();
+
+/**
+ * @brief MQTT Subscribe handler for incoming publications on:
+ * ucl/by-unid/+/+/UnifySwitchColor/Commands/SetColor
+ */
+// clang-format off
+void uic_mqtt_dotdot_on_unify_switch_color_set_color(
+  const char *topic,
+  const char *message,
+  const size_t message_length);
+// clang-format on
+
+/**
+ * @brief Retrieves the container with callbacks pointer for
+ * by-unid UnifySwitchColor/Commands/StartStopChange messages
+ *
+ * @returns std::set of callbacks.
+ */
+std::set<uic_mqtt_dotdot_unify_switch_color_start_stop_change_callback_t> &get_uic_mqtt_dotdot_unify_switch_color_start_stop_change_callback();
+
+/**
+ * @brief MQTT Subscribe handler for incoming publications on:
+ * ucl/by-unid/+/+/UnifySwitchColor/Commands/StartStopChange
+ */
+// clang-format off
+void uic_mqtt_dotdot_on_unify_switch_color_start_stop_change(
+  const char *topic,
+  const char *message,
+  const size_t message_length);
+// clang-format on
+
+/**
+ * @brief Retrieves the container with callback pointers for by-unid
+ * /Commands/WriteAttributes messages
+ *
+ * @returns std::set of callbacks.
+ */
+std::set<uic_mqtt_dotdot_unify_switch_color_write_attributes_callback_t> & get_uic_mqtt_dotdot_unify_switch_color_write_attributes_callback();
+
+/**
+ * @brief MQTT Subscribe handler for incoming publications on:
+ * ucl/by-unid/+/+/UnifySwitchColor/Commands/WriteAttributes
+ */
+// clang-format off
+void uic_mqtt_dotdot_on_unify_switch_color_WriteAttributes(
+  const char *topic,
+  const char *message,
+  const size_t message_length);
+
+
 
 
 // All bitmaps are defined as the cluster label for the bitmap plus the command/attribute name
diff --git a/components/uic_dotdot_mqtt/zap-generated/src/dotdot_mqtt_attributes.cpp b/components/uic_dotdot_mqtt/zap-generated/src/dotdot_mqtt_attributes.cpp
index 87fddb1ebf..d652e2f9eb 100644
--- a/components/uic_dotdot_mqtt/zap-generated/src/dotdot_mqtt_attributes.cpp
+++ b/components/uic_dotdot_mqtt/zap-generated/src/dotdot_mqtt_attributes.cpp
@@ -64347,3 +64347,710 @@ void uic_mqtt_dotdot_unify_humidity_control_attribute_auto_setpoint_precision_ca
 
 // End of supported cluster.
 
+///////////////////////////////////////////////////////////////////////////////
+// Callback pointers for UnifySwitchColor
+///////////////////////////////////////////////////////////////////////////////
+static uic_mqtt_dotdot_unify_switch_color_attribute_warm_white_callback_t uic_mqtt_dotdot_unify_switch_color_attribute_warm_white_callback = nullptr;
+static uic_mqtt_dotdot_unify_switch_color_attribute_cold_white_callback_t uic_mqtt_dotdot_unify_switch_color_attribute_cold_white_callback = nullptr;
+static uic_mqtt_dotdot_unify_switch_color_attribute_red_callback_t uic_mqtt_dotdot_unify_switch_color_attribute_red_callback = nullptr;
+static uic_mqtt_dotdot_unify_switch_color_attribute_green_callback_t uic_mqtt_dotdot_unify_switch_color_attribute_green_callback = nullptr;
+static uic_mqtt_dotdot_unify_switch_color_attribute_blue_callback_t uic_mqtt_dotdot_unify_switch_color_attribute_blue_callback = nullptr;
+static uic_mqtt_dotdot_unify_switch_color_attribute_amber_callback_t uic_mqtt_dotdot_unify_switch_color_attribute_amber_callback = nullptr;
+static uic_mqtt_dotdot_unify_switch_color_attribute_cyan_callback_t uic_mqtt_dotdot_unify_switch_color_attribute_cyan_callback = nullptr;
+static uic_mqtt_dotdot_unify_switch_color_attribute_purple_callback_t uic_mqtt_dotdot_unify_switch_color_attribute_purple_callback = nullptr;
+
+///////////////////////////////////////////////////////////////////////////////
+// Attribute update handlers for UnifySwitchColor
+///////////////////////////////////////////////////////////////////////////////
+static void uic_mqtt_dotdot_on_unify_switch_color_warm_white_attribute_update(
+  const char *topic,
+  const char *message,
+  const size_t message_length) {
+  if (uic_mqtt_dotdot_unify_switch_color_attribute_warm_white_callback == nullptr) {
+    return;
+  }
+
+  std::string unid;
+  uint8_t endpoint = 0; // Default value for endpoint-less topics.
+  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
+    sl_log_debug(LOG_TAG,
+                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
+                topic);
+    return;
+  }
+
+  std::string last_item;
+  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
+    sl_log_debug(LOG_TAG,
+                "Error parsing last item from topic %s. Ignoring",
+                topic);
+    return;
+  }
+
+  uic_mqtt_dotdot_attribute_update_type_t update_type;
+  if (last_item == "Reported") {
+    update_type = UCL_REPORTED_UPDATED;
+  } else if (last_item == "Desired") {
+    update_type = UCL_DESIRED_UPDATED;
+  } else {
+    sl_log_debug(LOG_TAG,
+                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
+                topic);
+    return;
+  }
+
+  // Empty message means unretained value.
+  bool unretained = false;
+  if (message_length == 0) {
+    unretained = true;
+  }
+
+
+  uint8_t warm_white = {};
+
+  nlohmann::json json_payload;
+  try {
+
+    if (unretained == false) {
+      json_payload = nlohmann::json::parse(std::string(message));
+
+      if (json_payload.find("value") == json_payload.end()) {
+        sl_log_debug(LOG_TAG, "UnifySwitchColor::WarmWhite: Missing attribute element: 'value'\n");
+        return;
+      }
+// Start parsing value
+      warm_white = json_payload.at("value").get<uint8_t>();
+    
+    // End parsing value
+    }
+
+  } catch (const std::exception& e) {
+    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
+    return;
+  }
+
+  uic_mqtt_dotdot_unify_switch_color_attribute_warm_white_callback(
+    static_cast<dotdot_unid_t>(unid.c_str()),
+    endpoint,
+    unretained,
+    update_type,
+    warm_white
+  );
+
+}
+static void uic_mqtt_dotdot_on_unify_switch_color_cold_white_attribute_update(
+  const char *topic,
+  const char *message,
+  const size_t message_length) {
+  if (uic_mqtt_dotdot_unify_switch_color_attribute_cold_white_callback == nullptr) {
+    return;
+  }
+
+  std::string unid;
+  uint8_t endpoint = 0; // Default value for endpoint-less topics.
+  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
+    sl_log_debug(LOG_TAG,
+                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
+                topic);
+    return;
+  }
+
+  std::string last_item;
+  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
+    sl_log_debug(LOG_TAG,
+                "Error parsing last item from topic %s. Ignoring",
+                topic);
+    return;
+  }
+
+  uic_mqtt_dotdot_attribute_update_type_t update_type;
+  if (last_item == "Reported") {
+    update_type = UCL_REPORTED_UPDATED;
+  } else if (last_item == "Desired") {
+    update_type = UCL_DESIRED_UPDATED;
+  } else {
+    sl_log_debug(LOG_TAG,
+                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
+                topic);
+    return;
+  }
+
+  // Empty message means unretained value.
+  bool unretained = false;
+  if (message_length == 0) {
+    unretained = true;
+  }
+
+
+  uint8_t cold_white = {};
+
+  nlohmann::json json_payload;
+  try {
+
+    if (unretained == false) {
+      json_payload = nlohmann::json::parse(std::string(message));
+
+      if (json_payload.find("value") == json_payload.end()) {
+        sl_log_debug(LOG_TAG, "UnifySwitchColor::ColdWhite: Missing attribute element: 'value'\n");
+        return;
+      }
+// Start parsing value
+      cold_white = json_payload.at("value").get<uint8_t>();
+    
+    // End parsing value
+    }
+
+  } catch (const std::exception& e) {
+    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
+    return;
+  }
+
+  uic_mqtt_dotdot_unify_switch_color_attribute_cold_white_callback(
+    static_cast<dotdot_unid_t>(unid.c_str()),
+    endpoint,
+    unretained,
+    update_type,
+    cold_white
+  );
+
+}
+static void uic_mqtt_dotdot_on_unify_switch_color_red_attribute_update(
+  const char *topic,
+  const char *message,
+  const size_t message_length) {
+  if (uic_mqtt_dotdot_unify_switch_color_attribute_red_callback == nullptr) {
+    return;
+  }
+
+  std::string unid;
+  uint8_t endpoint = 0; // Default value for endpoint-less topics.
+  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
+    sl_log_debug(LOG_TAG,
+                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
+                topic);
+    return;
+  }
+
+  std::string last_item;
+  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
+    sl_log_debug(LOG_TAG,
+                "Error parsing last item from topic %s. Ignoring",
+                topic);
+    return;
+  }
+
+  uic_mqtt_dotdot_attribute_update_type_t update_type;
+  if (last_item == "Reported") {
+    update_type = UCL_REPORTED_UPDATED;
+  } else if (last_item == "Desired") {
+    update_type = UCL_DESIRED_UPDATED;
+  } else {
+    sl_log_debug(LOG_TAG,
+                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
+                topic);
+    return;
+  }
+
+  // Empty message means unretained value.
+  bool unretained = false;
+  if (message_length == 0) {
+    unretained = true;
+  }
+
+
+  uint8_t red = {};
+
+  nlohmann::json json_payload;
+  try {
+
+    if (unretained == false) {
+      json_payload = nlohmann::json::parse(std::string(message));
+
+      if (json_payload.find("value") == json_payload.end()) {
+        sl_log_debug(LOG_TAG, "UnifySwitchColor::Red: Missing attribute element: 'value'\n");
+        return;
+      }
+// Start parsing value
+      red = json_payload.at("value").get<uint8_t>();
+    
+    // End parsing value
+    }
+
+  } catch (const std::exception& e) {
+    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
+    return;
+  }
+
+  uic_mqtt_dotdot_unify_switch_color_attribute_red_callback(
+    static_cast<dotdot_unid_t>(unid.c_str()),
+    endpoint,
+    unretained,
+    update_type,
+    red
+  );
+
+}
+static void uic_mqtt_dotdot_on_unify_switch_color_green_attribute_update(
+  const char *topic,
+  const char *message,
+  const size_t message_length) {
+  if (uic_mqtt_dotdot_unify_switch_color_attribute_green_callback == nullptr) {
+    return;
+  }
+
+  std::string unid;
+  uint8_t endpoint = 0; // Default value for endpoint-less topics.
+  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
+    sl_log_debug(LOG_TAG,
+                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
+                topic);
+    return;
+  }
+
+  std::string last_item;
+  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
+    sl_log_debug(LOG_TAG,
+                "Error parsing last item from topic %s. Ignoring",
+                topic);
+    return;
+  }
+
+  uic_mqtt_dotdot_attribute_update_type_t update_type;
+  if (last_item == "Reported") {
+    update_type = UCL_REPORTED_UPDATED;
+  } else if (last_item == "Desired") {
+    update_type = UCL_DESIRED_UPDATED;
+  } else {
+    sl_log_debug(LOG_TAG,
+                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
+                topic);
+    return;
+  }
+
+  // Empty message means unretained value.
+  bool unretained = false;
+  if (message_length == 0) {
+    unretained = true;
+  }
+
+
+  uint8_t green = {};
+
+  nlohmann::json json_payload;
+  try {
+
+    if (unretained == false) {
+      json_payload = nlohmann::json::parse(std::string(message));
+
+      if (json_payload.find("value") == json_payload.end()) {
+        sl_log_debug(LOG_TAG, "UnifySwitchColor::Green: Missing attribute element: 'value'\n");
+        return;
+      }
+// Start parsing value
+      green = json_payload.at("value").get<uint8_t>();
+    
+    // End parsing value
+    }
+
+  } catch (const std::exception& e) {
+    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
+    return;
+  }
+
+  uic_mqtt_dotdot_unify_switch_color_attribute_green_callback(
+    static_cast<dotdot_unid_t>(unid.c_str()),
+    endpoint,
+    unretained,
+    update_type,
+    green
+  );
+
+}
+static void uic_mqtt_dotdot_on_unify_switch_color_blue_attribute_update(
+  const char *topic,
+  const char *message,
+  const size_t message_length) {
+  if (uic_mqtt_dotdot_unify_switch_color_attribute_blue_callback == nullptr) {
+    return;
+  }
+
+  std::string unid;
+  uint8_t endpoint = 0; // Default value for endpoint-less topics.
+  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
+    sl_log_debug(LOG_TAG,
+                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
+                topic);
+    return;
+  }
+
+  std::string last_item;
+  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
+    sl_log_debug(LOG_TAG,
+                "Error parsing last item from topic %s. Ignoring",
+                topic);
+    return;
+  }
+
+  uic_mqtt_dotdot_attribute_update_type_t update_type;
+  if (last_item == "Reported") {
+    update_type = UCL_REPORTED_UPDATED;
+  } else if (last_item == "Desired") {
+    update_type = UCL_DESIRED_UPDATED;
+  } else {
+    sl_log_debug(LOG_TAG,
+                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
+                topic);
+    return;
+  }
+
+  // Empty message means unretained value.
+  bool unretained = false;
+  if (message_length == 0) {
+    unretained = true;
+  }
+
+
+  uint8_t blue = {};
+
+  nlohmann::json json_payload;
+  try {
+
+    if (unretained == false) {
+      json_payload = nlohmann::json::parse(std::string(message));
+
+      if (json_payload.find("value") == json_payload.end()) {
+        sl_log_debug(LOG_TAG, "UnifySwitchColor::Blue: Missing attribute element: 'value'\n");
+        return;
+      }
+// Start parsing value
+      blue = json_payload.at("value").get<uint8_t>();
+    
+    // End parsing value
+    }
+
+  } catch (const std::exception& e) {
+    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
+    return;
+  }
+
+  uic_mqtt_dotdot_unify_switch_color_attribute_blue_callback(
+    static_cast<dotdot_unid_t>(unid.c_str()),
+    endpoint,
+    unretained,
+    update_type,
+    blue
+  );
+
+}
+static void uic_mqtt_dotdot_on_unify_switch_color_amber_attribute_update(
+  const char *topic,
+  const char *message,
+  const size_t message_length) {
+  if (uic_mqtt_dotdot_unify_switch_color_attribute_amber_callback == nullptr) {
+    return;
+  }
+
+  std::string unid;
+  uint8_t endpoint = 0; // Default value for endpoint-less topics.
+  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
+    sl_log_debug(LOG_TAG,
+                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
+                topic);
+    return;
+  }
+
+  std::string last_item;
+  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
+    sl_log_debug(LOG_TAG,
+                "Error parsing last item from topic %s. Ignoring",
+                topic);
+    return;
+  }
+
+  uic_mqtt_dotdot_attribute_update_type_t update_type;
+  if (last_item == "Reported") {
+    update_type = UCL_REPORTED_UPDATED;
+  } else if (last_item == "Desired") {
+    update_type = UCL_DESIRED_UPDATED;
+  } else {
+    sl_log_debug(LOG_TAG,
+                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
+                topic);
+    return;
+  }
+
+  // Empty message means unretained value.
+  bool unretained = false;
+  if (message_length == 0) {
+    unretained = true;
+  }
+
+
+  uint8_t amber = {};
+
+  nlohmann::json json_payload;
+  try {
+
+    if (unretained == false) {
+      json_payload = nlohmann::json::parse(std::string(message));
+
+      if (json_payload.find("value") == json_payload.end()) {
+        sl_log_debug(LOG_TAG, "UnifySwitchColor::Amber: Missing attribute element: 'value'\n");
+        return;
+      }
+// Start parsing value
+      amber = json_payload.at("value").get<uint8_t>();
+    
+    // End parsing value
+    }
+
+  } catch (const std::exception& e) {
+    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
+    return;
+  }
+
+  uic_mqtt_dotdot_unify_switch_color_attribute_amber_callback(
+    static_cast<dotdot_unid_t>(unid.c_str()),
+    endpoint,
+    unretained,
+    update_type,
+    amber
+  );
+
+}
+static void uic_mqtt_dotdot_on_unify_switch_color_cyan_attribute_update(
+  const char *topic,
+  const char *message,
+  const size_t message_length) {
+  if (uic_mqtt_dotdot_unify_switch_color_attribute_cyan_callback == nullptr) {
+    return;
+  }
+
+  std::string unid;
+  uint8_t endpoint = 0; // Default value for endpoint-less topics.
+  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
+    sl_log_debug(LOG_TAG,
+                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
+                topic);
+    return;
+  }
+
+  std::string last_item;
+  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
+    sl_log_debug(LOG_TAG,
+                "Error parsing last item from topic %s. Ignoring",
+                topic);
+    return;
+  }
+
+  uic_mqtt_dotdot_attribute_update_type_t update_type;
+  if (last_item == "Reported") {
+    update_type = UCL_REPORTED_UPDATED;
+  } else if (last_item == "Desired") {
+    update_type = UCL_DESIRED_UPDATED;
+  } else {
+    sl_log_debug(LOG_TAG,
+                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
+                topic);
+    return;
+  }
+
+  // Empty message means unretained value.
+  bool unretained = false;
+  if (message_length == 0) {
+    unretained = true;
+  }
+
+
+  uint8_t cyan = {};
+
+  nlohmann::json json_payload;
+  try {
+
+    if (unretained == false) {
+      json_payload = nlohmann::json::parse(std::string(message));
+
+      if (json_payload.find("value") == json_payload.end()) {
+        sl_log_debug(LOG_TAG, "UnifySwitchColor::Cyan: Missing attribute element: 'value'\n");
+        return;
+      }
+// Start parsing value
+      cyan = json_payload.at("value").get<uint8_t>();
+    
+    // End parsing value
+    }
+
+  } catch (const std::exception& e) {
+    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
+    return;
+  }
+
+  uic_mqtt_dotdot_unify_switch_color_attribute_cyan_callback(
+    static_cast<dotdot_unid_t>(unid.c_str()),
+    endpoint,
+    unretained,
+    update_type,
+    cyan
+  );
+
+}
+static void uic_mqtt_dotdot_on_unify_switch_color_purple_attribute_update(
+  const char *topic,
+  const char *message,
+  const size_t message_length) {
+  if (uic_mqtt_dotdot_unify_switch_color_attribute_purple_callback == nullptr) {
+    return;
+  }
+
+  std::string unid;
+  uint8_t endpoint = 0; // Default value for endpoint-less topics.
+  if(! uic_dotdot_mqtt::parse_topic(topic,unid,endpoint)) {
+    sl_log_debug(LOG_TAG,
+                "Error parsing UNID / Endpoint ID from topic %s. Ignoring",
+                topic);
+    return;
+  }
+
+  std::string last_item;
+  if (SL_STATUS_OK != uic_dotdot_mqtt::get_topic_last_item(topic,last_item)){
+    sl_log_debug(LOG_TAG,
+                "Error parsing last item from topic %s. Ignoring",
+                topic);
+    return;
+  }
+
+  uic_mqtt_dotdot_attribute_update_type_t update_type;
+  if (last_item == "Reported") {
+    update_type = UCL_REPORTED_UPDATED;
+  } else if (last_item == "Desired") {
+    update_type = UCL_DESIRED_UPDATED;
+  } else {
+    sl_log_debug(LOG_TAG,
+                "Unknown value type (neither Desired/Reported) for topic %s. Ignoring",
+                topic);
+    return;
+  }
+
+  // Empty message means unretained value.
+  bool unretained = false;
+  if (message_length == 0) {
+    unretained = true;
+  }
+
+
+  uint8_t purple = {};
+
+  nlohmann::json json_payload;
+  try {
+
+    if (unretained == false) {
+      json_payload = nlohmann::json::parse(std::string(message));
+
+      if (json_payload.find("value") == json_payload.end()) {
+        sl_log_debug(LOG_TAG, "UnifySwitchColor::Purple: Missing attribute element: 'value'\n");
+        return;
+      }
+// Start parsing value
+      purple = json_payload.at("value").get<uint8_t>();
+    
+    // End parsing value
+    }
+
+  } catch (const std::exception& e) {
+    sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "value", message);
+    return;
+  }
+
+  uic_mqtt_dotdot_unify_switch_color_attribute_purple_callback(
+    static_cast<dotdot_unid_t>(unid.c_str()),
+    endpoint,
+    unretained,
+    update_type,
+    purple
+  );
+
+}
+
+///////////////////////////////////////////////////////////////////////////////
+// Attribute init functions for UnifySwitchColor
+///////////////////////////////////////////////////////////////////////////////
+sl_status_t uic_mqtt_dotdot_unify_switch_color_attributes_init()
+{
+  std::string base_topic = "ucl/by-unid/+/+/";
+
+  std::string subscription_topic;
+  if(uic_mqtt_dotdot_unify_switch_color_attribute_warm_white_callback) {
+    subscription_topic = base_topic + "UnifySwitchColor/Attributes/WarmWhite/#";
+    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_unify_switch_color_warm_white_attribute_update);
+  }
+  if(uic_mqtt_dotdot_unify_switch_color_attribute_cold_white_callback) {
+    subscription_topic = base_topic + "UnifySwitchColor/Attributes/ColdWhite/#";
+    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_unify_switch_color_cold_white_attribute_update);
+  }
+  if(uic_mqtt_dotdot_unify_switch_color_attribute_red_callback) {
+    subscription_topic = base_topic + "UnifySwitchColor/Attributes/Red/#";
+    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_unify_switch_color_red_attribute_update);
+  }
+  if(uic_mqtt_dotdot_unify_switch_color_attribute_green_callback) {
+    subscription_topic = base_topic + "UnifySwitchColor/Attributes/Green/#";
+    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_unify_switch_color_green_attribute_update);
+  }
+  if(uic_mqtt_dotdot_unify_switch_color_attribute_blue_callback) {
+    subscription_topic = base_topic + "UnifySwitchColor/Attributes/Blue/#";
+    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_unify_switch_color_blue_attribute_update);
+  }
+  if(uic_mqtt_dotdot_unify_switch_color_attribute_amber_callback) {
+    subscription_topic = base_topic + "UnifySwitchColor/Attributes/Amber/#";
+    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_unify_switch_color_amber_attribute_update);
+  }
+  if(uic_mqtt_dotdot_unify_switch_color_attribute_cyan_callback) {
+    subscription_topic = base_topic + "UnifySwitchColor/Attributes/Cyan/#";
+    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_unify_switch_color_cyan_attribute_update);
+  }
+  if(uic_mqtt_dotdot_unify_switch_color_attribute_purple_callback) {
+    subscription_topic = base_topic + "UnifySwitchColor/Attributes/Purple/#";
+    uic_mqtt_subscribe(subscription_topic.c_str(), &uic_mqtt_dotdot_on_unify_switch_color_purple_attribute_update);
+  }
+
+  return SL_STATUS_OK;
+}
+
+
+///////////////////////////////////////////////////////////////////////////////
+// Callback setters and getters for UnifySwitchColor
+///////////////////////////////////////////////////////////////////////////////
+void uic_mqtt_dotdot_unify_switch_color_attribute_warm_white_callback_set(const uic_mqtt_dotdot_unify_switch_color_attribute_warm_white_callback_t callback)
+{
+  uic_mqtt_dotdot_unify_switch_color_attribute_warm_white_callback = callback;
+}
+void uic_mqtt_dotdot_unify_switch_color_attribute_cold_white_callback_set(const uic_mqtt_dotdot_unify_switch_color_attribute_cold_white_callback_t callback)
+{
+  uic_mqtt_dotdot_unify_switch_color_attribute_cold_white_callback = callback;
+}
+void uic_mqtt_dotdot_unify_switch_color_attribute_red_callback_set(const uic_mqtt_dotdot_unify_switch_color_attribute_red_callback_t callback)
+{
+  uic_mqtt_dotdot_unify_switch_color_attribute_red_callback = callback;
+}
+void uic_mqtt_dotdot_unify_switch_color_attribute_green_callback_set(const uic_mqtt_dotdot_unify_switch_color_attribute_green_callback_t callback)
+{
+  uic_mqtt_dotdot_unify_switch_color_attribute_green_callback = callback;
+}
+void uic_mqtt_dotdot_unify_switch_color_attribute_blue_callback_set(const uic_mqtt_dotdot_unify_switch_color_attribute_blue_callback_t callback)
+{
+  uic_mqtt_dotdot_unify_switch_color_attribute_blue_callback = callback;
+}
+void uic_mqtt_dotdot_unify_switch_color_attribute_amber_callback_set(const uic_mqtt_dotdot_unify_switch_color_attribute_amber_callback_t callback)
+{
+  uic_mqtt_dotdot_unify_switch_color_attribute_amber_callback = callback;
+}
+void uic_mqtt_dotdot_unify_switch_color_attribute_cyan_callback_set(const uic_mqtt_dotdot_unify_switch_color_attribute_cyan_callback_t callback)
+{
+  uic_mqtt_dotdot_unify_switch_color_attribute_cyan_callback = callback;
+}
+void uic_mqtt_dotdot_unify_switch_color_attribute_purple_callback_set(const uic_mqtt_dotdot_unify_switch_color_attribute_purple_callback_t callback)
+{
+  uic_mqtt_dotdot_unify_switch_color_attribute_purple_callback = callback;
+}
+
+// End of supported cluster.
+
diff --git a/components/uic_dotdot_mqtt/zap-generated/src/dotdot_mqtt_command_helpers.cpp b/components/uic_dotdot_mqtt/zap-generated/src/dotdot_mqtt_command_helpers.cpp
index 9dcceb98fc..9c5fea5705 100644
--- a/components/uic_dotdot_mqtt/zap-generated/src/dotdot_mqtt_command_helpers.cpp
+++ b/components/uic_dotdot_mqtt/zap-generated/src/dotdot_mqtt_command_helpers.cpp
@@ -15957,5 +15957,181 @@ void uic_mqtt_dotdot_parse_unify_humidity_control_write_attributes(
 
 
 
+}
+
+
+std::string get_json_payload_for_unify_switch_color_set_color_command(
+  
+  const uic_mqtt_dotdot_unify_switch_color_command_set_color_fields_t *fields
+  
+){
+  bool command_with_no_fields = true;
+
+  // Create a JSON payload from all the parameters
+  nlohmann::json json_payload;
+  command_with_no_fields = false;
+  // Single Value
+  // Non-enum and non-bitmask (struct, string or scalar)
+  json_payload["ColorComponentId"] = nlohmann::json(fields->color_component_id);
+  command_with_no_fields = false;
+  // Single Value
+  // Non-enum and non-bitmask (struct, string or scalar)
+  json_payload["Value"] = nlohmann::json(fields->value);
+  command_with_no_fields = false;
+  // Single Value
+  // Non-enum and non-bitmask (struct, string or scalar)
+  json_payload["Duration"] = nlohmann::json(fields->duration);
+
+  // Get the string
+  if (command_with_no_fields == true) {
+    return std::string("{}");
+  }
+  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
+  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
+}
+
+
+void uic_mqtt_dotdot_parse_unify_switch_color_set_color(
+  nlohmann::json &jsn,
+  uint8_t &color_component_id,
+  
+  uint8_t &value,
+  
+  uint32_t &duration
+  
+) {
+
+  if (jsn.at("ColorComponentId").is_null()) {
+    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
+    return;
+  }
+        
+  color_component_id = jsn.at("ColorComponentId").get< uint8_t >();
+      if (jsn.at("Value").is_null()) {
+    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
+    return;
+  }
+        
+  value = jsn.at("Value").get< uint8_t >();
+      if (jsn.at("Duration").is_null()) {
+    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
+    return;
+  }
+        
+  duration = jsn.at("Duration").get< uint32_t >();
+    }
+
+
+std::string get_json_payload_for_unify_switch_color_start_stop_change_command(
+  
+  const uic_mqtt_dotdot_unify_switch_color_command_start_stop_change_fields_t *fields
+  
+){
+  bool command_with_no_fields = true;
+
+  // Create a JSON payload from all the parameters
+  nlohmann::json json_payload;
+  command_with_no_fields = false;
+  // Single Value
+  // Non-enum and non-bitmask (struct, string or scalar)
+  json_payload["StartStop"] = nlohmann::json(fields->start_stop);
+  command_with_no_fields = false;
+  // Single Value
+  // Non-enum and non-bitmask (struct, string or scalar)
+  json_payload["UpDown"] = nlohmann::json(fields->up_down);
+  command_with_no_fields = false;
+  // Single Value
+  // Non-enum and non-bitmask (struct, string or scalar)
+  json_payload["IgnorStartLevel"] = nlohmann::json(fields->ignor_start_level);
+  command_with_no_fields = false;
+  // Single Value
+  // Non-enum and non-bitmask (struct, string or scalar)
+  json_payload["ColorComponentId"] = nlohmann::json(fields->color_component_id);
+  command_with_no_fields = false;
+  // Single Value
+  // Non-enum and non-bitmask (struct, string or scalar)
+  json_payload["StartLevel"] = nlohmann::json(fields->start_level);
+  command_with_no_fields = false;
+  // Single Value
+  // Non-enum and non-bitmask (struct, string or scalar)
+  json_payload["Duration"] = nlohmann::json(fields->duration);
+
+  // Get the string
+  if (command_with_no_fields == true) {
+    return std::string("{}");
+  }
+  // Payload may contain data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
+  return json_payload.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
+}
+
+
+void uic_mqtt_dotdot_parse_unify_switch_color_start_stop_change(
+  nlohmann::json &jsn,
+  bool &start_stop,
+  
+  bool &up_down,
+  
+  bool &ignor_start_level,
+  
+  uint8_t &color_component_id,
+  
+  uint8_t &start_level,
+  
+  uint32_t &duration
+  
+) {
+
+  if (jsn.at("StartStop").is_null()) {
+    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
+    return;
+  }
+        
+  start_stop = jsn.at("StartStop").get< bool >();
+      if (jsn.at("UpDown").is_null()) {
+    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
+    return;
+  }
+        
+  up_down = jsn.at("UpDown").get< bool >();
+      if (jsn.at("IgnorStartLevel").is_null()) {
+    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
+    return;
+  }
+        
+  ignor_start_level = jsn.at("IgnorStartLevel").get< bool >();
+      if (jsn.at("ColorComponentId").is_null()) {
+    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
+    return;
+  }
+        
+  color_component_id = jsn.at("ColorComponentId").get< uint8_t >();
+      if (jsn.at("StartLevel").is_null()) {
+    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
+    return;
+  }
+        
+  start_level = jsn.at("StartLevel").get< uint8_t >();
+      if (jsn.at("Duration").is_null()) {
+    sl_log_debug(LOG_TAG, "Ignoring JSON Null object");
+    return;
+  }
+        
+  duration = jsn.at("Duration").get< uint32_t >();
+    }
+
+
+/**
+ * @brief JSON parser for ::WriteAttributes command arguments.
+ *
+ * Parse incoming JSON object to populate command arguments passed in by reference.
+ */
+void uic_mqtt_dotdot_parse_unify_switch_color_write_attributes(
+  nlohmann::json &jsn,
+  uic_mqtt_dotdot_unify_switch_color_state_t &new_state,
+  uic_mqtt_dotdot_unify_switch_color_updated_state_t &new_updated_state
+) {
+
+
+
 }
 
diff --git a/components/uic_dotdot_mqtt/zap-generated/src/dotdot_mqtt_command_helpers.hpp b/components/uic_dotdot_mqtt/zap-generated/src/dotdot_mqtt_command_helpers.hpp
index ede2d6189e..5ecd3fe972 100644
--- a/components/uic_dotdot_mqtt/zap-generated/src/dotdot_mqtt_command_helpers.hpp
+++ b/components/uic_dotdot_mqtt/zap-generated/src/dotdot_mqtt_command_helpers.hpp
@@ -6650,6 +6650,88 @@ void uic_mqtt_dotdot_parse_unify_humidity_control_write_attributes(
 );
 
 
+/**
+ * @brief Private helper function that will create a JSON string based on the
+ * fields of a UnifySwitchColor SetColor command
+ * 
+ * @param fields       Struct pointer with the list of fields for the command
+ * 
+ * @returns std::string that contains JSON payload
+ */
+std::string get_json_payload_for_unify_switch_color_set_color_command(
+  
+  const uic_mqtt_dotdot_unify_switch_color_command_set_color_fields_t *fields
+  
+);
+
+
+/**
+ * @brief JSON parser for UnifySwitchColor SetColor command arguments.
+ *
+ * Parse incoming JSON object to populate command arguments passed in by reference.
+ */
+void uic_mqtt_dotdot_parse_unify_switch_color_set_color(
+  nlohmann::json &jsn,
+  uint8_t &color_component_id,
+
+  uint8_t &value,
+
+  uint32_t &duration
+
+);
+
+
+
+/**
+ * @brief Private helper function that will create a JSON string based on the
+ * fields of a UnifySwitchColor StartStopChange command
+ * 
+ * @param fields       Struct pointer with the list of fields for the command
+ * 
+ * @returns std::string that contains JSON payload
+ */
+std::string get_json_payload_for_unify_switch_color_start_stop_change_command(
+  
+  const uic_mqtt_dotdot_unify_switch_color_command_start_stop_change_fields_t *fields
+  
+);
+
+
+/**
+ * @brief JSON parser for UnifySwitchColor StartStopChange command arguments.
+ *
+ * Parse incoming JSON object to populate command arguments passed in by reference.
+ */
+void uic_mqtt_dotdot_parse_unify_switch_color_start_stop_change(
+  nlohmann::json &jsn,
+  bool &start_stop,
+
+  bool &up_down,
+
+  bool &ignor_start_level,
+
+  uint8_t &color_component_id,
+
+  uint8_t &start_level,
+
+  uint32_t &duration
+
+);
+
+
+
+/**
+ * @brief JSON parser for UnifySwitchColor WriteAttributes command arguments.
+ *
+ * Parse incoming JSON object to populate command arguments passed in by reference.
+ */
+void uic_mqtt_dotdot_parse_unify_switch_color_write_attributes(
+  nlohmann::json &jsn,
+  uic_mqtt_dotdot_unify_switch_color_state_t &new_state,
+  uic_mqtt_dotdot_unify_switch_color_updated_state_t &new_updated_state
+);
+
+
 
 #endif  //DOTDOT_MQTT_COMMAND_HELPERS_HPP
 /** @} end dotdot_mqtt_command_helpers */
diff --git a/components/uic_dotdot_mqtt/zap-generated/src/dotdot_mqtt_generated_commands.cpp b/components/uic_dotdot_mqtt/zap-generated/src/dotdot_mqtt_generated_commands.cpp
index 523ffd0855..e2e522b193 100644
--- a/components/uic_dotdot_mqtt/zap-generated/src/dotdot_mqtt_generated_commands.cpp
+++ b/components/uic_dotdot_mqtt/zap-generated/src/dotdot_mqtt_generated_commands.cpp
@@ -12047,3 +12047,115 @@ void uic_mqtt_dotdot_unify_humidity_control_publish_generated_write_attributes_c
                    false);
 }
 
+/**
+ * @brief Publishes an incoming/generated SetColor command for
+ * the UnifySwitchColor cluster.
+ *
+ * Publication will be made at the following topic
+ * ucl/by-unid/UNID/epID/UnifySwitchColor/GeneratedCommands/SetColor
+ *
+ * @param unid      The UNID of the node that sent us the command.
+ * 
+ * @param endpoint  The Endpoint ID of the node that sent us the command.
+ * 
+ * 
+ * @param fields                Struct pointer with the fields value of the command
+ * 
+ */
+void uic_mqtt_dotdot_unify_switch_color_publish_generated_set_color_command(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint,
+  const uic_mqtt_dotdot_unify_switch_color_command_set_color_fields_t *fields
+  
+) {
+  // Create the topic
+  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
+                      std::to_string(endpoint) + "/";
+  topic += "UnifySwitchColor/GeneratedCommands/SetColor";
+
+  std::string payload =
+    get_json_payload_for_unify_switch_color_set_color_command(
+    fields);
+
+  // Publish our command
+  uic_mqtt_publish(topic.c_str(),
+                    payload.c_str(),
+                    payload.size(),
+                    false);
+}
+/**
+ * @brief Publishes an incoming/generated StartStopChange command for
+ * the UnifySwitchColor cluster.
+ *
+ * Publication will be made at the following topic
+ * ucl/by-unid/UNID/epID/UnifySwitchColor/GeneratedCommands/StartStopChange
+ *
+ * @param unid      The UNID of the node that sent us the command.
+ * 
+ * @param endpoint  The Endpoint ID of the node that sent us the command.
+ * 
+ * 
+ * @param fields                Struct pointer with the fields value of the command
+ * 
+ */
+void uic_mqtt_dotdot_unify_switch_color_publish_generated_start_stop_change_command(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint,
+  const uic_mqtt_dotdot_unify_switch_color_command_start_stop_change_fields_t *fields
+  
+) {
+  // Create the topic
+  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
+                      std::to_string(endpoint) + "/";
+  topic += "UnifySwitchColor/GeneratedCommands/StartStopChange";
+
+  std::string payload =
+    get_json_payload_for_unify_switch_color_start_stop_change_command(
+    fields);
+
+  // Publish our command
+  uic_mqtt_publish(topic.c_str(),
+                    payload.c_str(),
+                    payload.size(),
+                    false);
+}
+
+
+/**
+ * @brief Publishes an incoming/generated WriteAttributes command for
+ * the UnifySwitchColor cluster.
+ *
+ * Publication will be made at the following topic
+ * ucl/by-unid/UNID/epID/UnifySwitchColor/GeneratedCommands/WriteAttributes
+ *
+ * @param unid      The UNID of the node that sent us the command.
+ * 
+ * @param endpoint  The Endpoint ID of the node that sent us the command.
+ * 
+ * @param attribute_values  Values to assign to the attributes
+ * @param attribute_list    List of attributes that are written
+ */
+void uic_mqtt_dotdot_unify_switch_color_publish_generated_write_attributes_command(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint,
+  uic_mqtt_dotdot_unify_switch_color_state_t attribute_values,
+  uic_mqtt_dotdot_unify_switch_color_updated_state_t attribute_list
+){
+  // Create the topic
+  std::string topic = "ucl/by-unid/"+ std::string(unid) + "/ep" +
+                      std::to_string(endpoint) + "/";
+  topic += "UnifySwitchColor/GeneratedCommands/WriteAttributes";
+
+  nlohmann::json json_object = nlohmann::json::object();
+
+
+  // Payload contains data from end nodes, which we cannot control, thus we handle if there are non-utf8 characters
+  std::string payload = json_object.dump(-1, ' ', false, nlohmann::detail::error_handler_t::replace);
+
+  // Publish our command
+  uic_mqtt_publish(topic.c_str(),
+                   payload.c_str(),
+                   payload.size(),
+                   false);
+}
+
diff --git a/components/uic_dotdot_mqtt/zap-generated/src/dotdot_mqtt_group_commands.cpp b/components/uic_dotdot_mqtt/zap-generated/src/dotdot_mqtt_group_commands.cpp
index 295e2af47e..15eb05a694 100644
--- a/components/uic_dotdot_mqtt/zap-generated/src/dotdot_mqtt_group_commands.cpp
+++ b/components/uic_dotdot_mqtt/zap-generated/src/dotdot_mqtt_group_commands.cpp
@@ -393,6 +393,11 @@ static uic_mqtt_dotdot_by_group_unify_humidity_control_setpoint_set_callback_t u
 static uic_mqtt_dotdot_by_group_unify_humidity_control_write_attributes_callback_t uic_mqtt_dotdot_by_group_unify_humidity_control_write_attributes_callback = nullptr;
 
 
+static uic_mqtt_dotdot_by_group_unify_switch_color_set_color_callback_t uic_mqtt_dotdot_by_group_unify_switch_color_set_color_callback = nullptr;
+static uic_mqtt_dotdot_by_group_unify_switch_color_start_stop_change_callback_t uic_mqtt_dotdot_by_group_unify_switch_color_start_stop_change_callback = nullptr;
+static uic_mqtt_dotdot_by_group_unify_switch_color_write_attributes_callback_t uic_mqtt_dotdot_by_group_unify_switch_color_write_attributes_callback = nullptr;
+
+
 
 // Callbacks setters
 
@@ -2047,6 +2052,27 @@ void uic_mqtt_dotdot_by_group_unify_humidity_control_write_attributes_callback_s
 
 
 
+// Callbacks setters
+
+void uic_mqtt_dotdot_by_group_unify_switch_color_set_color_callback_set(const uic_mqtt_dotdot_by_group_unify_switch_color_set_color_callback_t callback)
+{
+  uic_mqtt_dotdot_by_group_unify_switch_color_set_color_callback = callback;
+}
+
+
+void uic_mqtt_dotdot_by_group_unify_switch_color_start_stop_change_callback_set(const uic_mqtt_dotdot_by_group_unify_switch_color_start_stop_change_callback_t callback)
+{
+  uic_mqtt_dotdot_by_group_unify_switch_color_start_stop_change_callback = callback;
+}
+
+void uic_mqtt_dotdot_by_group_unify_switch_color_write_attributes_callback_set(
+  const uic_mqtt_dotdot_by_group_unify_switch_color_write_attributes_callback_t callback)
+{
+  uic_mqtt_dotdot_by_group_unify_switch_color_write_attributes_callback = callback;
+}
+
+
+
 
 // Callback function for incoming publications on ucl/by-group/+/Basic/Commands/ResetToFactoryDefaults
 static void uic_mqtt_dotdot_on_by_group_basic_reset_to_factory_defaults(
@@ -25768,6 +25794,311 @@ sl_status_t uic_mqtt_dotdot_by_group_unify_humidity_control_init()
 
 
 
+
+// Callback function for incoming publications on ucl/by-group/+/UnifySwitchColor/Commands/SetColor
+static void uic_mqtt_dotdot_on_by_group_unify_switch_color_set_color(
+  const char *topic,
+  const char *message,
+  const size_t message_length)
+{
+  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_unify_switch_color_set_color_callback == nullptr)) {
+    return;
+  }
+  if (message_length == 0) {
+    return;
+  }
+
+  dotdot_group_id_t group_id = 0U;
+  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
+    sl_log_debug(LOG_TAG,
+                "Failed to parse GroupId from topic %s. Ignoring",
+                topic);
+    return;
+  }
+
+  // Pass to command-specific callback if set. Otherwise, pass to
+  // group-dispatch callback
+  if (uic_mqtt_dotdot_by_group_unify_switch_color_set_color_callback != nullptr) {
+
+    
+    uic_mqtt_dotdot_unify_switch_color_command_set_color_fields_t fields;
+
+
+      nlohmann::json jsn;
+      try {
+        jsn = nlohmann::json::parse(std::string(message));
+
+      
+        uic_mqtt_dotdot_parse_unify_switch_color_set_color(
+          jsn,
+          fields.color_component_id,
+              
+          fields.value,
+              
+          fields.duration
+              );
+
+      // Populate list fields from vector or string types
+      
+
+      } catch (const nlohmann::json::parse_error& e) {
+        // Catch JSON object field parsing errors
+        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "UnifySwitchColor", "SetColor");
+        return;
+      } catch (const nlohmann::json::exception& e) {
+        // Catch JSON object field parsing errors
+        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "UnifySwitchColor", "SetColor", e.what());
+        return;
+      } catch (const std::exception& e) {
+        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "UnifySwitchColor", "SetColor", "");
+        return;
+      }
+
+      uic_mqtt_dotdot_by_group_unify_switch_color_set_color_callback(
+        group_id,
+        &fields
+      );
+  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_unify_switch_color_set_color_callback().empty())) {
+    // group-dispatch callback only called if the command-specific by-unid
+    // callback is set
+    try {
+      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
+      if (jsn.find("ColorComponentId") == jsn.end()) {
+        sl_log_debug(LOG_TAG, "UnifySwitchColor::SetColor: Missing command-argument: ColorComponentId\n");
+        return;
+      }
+      if (jsn.find("Value") == jsn.end()) {
+        sl_log_debug(LOG_TAG, "UnifySwitchColor::SetColor: Missing command-argument: Value\n");
+        return;
+      }
+      if (jsn.find("Duration") == jsn.end()) {
+        sl_log_debug(LOG_TAG, "UnifySwitchColor::SetColor: Missing command-argument: Duration\n");
+        return;
+      }
+
+      group_dispatch_callback(
+        group_id,
+        "UnifySwitchColor",
+        "SetColor",
+        message,
+        message_length,
+        uic_mqtt_dotdot_on_unify_switch_color_set_color);
+
+    } catch (...) {
+      sl_log_debug(LOG_TAG, "SetColor: Unable to parse JSON payload.\n");
+      return;
+    }
+  }
+
+}
+
+// Callback function for incoming publications on ucl/by-group/+/UnifySwitchColor/Commands/StartStopChange
+static void uic_mqtt_dotdot_on_by_group_unify_switch_color_start_stop_change(
+  const char *topic,
+  const char *message,
+  const size_t message_length)
+{
+  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_unify_switch_color_start_stop_change_callback == nullptr)) {
+    return;
+  }
+  if (message_length == 0) {
+    return;
+  }
+
+  dotdot_group_id_t group_id = 0U;
+  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
+    sl_log_debug(LOG_TAG,
+                "Failed to parse GroupId from topic %s. Ignoring",
+                topic);
+    return;
+  }
+
+  // Pass to command-specific callback if set. Otherwise, pass to
+  // group-dispatch callback
+  if (uic_mqtt_dotdot_by_group_unify_switch_color_start_stop_change_callback != nullptr) {
+
+    
+    uic_mqtt_dotdot_unify_switch_color_command_start_stop_change_fields_t fields;
+
+
+      nlohmann::json jsn;
+      try {
+        jsn = nlohmann::json::parse(std::string(message));
+
+      
+        uic_mqtt_dotdot_parse_unify_switch_color_start_stop_change(
+          jsn,
+          fields.start_stop,
+              
+          fields.up_down,
+              
+          fields.ignor_start_level,
+              
+          fields.color_component_id,
+              
+          fields.start_level,
+              
+          fields.duration
+              );
+
+      // Populate list fields from vector or string types
+      
+
+      } catch (const nlohmann::json::parse_error& e) {
+        // Catch JSON object field parsing errors
+        sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "UnifySwitchColor", "StartStopChange");
+        return;
+      } catch (const nlohmann::json::exception& e) {
+        // Catch JSON object field parsing errors
+        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "UnifySwitchColor", "StartStopChange", e.what());
+        return;
+      } catch (const std::exception& e) {
+        sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "UnifySwitchColor", "StartStopChange", "");
+        return;
+      }
+
+      uic_mqtt_dotdot_by_group_unify_switch_color_start_stop_change_callback(
+        group_id,
+        &fields
+      );
+  } else if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_unify_switch_color_start_stop_change_callback().empty())) {
+    // group-dispatch callback only called if the command-specific by-unid
+    // callback is set
+    try {
+      nlohmann::json jsn = nlohmann::json::parse(std::string(message));
+      if (jsn.find("StartStop") == jsn.end()) {
+        sl_log_debug(LOG_TAG, "UnifySwitchColor::StartStopChange: Missing command-argument: StartStop\n");
+        return;
+      }
+      if (jsn.find("UpDown") == jsn.end()) {
+        sl_log_debug(LOG_TAG, "UnifySwitchColor::StartStopChange: Missing command-argument: UpDown\n");
+        return;
+      }
+      if (jsn.find("IgnorStartLevel") == jsn.end()) {
+        sl_log_debug(LOG_TAG, "UnifySwitchColor::StartStopChange: Missing command-argument: IgnorStartLevel\n");
+        return;
+      }
+      if (jsn.find("ColorComponentId") == jsn.end()) {
+        sl_log_debug(LOG_TAG, "UnifySwitchColor::StartStopChange: Missing command-argument: ColorComponentId\n");
+        return;
+      }
+      if (jsn.find("StartLevel") == jsn.end()) {
+        sl_log_debug(LOG_TAG, "UnifySwitchColor::StartStopChange: Missing command-argument: StartLevel\n");
+        return;
+      }
+      if (jsn.find("Duration") == jsn.end()) {
+        sl_log_debug(LOG_TAG, "UnifySwitchColor::StartStopChange: Missing command-argument: Duration\n");
+        return;
+      }
+
+      group_dispatch_callback(
+        group_id,
+        "UnifySwitchColor",
+        "StartStopChange",
+        message,
+        message_length,
+        uic_mqtt_dotdot_on_unify_switch_color_start_stop_change);
+
+    } catch (...) {
+      sl_log_debug(LOG_TAG, "StartStopChange: Unable to parse JSON payload.\n");
+      return;
+    }
+  }
+
+}
+
+static void uic_mqtt_dotdot_on_by_group_unify_switch_color_WriteAttributes(
+  const char *topic,
+  const char *message,
+  const size_t message_length)
+{
+
+  if ((group_dispatch_callback == nullptr) && (uic_mqtt_dotdot_by_group_unify_switch_color_write_attributes_callback == nullptr)) {
+    return;
+  }
+  if (message_length == 0) {
+    return;
+  }
+
+  dotdot_group_id_t group_id = 0U;
+  if(!uic_dotdot_mqtt::parse_topic_group_id(topic,group_id)) {
+    sl_log_debug(LOG_TAG,
+                "Failed to parse GroupId from topic %s. Ignoring",
+                topic);
+    return;
+  }
+
+  if ((group_dispatch_callback != nullptr) && (!get_uic_mqtt_dotdot_unify_switch_color_write_attributes_callback().empty())) {
+    try {
+      group_dispatch_callback(group_id,
+                              "UnifySwitchColor",
+                              "WriteAttributes",
+                              message,
+                              message_length,
+                              uic_mqtt_dotdot_on_unify_switch_color_WriteAttributes);
+
+    } catch (...) {
+      sl_log_debug(LOG_TAG, "UnifySwitchColor: Unable to parse JSON payload.\n");
+      return;
+    }
+  } else if (uic_mqtt_dotdot_by_group_unify_switch_color_write_attributes_callback != nullptr) {
+
+    uic_mqtt_dotdot_unify_switch_color_state_t new_state = {};
+    uic_mqtt_dotdot_unify_switch_color_updated_state_t new_updated_state = {};
+    
+
+    nlohmann::json jsn;
+    try {
+      jsn = nlohmann::json::parse(std::string(message));
+
+      uic_mqtt_dotdot_parse_unify_switch_color_write_attributes(
+        jsn,
+        new_state,
+        new_updated_state
+      );
+    } catch (const nlohmann::json::parse_error& e) {
+      // Catch JSON object field parsing errors
+      sl_log_debug(LOG_TAG, LOG_FMT_JSON_PARSE_FAIL, "UnifySwitchColor", "WriteAttributes");
+      return;
+    } catch (const nlohmann::json::exception& e) {
+      // Catch JSON object field parsing errors
+      sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "UnifySwitchColor", "WriteAttributes", e.what());
+      return;
+    } catch (const std::exception& e) {
+      sl_log_debug(LOG_TAG, LOG_FMT_JSON_ERROR, "UnifySwitchColor", "WriteAttributes", "");
+      return;
+    }
+
+    uic_mqtt_dotdot_by_group_unify_switch_color_write_attributes_callback(
+      group_id,
+      new_state,
+      new_updated_state
+    );
+  }
+}
+
+sl_status_t uic_mqtt_dotdot_by_group_unify_switch_color_init()
+{
+  std::string subscription_topic;
+  const std::string topic_bygroup = TOPIC_BY_GROUP_PREFIX;
+  if(uic_mqtt_dotdot_by_group_unify_switch_color_write_attributes_callback) {
+    subscription_topic = topic_bygroup + "UnifySwitchColor/Commands/WriteAttributes";
+    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_unify_switch_color_WriteAttributes);
+  }
+  if (uic_mqtt_dotdot_by_group_unify_switch_color_set_color_callback) {
+    subscription_topic = topic_bygroup + "UnifySwitchColor/Commands/SetColor";
+    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_unify_switch_color_set_color);
+  }
+  if (uic_mqtt_dotdot_by_group_unify_switch_color_start_stop_change_callback) {
+    subscription_topic = topic_bygroup + "UnifySwitchColor/Commands/StartStopChange";
+    uic_mqtt_subscribe(subscription_topic.c_str(), uic_mqtt_dotdot_on_by_group_unify_switch_color_start_stop_change);
+  }
+
+  return SL_STATUS_OK;
+}
+
+
+
 void uic_mqtt_dotdot_set_group_dispatch_callback(group_dispatch_t callback)
 {
   // Check for uninitialized value in order to subscribe with on_group handlers
@@ -26074,6 +26405,10 @@ void uic_mqtt_dotdot_set_group_dispatch_callback(group_dispatch_t callback)
     uic_mqtt_subscribe("ucl/by-group/+/UnifyHumidityControl/Commands/ModeSet", uic_mqtt_dotdot_on_by_group_unify_humidity_control_mode_set);
     uic_mqtt_subscribe("ucl/by-group/+/UnifyHumidityControl/Commands/SetpointSet", uic_mqtt_dotdot_on_by_group_unify_humidity_control_setpoint_set);
 
+    uic_mqtt_subscribe("ucl/by-group/+/UnifySwitchColor/Commands/WriteAttributes", uic_mqtt_dotdot_on_by_group_unify_switch_color_WriteAttributes);
+    uic_mqtt_subscribe("ucl/by-group/+/UnifySwitchColor/Commands/SetColor", uic_mqtt_dotdot_on_by_group_unify_switch_color_set_color);
+    uic_mqtt_subscribe("ucl/by-group/+/UnifySwitchColor/Commands/StartStopChange", uic_mqtt_dotdot_on_by_group_unify_switch_color_start_stop_change);
+
   }
 
   group_dispatch_callback = callback;
diff --git a/components/uic_dotdot_mqtt/zap-generated/src/dotdot_mqtt_helpers.cpp b/components/uic_dotdot_mqtt/zap-generated/src/dotdot_mqtt_helpers.cpp
index 620772af1c..082fdb9bdf 100644
--- a/components/uic_dotdot_mqtt/zap-generated/src/dotdot_mqtt_helpers.cpp
+++ b/components/uic_dotdot_mqtt/zap-generated/src/dotdot_mqtt_helpers.cpp
@@ -10644,6 +10644,57 @@ std::string get_enum_value_name(
   #endif
   }
 
+  if (65441 == cluster_id) {
+  #ifdef UNIFY_SWITCH_COLOR_WARM_WHITE_ENUM_NAME_AVAILABLE
+    if (0 == attribute_id) {
+      // FIXME: Some attributes don't work because multi-upper case names end up like this: unify_switch_colorwarm_white instead of this: unify_switch_color_warm_white
+      return unify_switch_color_warm_white_get_enum_value_name(value);
+    }
+  #endif
+  #ifdef UNIFY_SWITCH_COLOR_COLD_WHITE_ENUM_NAME_AVAILABLE
+    if (1 == attribute_id) {
+      // FIXME: Some attributes don't work because multi-upper case names end up like this: unify_switch_colorcold_white instead of this: unify_switch_color_cold_white
+      return unify_switch_color_cold_white_get_enum_value_name(value);
+    }
+  #endif
+  #ifdef UNIFY_SWITCH_COLOR_RED_ENUM_NAME_AVAILABLE
+    if (2 == attribute_id) {
+      // FIXME: Some attributes don't work because multi-upper case names end up like this: unify_switch_colorred instead of this: unify_switch_color_red
+      return unify_switch_color_red_get_enum_value_name(value);
+    }
+  #endif
+  #ifdef UNIFY_SWITCH_COLOR_GREEN_ENUM_NAME_AVAILABLE
+    if (3 == attribute_id) {
+      // FIXME: Some attributes don't work because multi-upper case names end up like this: unify_switch_colorgreen instead of this: unify_switch_color_green
+      return unify_switch_color_green_get_enum_value_name(value);
+    }
+  #endif
+  #ifdef UNIFY_SWITCH_COLOR_BLUE_ENUM_NAME_AVAILABLE
+    if (4 == attribute_id) {
+      // FIXME: Some attributes don't work because multi-upper case names end up like this: unify_switch_colorblue instead of this: unify_switch_color_blue
+      return unify_switch_color_blue_get_enum_value_name(value);
+    }
+  #endif
+  #ifdef UNIFY_SWITCH_COLOR_AMBER_ENUM_NAME_AVAILABLE
+    if (5 == attribute_id) {
+      // FIXME: Some attributes don't work because multi-upper case names end up like this: unify_switch_coloramber instead of this: unify_switch_color_amber
+      return unify_switch_color_amber_get_enum_value_name(value);
+    }
+  #endif
+  #ifdef UNIFY_SWITCH_COLOR_CYAN_ENUM_NAME_AVAILABLE
+    if (6 == attribute_id) {
+      // FIXME: Some attributes don't work because multi-upper case names end up like this: unify_switch_colorcyan instead of this: unify_switch_color_cyan
+      return unify_switch_color_cyan_get_enum_value_name(value);
+    }
+  #endif
+  #ifdef UNIFY_SWITCH_COLOR_PURPLE_ENUM_NAME_AVAILABLE
+    if (7 == attribute_id) {
+      // FIXME: Some attributes don't work because multi-upper case names end up like this: unify_switch_colorpurple instead of this: unify_switch_color_purple
+      return unify_switch_color_purple_get_enum_value_name(value);
+    }
+  #endif
+  }
+
 
   std::string value_name;
   return value_name;
@@ -15202,6 +15253,57 @@ uint32_t get_enum_name_value(
   #endif
   }
 
+  if (65441 == cluster_id) {
+  #ifdef UNIFY_SWITCH_COLOR_WARM_WHITE_ENUM_NAME_AVAILABLE
+    if (0 == attribute_id) {
+      // FIXME: Some attributes don't work because multi-upper case names end up like this: unify_switch_colorwarm_white instead of this: unify_switch_color_warm_white
+      return unify_switch_color_warm_white_get_enum_value_number(name);
+    }
+  #endif
+  #ifdef UNIFY_SWITCH_COLOR_COLD_WHITE_ENUM_NAME_AVAILABLE
+    if (1 == attribute_id) {
+      // FIXME: Some attributes don't work because multi-upper case names end up like this: unify_switch_colorcold_white instead of this: unify_switch_color_cold_white
+      return unify_switch_color_cold_white_get_enum_value_number(name);
+    }
+  #endif
+  #ifdef UNIFY_SWITCH_COLOR_RED_ENUM_NAME_AVAILABLE
+    if (2 == attribute_id) {
+      // FIXME: Some attributes don't work because multi-upper case names end up like this: unify_switch_colorred instead of this: unify_switch_color_red
+      return unify_switch_color_red_get_enum_value_number(name);
+    }
+  #endif
+  #ifdef UNIFY_SWITCH_COLOR_GREEN_ENUM_NAME_AVAILABLE
+    if (3 == attribute_id) {
+      // FIXME: Some attributes don't work because multi-upper case names end up like this: unify_switch_colorgreen instead of this: unify_switch_color_green
+      return unify_switch_color_green_get_enum_value_number(name);
+    }
+  #endif
+  #ifdef UNIFY_SWITCH_COLOR_BLUE_ENUM_NAME_AVAILABLE
+    if (4 == attribute_id) {
+      // FIXME: Some attributes don't work because multi-upper case names end up like this: unify_switch_colorblue instead of this: unify_switch_color_blue
+      return unify_switch_color_blue_get_enum_value_number(name);
+    }
+  #endif
+  #ifdef UNIFY_SWITCH_COLOR_AMBER_ENUM_NAME_AVAILABLE
+    if (5 == attribute_id) {
+      // FIXME: Some attributes don't work because multi-upper case names end up like this: unify_switch_coloramber instead of this: unify_switch_color_amber
+      return unify_switch_color_amber_get_enum_value_number(name);
+    }
+  #endif
+  #ifdef UNIFY_SWITCH_COLOR_CYAN_ENUM_NAME_AVAILABLE
+    if (6 == attribute_id) {
+      // FIXME: Some attributes don't work because multi-upper case names end up like this: unify_switch_colorcyan instead of this: unify_switch_color_cyan
+      return unify_switch_color_cyan_get_enum_value_number(name);
+    }
+  #endif
+  #ifdef UNIFY_SWITCH_COLOR_PURPLE_ENUM_NAME_AVAILABLE
+    if (7 == attribute_id) {
+      // FIXME: Some attributes don't work because multi-upper case names end up like this: unify_switch_colorpurple instead of this: unify_switch_color_purple
+      return unify_switch_color_purple_get_enum_value_number(name);
+    }
+  #endif
+  }
+
 
   // No known numeric value is set for this string.
   // Return UINT32_MAX to indicate an error.
diff --git a/components/uic_dotdot_mqtt/zap-generated/src/dotdot_mqtt_send_commands.cpp b/components/uic_dotdot_mqtt/zap-generated/src/dotdot_mqtt_send_commands.cpp
index cbee8704d9..d142a852d8 100644
--- a/components/uic_dotdot_mqtt/zap-generated/src/dotdot_mqtt_send_commands.cpp
+++ b/components/uic_dotdot_mqtt/zap-generated/src/dotdot_mqtt_send_commands.cpp
@@ -15295,3 +15295,151 @@ void uic_mqtt_dotdot_unify_humidity_control_publish_setpoint_set_command_to_grou
                    payload.size(),
                    false);
 }
+
+/**
+ * @brief Sends/Publishes a SetColor command for
+ * the UnifySwitchColor cluster to a destination.
+ *
+ * Publication will be made at the following topic
+ * ucl/by-unid/UNID/epID/UnifySwitchColor/Commands/SetColor
+ *
+ * @param destination_unid      The UNID of the node that should receive the command.
+ * 
+ * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
+ * 
+ * 
+ * @param fields                Struct pointer with the fields value of the command
+ * 
+ */
+void uic_mqtt_dotdot_unify_switch_color_publish_set_color_command(
+  const dotdot_unid_t destination_unid,
+  const dotdot_endpoint_id_t destination_endpoint,
+  const uic_mqtt_dotdot_unify_switch_color_command_set_color_fields_t *fields
+  
+) {
+  // Create the topic
+  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
+                      std::to_string(destination_endpoint) + "/";
+  topic += "UnifySwitchColor/Commands/SetColor";
+
+
+  std::string payload =
+    get_json_payload_for_unify_switch_color_set_color_command(
+    fields);
+
+  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());
+
+  // Publish our command, not retained
+  uic_mqtt_publish(topic.c_str(),
+                   payload.c_str(),
+                   payload.size(),
+                   false);
+}
+
+/**
+ * @brief Sends/Publishes a SetColor command for
+ * the UnifySwitchColor cluster to a group.
+ *
+ * Publication will be made at the following topic
+ * ucl/by-group/GroupID/UnifySwitchColor/Commands/SetColor
+ *
+ * @param destination_group_id  The GroupID that should receive the command.
+ * 
+ * @param fields                Struct pointer with the fields value of the command
+ * 
+ */
+void uic_mqtt_dotdot_unify_switch_color_publish_set_color_command_to_group(
+  uint16_t destination_group_id,
+  const uic_mqtt_dotdot_unify_switch_color_command_set_color_fields_t *fields
+  
+){
+  // Create the topic
+  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
+                      "/UnifySwitchColor/Commands/SetColor";
+
+  std::string payload =
+    get_json_payload_for_unify_switch_color_set_color_command(
+    fields);
+
+  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());
+
+  // Publish our command, not retained
+  uic_mqtt_publish(topic.c_str(),
+                   payload.c_str(),
+                   payload.size(),
+                   false);
+}
+
+/**
+ * @brief Sends/Publishes a StartStopChange command for
+ * the UnifySwitchColor cluster to a destination.
+ *
+ * Publication will be made at the following topic
+ * ucl/by-unid/UNID/epID/UnifySwitchColor/Commands/StartStopChange
+ *
+ * @param destination_unid      The UNID of the node that should receive the command.
+ * 
+ * @param destination_endpoint  The Endpoint ID of the node that should receive the command.
+ * 
+ * 
+ * @param fields                Struct pointer with the fields value of the command
+ * 
+ */
+void uic_mqtt_dotdot_unify_switch_color_publish_start_stop_change_command(
+  const dotdot_unid_t destination_unid,
+  const dotdot_endpoint_id_t destination_endpoint,
+  const uic_mqtt_dotdot_unify_switch_color_command_start_stop_change_fields_t *fields
+  
+) {
+  // Create the topic
+  std::string topic = "ucl/by-unid/"+ std::string(destination_unid) + "/ep" +
+                      std::to_string(destination_endpoint) + "/";
+  topic += "UnifySwitchColor/Commands/StartStopChange";
+
+
+  std::string payload =
+    get_json_payload_for_unify_switch_color_start_stop_change_command(
+    fields);
+
+  sl_log_debug(LOG_TAG, "Sending command to %s with payload %s ---", topic.c_str() , payload.c_str());
+
+  // Publish our command, not retained
+  uic_mqtt_publish(topic.c_str(),
+                   payload.c_str(),
+                   payload.size(),
+                   false);
+}
+
+/**
+ * @brief Sends/Publishes a StartStopChange command for
+ * the UnifySwitchColor cluster to a group.
+ *
+ * Publication will be made at the following topic
+ * ucl/by-group/GroupID/UnifySwitchColor/Commands/StartStopChange
+ *
+ * @param destination_group_id  The GroupID that should receive the command.
+ * 
+ * @param fields                Struct pointer with the fields value of the command
+ * 
+ */
+void uic_mqtt_dotdot_unify_switch_color_publish_start_stop_change_command_to_group(
+  uint16_t destination_group_id,
+  const uic_mqtt_dotdot_unify_switch_color_command_start_stop_change_fields_t *fields
+  
+){
+  // Create the topic
+  std::string topic = "ucl/by-group/"+ std::to_string(destination_group_id) +
+                      "/UnifySwitchColor/Commands/StartStopChange";
+
+  std::string payload =
+    get_json_payload_for_unify_switch_color_start_stop_change_command(
+    fields);
+
+  sl_log_info(LOG_TAG, "Sending group command to %s with payload %s ---", topic.c_str() , payload.c_str());
+
+  // Publish our command, not retained
+  uic_mqtt_publish(topic.c_str(),
+                   payload.c_str(),
+                   payload.size(),
+                   false);
+}
diff --git a/components/uic_dotdot_mqtt/zap-generated/src/dotdot_mqtt_supported_generated_commands.cpp b/components/uic_dotdot_mqtt/zap-generated/src/dotdot_mqtt_supported_generated_commands.cpp
index a615166fa3..0229839e9f 100644
--- a/components/uic_dotdot_mqtt/zap-generated/src/dotdot_mqtt_supported_generated_commands.cpp
+++ b/components/uic_dotdot_mqtt/zap-generated/src/dotdot_mqtt_supported_generated_commands.cpp
@@ -2964,3 +2964,52 @@ void uic_mqtt_dotdot_unify_humidity_control_publish_supported_generated_commands
 
 }
 
+
+/**
+ * @brief Sends/Publishes a the SupportedGenerated commands for
+ * the UnifySwitchColor cluster for a UNID/Endpoint
+ *
+ * Publication will be made at the following topic
+ * ucl/by-unid/UNID/epID/UnifySwitchColor/SupportedGeneratedCommands
+ *
+ * @param unid      The UNID of the node on behalf of which the advertisment is made
+ * 
+ * @param endpoint  The Endpoint ID of the node on behalf of which the advertisment is made
+ * 
+ * @param command_list      Struct pointer with the fields value indicating if
+ *                          individual commands can be generated.
+ */
+void uic_mqtt_dotdot_unify_switch_color_publish_supported_generated_commands(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint,
+  const uic_mqtt_dotdot_unify_switch_color_supported_commands_t *command_list)
+{
+  std::string topic = "ucl/by-unid/" + std::string(unid);
+  topic +=  "/ep"+ std::to_string(endpoint);
+  topic +=  "/UnifySwitchColor/SupportedGeneratedCommands";
+
+  // Assemble of vector of strings for the Supported Commands:
+  std::vector<std::string> command_vector;
+  if (command_list->set_color == true) {
+    command_vector.emplace_back("SetColor");
+  }
+  if (command_list->start_stop_change == true) {
+    command_vector.emplace_back("StartStopChange");
+  }
+  if (command_list->write_attributes == true) {
+    command_vector.emplace_back("WriteAttributes");
+  }
+
+  // JSONify, then Stringify
+  nlohmann::json json_payload;
+  json_payload["value"] = command_vector;
+  std::string string_payload = json_payload.dump();
+
+  // Publish to MQTT
+  uic_mqtt_publish(topic.c_str(),
+                   string_payload.c_str(),
+                   string_payload.length(),
+                   true);
+
+}
+
diff --git a/components/uic_dotdot_mqtt/zap-generated/test/dotdot_mqtt_test.include b/components/uic_dotdot_mqtt/zap-generated/test/dotdot_mqtt_test.include
index 89a5002b0f..0ce338a51e 100644
--- a/components/uic_dotdot_mqtt/zap-generated/test/dotdot_mqtt_test.include
+++ b/components/uic_dotdot_mqtt/zap-generated/test/dotdot_mqtt_test.include
@@ -3339,6 +3339,46 @@ static sl_status_t uic_mqtt_dotdot_unify_humidity_control_setpoint_set_callback_
   return SL_STATUS_OK;
 }
 
+static unsigned int uic_mqtt_dotdot_unify_switch_color_set_color_callback_count;
+static sl_status_t uic_mqtt_dotdot_unify_switch_color_set_color_callback_func(
+    dotdot_unid_t unid,
+    dotdot_endpoint_id_t endpoint,
+    uic_mqtt_dotdot_callback_call_type_t callback_type,
+    uint8_t color_component_id,
+
+    uint8_t value,
+
+    uint32_t duration
+
+) {
+  uic_mqtt_dotdot_unify_switch_color_set_color_callback_count++;
+  num_command_callbacks++;
+  return SL_STATUS_OK;
+}
+
+static unsigned int uic_mqtt_dotdot_unify_switch_color_start_stop_change_callback_count;
+static sl_status_t uic_mqtt_dotdot_unify_switch_color_start_stop_change_callback_func(
+    dotdot_unid_t unid,
+    dotdot_endpoint_id_t endpoint,
+    uic_mqtt_dotdot_callback_call_type_t callback_type,
+    bool start_stop,
+
+    bool up_down,
+
+    bool ignor_start_level,
+
+    uint8_t color_component_id,
+
+    uint8_t start_level,
+
+    uint32_t duration
+
+) {
+  uic_mqtt_dotdot_unify_switch_color_start_stop_change_callback_count++;
+  num_command_callbacks++;
+  return SL_STATUS_OK;
+}
+
 static unsigned int set_all_callbacks()
 {
   unsigned int num_callbacks = 0;
@@ -3765,6 +3805,10 @@ static unsigned int set_all_callbacks()
   num_callbacks++;
   uic_mqtt_dotdot_unify_humidity_control_setpoint_set_callback_set(&uic_mqtt_dotdot_unify_humidity_control_setpoint_set_callback_func);
   num_callbacks++;
+  uic_mqtt_dotdot_unify_switch_color_set_color_callback_set(&uic_mqtt_dotdot_unify_switch_color_set_color_callback_func);
+  num_callbacks++;
+  uic_mqtt_dotdot_unify_switch_color_start_stop_change_callback_set(&uic_mqtt_dotdot_unify_switch_color_start_stop_change_callback_func);
+  num_callbacks++;
   return num_callbacks;
 }
 
@@ -4036,6 +4080,9 @@ static void unset_all_callbacks()
   uic_mqtt_dotdot_unify_humidity_control_mode_set_callback_clear();
   uic_mqtt_dotdot_unify_humidity_control_setpoint_set_callback_clear();
   uic_mqtt_dotdot_clear_unify_humidity_control_write_attributes_callbacks();
+  uic_mqtt_dotdot_unify_switch_color_set_color_callback_clear();
+  uic_mqtt_dotdot_unify_switch_color_start_stop_change_callback_clear();
+  uic_mqtt_dotdot_clear_unify_switch_color_write_attributes_callbacks();
 }
 
 static void reset_callback_counters()
@@ -4252,4 +4299,6 @@ static void reset_callback_counters()
   uic_mqtt_dotdot_unify_fan_control_turn_off_callback_count = 0;
   uic_mqtt_dotdot_unify_humidity_control_mode_set_callback_count = 0;
   uic_mqtt_dotdot_unify_humidity_control_setpoint_set_callback_count = 0;
+  uic_mqtt_dotdot_unify_switch_color_set_color_callback_count = 0;
+  uic_mqtt_dotdot_unify_switch_color_start_stop_change_callback_count = 0;
 }
diff --git a/components/unify_dotdot_attribute_store/zap-generated/include/dotdot_attributes.uam b/components/unify_dotdot_attribute_store/zap-generated/include/dotdot_attributes.uam
index 68ed25df42..b3cb71a58e 100644
--- a/components/unify_dotdot_attribute_store/zap-generated/include/dotdot_attributes.uam
+++ b/components/unify_dotdot_attribute_store/zap-generated/include/dotdot_attributes.uam
@@ -904,3 +904,13 @@ def DOTDOT_ATTRIBUTE_ID_UNIFY_HUMIDITY_CONTROL_AUTO_SETPOINT 0xfda00011
 def DOTDOT_ATTRIBUTE_ID_UNIFY_HUMIDITY_CONTROL_AUTO_SETPOINT_SCALE 0xfda00012
 def DOTDOT_ATTRIBUTE_ID_UNIFY_HUMIDITY_CONTROL_AUTO_SETPOINT_PRECISION 0xfda00013
 
+// This represents the attributes in the DotDot UnifySwitchColor cluster
+def DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_WARM_WHITE 0xffa10000
+def DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_COLD_WHITE 0xffa10001
+def DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_RED 0xffa10002
+def DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_GREEN 0xffa10003
+def DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_BLUE 0xffa10004
+def DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_AMBER 0xffa10005
+def DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_CYAN 0xffa10006
+def DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_PURPLE 0xffa10007
+
diff --git a/components/unify_dotdot_attribute_store/zap-generated/include/dotdot_attributes_camel_case.uam b/components/unify_dotdot_attribute_store/zap-generated/include/dotdot_attributes_camel_case.uam
index 440dddc2ea..ede33f9966 100644
--- a/components/unify_dotdot_attribute_store/zap-generated/include/dotdot_attributes_camel_case.uam
+++ b/components/unify_dotdot_attribute_store/zap-generated/include/dotdot_attributes_camel_case.uam
@@ -904,3 +904,13 @@ def zb_AutoSetpoint 0xfda00011
 def zb_AutoSetpointScale 0xfda00012
 def zb_AutoSetpointPrecision 0xfda00013
 
+// This represents short CamelCase labels the attributes in the DotDot UnifySwitchColor cluster
+def zb_WarmWhite 0xffa10000
+def zb_ColdWhite 0xffa10001
+def zb_Red 0xffa10002
+def zb_Green 0xffa10003
+def zb_Blue 0xffa10004
+def zb_Amber 0xffa10005
+def zb_Cyan 0xffa10006
+def zb_Purple 0xffa10007
+
diff --git a/components/unify_dotdot_attribute_store/zap-generated/include/unify_dotdot_attribute_store_helpers.h b/components/unify_dotdot_attribute_store/zap-generated/include/unify_dotdot_attribute_store_helpers.h
index 8027848315..9ebb9bc489 100644
--- a/components/unify_dotdot_attribute_store/zap-generated/include/unify_dotdot_attribute_store_helpers.h
+++ b/components/unify_dotdot_attribute_store/zap-generated/include/unify_dotdot_attribute_store_helpers.h
@@ -79177,6 +79177,882 @@ bool dotdot_is_any_unify_humidity_control_writable_attribute_supported(
   const dotdot_unid_t unid,
   const dotdot_endpoint_id_t endpoint_id);
 
+////////////////////////////////////////////////////////////////////////////////
+// Start of cluster UnifySwitchColor
+////////////////////////////////////////////////////////////////////////////////
+// UnifySwitchColor WarmWhite
+/**
+ * @brief Verifies if the DotDot UnifySwitchColor - WarmWhite is supported
+ * under a UNID/EndpoinID
+ *
+ * @param unid          Node's UNID
+ * @param endpoint_id   Endpoint ID
+ *
+ * @returns true if WarmWhite is supported
+ * @returns false if WarmWhite is not supported
+ */
+bool dotdot_is_supported_unify_switch_color_warm_white (
+              const dotdot_unid_t unid, const dotdot_endpoint_id_t endpoint_id);
+
+/**
+ * @brief Gets the DotDot UnifySwitchColor - WarmWhite attribute value under a UNID/EndpoinID
+ *
+ * @param unid          Node's UNID
+ * @param endpoint_id   Endpoint ID
+ * @param value_state   value state to get,
+ *                      see \ref attribute_store_get_node_attribute_value
+ * 
+ *
+ * @returns WarmWhite attribute
+ */
+uint8_t dotdot_get_unify_switch_color_warm_white(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id,
+  attribute_store_node_value_state_t value_state);
+
+/**
+ * @brief Set the DotDot UnifySwitchColor - WarmWhite attribute under a UNID/EndpoinID
+ *
+ * @param unid          Node's UNID
+ * @param endpoint_id   Endpoint ID
+ * @param value_state   value state to write for the node,
+ *                      see \ref attribute_store_set_node_attribute_value
+ * 
+ * @param new_warm_white new value to set
+ * @returns sl_status_t SL_STATUS_OK on success
+ */
+sl_status_t dotdot_set_unify_switch_color_warm_white(
+  const dotdot_unid_t unid,
+  dotdot_endpoint_id_t endpoint_id,
+  attribute_store_node_value_state_t value_state,
+  uint8_t new_warm_white
+  );
+
+/**
+ * @brief Undefines the Reported value of the the DotDot UnifySwitchColor - WarmWhite
+ * attribute under a UNID/EndpoinID
+ *
+ * @param unid          Node's UNID
+ * @param endpoint_id   Endpoint ID
+ * @returns sl_status_t SL_STATUS_OK on success
+ */
+sl_status_t dotdot_unify_switch_color_warm_white_undefine_reported(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id);
+
+/**
+ * @brief Undefines the Desired value of the DotDot
+ * UnifySwitchColor - WarmWhite attribute under a UNID/EndpointID
+ *
+ * @param unid          Node's UNID
+ * @param endpoint_id   Endpoint ID
+ * @returns sl_status_t SL_STATUS_OK on success
+ */
+sl_status_t dotdot_unify_switch_color_warm_white_undefine_desired(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id);
+
+/**
+ * @brief Checks if the reported value is defined for the DotDot
+ * UnifySwitchColor - WarmWhite attribute under a UNID/EndpointID
+ *
+ * @param unid          Node's UNID
+ * @param endpoint_id   Endpoint ID
+ * @returns true if defined, false is undefined or non-existent
+ */
+bool dotdot_unify_switch_color_warm_white_is_reported_defined(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id);
+
+/**
+ * @brief Checks if the desired value is defined for the DotDot
+ * UnifySwitchColor - WarmWhite attribute under a UNID/EndpointID
+ *
+ * @param unid          Node's UNID
+ * @param endpoint_id   Endpoint ID
+ * @returns true if defined, false is undefined or non-existent
+ */
+bool dotdot_unify_switch_color_warm_white_is_desired_defined(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id);
+
+/**
+ * @brief Creates a DotDot UnifySwitchColor - WarmWhite attribute under a UNID/EndpoinID
+ *
+ * @param unid          Node's UNID
+ * @param endpoint_id   Endpoint ID
+ * @returns sl_status_t SL_STATUS_OK on success
+ */
+sl_status_t dotdot_create_unify_switch_color_warm_white(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id);
+// UnifySwitchColor ColdWhite
+/**
+ * @brief Verifies if the DotDot UnifySwitchColor - ColdWhite is supported
+ * under a UNID/EndpoinID
+ *
+ * @param unid          Node's UNID
+ * @param endpoint_id   Endpoint ID
+ *
+ * @returns true if ColdWhite is supported
+ * @returns false if ColdWhite is not supported
+ */
+bool dotdot_is_supported_unify_switch_color_cold_white (
+              const dotdot_unid_t unid, const dotdot_endpoint_id_t endpoint_id);
+
+/**
+ * @brief Gets the DotDot UnifySwitchColor - ColdWhite attribute value under a UNID/EndpoinID
+ *
+ * @param unid          Node's UNID
+ * @param endpoint_id   Endpoint ID
+ * @param value_state   value state to get,
+ *                      see \ref attribute_store_get_node_attribute_value
+ * 
+ *
+ * @returns ColdWhite attribute
+ */
+uint8_t dotdot_get_unify_switch_color_cold_white(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id,
+  attribute_store_node_value_state_t value_state);
+
+/**
+ * @brief Set the DotDot UnifySwitchColor - ColdWhite attribute under a UNID/EndpoinID
+ *
+ * @param unid          Node's UNID
+ * @param endpoint_id   Endpoint ID
+ * @param value_state   value state to write for the node,
+ *                      see \ref attribute_store_set_node_attribute_value
+ * 
+ * @param new_cold_white new value to set
+ * @returns sl_status_t SL_STATUS_OK on success
+ */
+sl_status_t dotdot_set_unify_switch_color_cold_white(
+  const dotdot_unid_t unid,
+  dotdot_endpoint_id_t endpoint_id,
+  attribute_store_node_value_state_t value_state,
+  uint8_t new_cold_white
+  );
+
+/**
+ * @brief Undefines the Reported value of the the DotDot UnifySwitchColor - ColdWhite
+ * attribute under a UNID/EndpoinID
+ *
+ * @param unid          Node's UNID
+ * @param endpoint_id   Endpoint ID
+ * @returns sl_status_t SL_STATUS_OK on success
+ */
+sl_status_t dotdot_unify_switch_color_cold_white_undefine_reported(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id);
+
+/**
+ * @brief Undefines the Desired value of the DotDot
+ * UnifySwitchColor - ColdWhite attribute under a UNID/EndpointID
+ *
+ * @param unid          Node's UNID
+ * @param endpoint_id   Endpoint ID
+ * @returns sl_status_t SL_STATUS_OK on success
+ */
+sl_status_t dotdot_unify_switch_color_cold_white_undefine_desired(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id);
+
+/**
+ * @brief Checks if the reported value is defined for the DotDot
+ * UnifySwitchColor - ColdWhite attribute under a UNID/EndpointID
+ *
+ * @param unid          Node's UNID
+ * @param endpoint_id   Endpoint ID
+ * @returns true if defined, false is undefined or non-existent
+ */
+bool dotdot_unify_switch_color_cold_white_is_reported_defined(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id);
+
+/**
+ * @brief Checks if the desired value is defined for the DotDot
+ * UnifySwitchColor - ColdWhite attribute under a UNID/EndpointID
+ *
+ * @param unid          Node's UNID
+ * @param endpoint_id   Endpoint ID
+ * @returns true if defined, false is undefined or non-existent
+ */
+bool dotdot_unify_switch_color_cold_white_is_desired_defined(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id);
+
+/**
+ * @brief Creates a DotDot UnifySwitchColor - ColdWhite attribute under a UNID/EndpoinID
+ *
+ * @param unid          Node's UNID
+ * @param endpoint_id   Endpoint ID
+ * @returns sl_status_t SL_STATUS_OK on success
+ */
+sl_status_t dotdot_create_unify_switch_color_cold_white(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id);
+// UnifySwitchColor Red
+/**
+ * @brief Verifies if the DotDot UnifySwitchColor - Red is supported
+ * under a UNID/EndpoinID
+ *
+ * @param unid          Node's UNID
+ * @param endpoint_id   Endpoint ID
+ *
+ * @returns true if Red is supported
+ * @returns false if Red is not supported
+ */
+bool dotdot_is_supported_unify_switch_color_red (
+              const dotdot_unid_t unid, const dotdot_endpoint_id_t endpoint_id);
+
+/**
+ * @brief Gets the DotDot UnifySwitchColor - Red attribute value under a UNID/EndpoinID
+ *
+ * @param unid          Node's UNID
+ * @param endpoint_id   Endpoint ID
+ * @param value_state   value state to get,
+ *                      see \ref attribute_store_get_node_attribute_value
+ * 
+ *
+ * @returns Red attribute
+ */
+uint8_t dotdot_get_unify_switch_color_red(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id,
+  attribute_store_node_value_state_t value_state);
+
+/**
+ * @brief Set the DotDot UnifySwitchColor - Red attribute under a UNID/EndpoinID
+ *
+ * @param unid          Node's UNID
+ * @param endpoint_id   Endpoint ID
+ * @param value_state   value state to write for the node,
+ *                      see \ref attribute_store_set_node_attribute_value
+ * 
+ * @param new_red new value to set
+ * @returns sl_status_t SL_STATUS_OK on success
+ */
+sl_status_t dotdot_set_unify_switch_color_red(
+  const dotdot_unid_t unid,
+  dotdot_endpoint_id_t endpoint_id,
+  attribute_store_node_value_state_t value_state,
+  uint8_t new_red
+  );
+
+/**
+ * @brief Undefines the Reported value of the the DotDot UnifySwitchColor - Red
+ * attribute under a UNID/EndpoinID
+ *
+ * @param unid          Node's UNID
+ * @param endpoint_id   Endpoint ID
+ * @returns sl_status_t SL_STATUS_OK on success
+ */
+sl_status_t dotdot_unify_switch_color_red_undefine_reported(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id);
+
+/**
+ * @brief Undefines the Desired value of the DotDot
+ * UnifySwitchColor - Red attribute under a UNID/EndpointID
+ *
+ * @param unid          Node's UNID
+ * @param endpoint_id   Endpoint ID
+ * @returns sl_status_t SL_STATUS_OK on success
+ */
+sl_status_t dotdot_unify_switch_color_red_undefine_desired(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id);
+
+/**
+ * @brief Checks if the reported value is defined for the DotDot
+ * UnifySwitchColor - Red attribute under a UNID/EndpointID
+ *
+ * @param unid          Node's UNID
+ * @param endpoint_id   Endpoint ID
+ * @returns true if defined, false is undefined or non-existent
+ */
+bool dotdot_unify_switch_color_red_is_reported_defined(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id);
+
+/**
+ * @brief Checks if the desired value is defined for the DotDot
+ * UnifySwitchColor - Red attribute under a UNID/EndpointID
+ *
+ * @param unid          Node's UNID
+ * @param endpoint_id   Endpoint ID
+ * @returns true if defined, false is undefined or non-existent
+ */
+bool dotdot_unify_switch_color_red_is_desired_defined(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id);
+
+/**
+ * @brief Creates a DotDot UnifySwitchColor - Red attribute under a UNID/EndpoinID
+ *
+ * @param unid          Node's UNID
+ * @param endpoint_id   Endpoint ID
+ * @returns sl_status_t SL_STATUS_OK on success
+ */
+sl_status_t dotdot_create_unify_switch_color_red(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id);
+// UnifySwitchColor Green
+/**
+ * @brief Verifies if the DotDot UnifySwitchColor - Green is supported
+ * under a UNID/EndpoinID
+ *
+ * @param unid          Node's UNID
+ * @param endpoint_id   Endpoint ID
+ *
+ * @returns true if Green is supported
+ * @returns false if Green is not supported
+ */
+bool dotdot_is_supported_unify_switch_color_green (
+              const dotdot_unid_t unid, const dotdot_endpoint_id_t endpoint_id);
+
+/**
+ * @brief Gets the DotDot UnifySwitchColor - Green attribute value under a UNID/EndpoinID
+ *
+ * @param unid          Node's UNID
+ * @param endpoint_id   Endpoint ID
+ * @param value_state   value state to get,
+ *                      see \ref attribute_store_get_node_attribute_value
+ * 
+ *
+ * @returns Green attribute
+ */
+uint8_t dotdot_get_unify_switch_color_green(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id,
+  attribute_store_node_value_state_t value_state);
+
+/**
+ * @brief Set the DotDot UnifySwitchColor - Green attribute under a UNID/EndpoinID
+ *
+ * @param unid          Node's UNID
+ * @param endpoint_id   Endpoint ID
+ * @param value_state   value state to write for the node,
+ *                      see \ref attribute_store_set_node_attribute_value
+ * 
+ * @param new_green new value to set
+ * @returns sl_status_t SL_STATUS_OK on success
+ */
+sl_status_t dotdot_set_unify_switch_color_green(
+  const dotdot_unid_t unid,
+  dotdot_endpoint_id_t endpoint_id,
+  attribute_store_node_value_state_t value_state,
+  uint8_t new_green
+  );
+
+/**
+ * @brief Undefines the Reported value of the the DotDot UnifySwitchColor - Green
+ * attribute under a UNID/EndpoinID
+ *
+ * @param unid          Node's UNID
+ * @param endpoint_id   Endpoint ID
+ * @returns sl_status_t SL_STATUS_OK on success
+ */
+sl_status_t dotdot_unify_switch_color_green_undefine_reported(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id);
+
+/**
+ * @brief Undefines the Desired value of the DotDot
+ * UnifySwitchColor - Green attribute under a UNID/EndpointID
+ *
+ * @param unid          Node's UNID
+ * @param endpoint_id   Endpoint ID
+ * @returns sl_status_t SL_STATUS_OK on success
+ */
+sl_status_t dotdot_unify_switch_color_green_undefine_desired(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id);
+
+/**
+ * @brief Checks if the reported value is defined for the DotDot
+ * UnifySwitchColor - Green attribute under a UNID/EndpointID
+ *
+ * @param unid          Node's UNID
+ * @param endpoint_id   Endpoint ID
+ * @returns true if defined, false is undefined or non-existent
+ */
+bool dotdot_unify_switch_color_green_is_reported_defined(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id);
+
+/**
+ * @brief Checks if the desired value is defined for the DotDot
+ * UnifySwitchColor - Green attribute under a UNID/EndpointID
+ *
+ * @param unid          Node's UNID
+ * @param endpoint_id   Endpoint ID
+ * @returns true if defined, false is undefined or non-existent
+ */
+bool dotdot_unify_switch_color_green_is_desired_defined(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id);
+
+/**
+ * @brief Creates a DotDot UnifySwitchColor - Green attribute under a UNID/EndpoinID
+ *
+ * @param unid          Node's UNID
+ * @param endpoint_id   Endpoint ID
+ * @returns sl_status_t SL_STATUS_OK on success
+ */
+sl_status_t dotdot_create_unify_switch_color_green(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id);
+// UnifySwitchColor Blue
+/**
+ * @brief Verifies if the DotDot UnifySwitchColor - Blue is supported
+ * under a UNID/EndpoinID
+ *
+ * @param unid          Node's UNID
+ * @param endpoint_id   Endpoint ID
+ *
+ * @returns true if Blue is supported
+ * @returns false if Blue is not supported
+ */
+bool dotdot_is_supported_unify_switch_color_blue (
+              const dotdot_unid_t unid, const dotdot_endpoint_id_t endpoint_id);
+
+/**
+ * @brief Gets the DotDot UnifySwitchColor - Blue attribute value under a UNID/EndpoinID
+ *
+ * @param unid          Node's UNID
+ * @param endpoint_id   Endpoint ID
+ * @param value_state   value state to get,
+ *                      see \ref attribute_store_get_node_attribute_value
+ * 
+ *
+ * @returns Blue attribute
+ */
+uint8_t dotdot_get_unify_switch_color_blue(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id,
+  attribute_store_node_value_state_t value_state);
+
+/**
+ * @brief Set the DotDot UnifySwitchColor - Blue attribute under a UNID/EndpoinID
+ *
+ * @param unid          Node's UNID
+ * @param endpoint_id   Endpoint ID
+ * @param value_state   value state to write for the node,
+ *                      see \ref attribute_store_set_node_attribute_value
+ * 
+ * @param new_blue new value to set
+ * @returns sl_status_t SL_STATUS_OK on success
+ */
+sl_status_t dotdot_set_unify_switch_color_blue(
+  const dotdot_unid_t unid,
+  dotdot_endpoint_id_t endpoint_id,
+  attribute_store_node_value_state_t value_state,
+  uint8_t new_blue
+  );
+
+/**
+ * @brief Undefines the Reported value of the the DotDot UnifySwitchColor - Blue
+ * attribute under a UNID/EndpoinID
+ *
+ * @param unid          Node's UNID
+ * @param endpoint_id   Endpoint ID
+ * @returns sl_status_t SL_STATUS_OK on success
+ */
+sl_status_t dotdot_unify_switch_color_blue_undefine_reported(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id);
+
+/**
+ * @brief Undefines the Desired value of the DotDot
+ * UnifySwitchColor - Blue attribute under a UNID/EndpointID
+ *
+ * @param unid          Node's UNID
+ * @param endpoint_id   Endpoint ID
+ * @returns sl_status_t SL_STATUS_OK on success
+ */
+sl_status_t dotdot_unify_switch_color_blue_undefine_desired(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id);
+
+/**
+ * @brief Checks if the reported value is defined for the DotDot
+ * UnifySwitchColor - Blue attribute under a UNID/EndpointID
+ *
+ * @param unid          Node's UNID
+ * @param endpoint_id   Endpoint ID
+ * @returns true if defined, false is undefined or non-existent
+ */
+bool dotdot_unify_switch_color_blue_is_reported_defined(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id);
+
+/**
+ * @brief Checks if the desired value is defined for the DotDot
+ * UnifySwitchColor - Blue attribute under a UNID/EndpointID
+ *
+ * @param unid          Node's UNID
+ * @param endpoint_id   Endpoint ID
+ * @returns true if defined, false is undefined or non-existent
+ */
+bool dotdot_unify_switch_color_blue_is_desired_defined(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id);
+
+/**
+ * @brief Creates a DotDot UnifySwitchColor - Blue attribute under a UNID/EndpoinID
+ *
+ * @param unid          Node's UNID
+ * @param endpoint_id   Endpoint ID
+ * @returns sl_status_t SL_STATUS_OK on success
+ */
+sl_status_t dotdot_create_unify_switch_color_blue(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id);
+// UnifySwitchColor Amber
+/**
+ * @brief Verifies if the DotDot UnifySwitchColor - Amber is supported
+ * under a UNID/EndpoinID
+ *
+ * @param unid          Node's UNID
+ * @param endpoint_id   Endpoint ID
+ *
+ * @returns true if Amber is supported
+ * @returns false if Amber is not supported
+ */
+bool dotdot_is_supported_unify_switch_color_amber (
+              const dotdot_unid_t unid, const dotdot_endpoint_id_t endpoint_id);
+
+/**
+ * @brief Gets the DotDot UnifySwitchColor - Amber attribute value under a UNID/EndpoinID
+ *
+ * @param unid          Node's UNID
+ * @param endpoint_id   Endpoint ID
+ * @param value_state   value state to get,
+ *                      see \ref attribute_store_get_node_attribute_value
+ * 
+ *
+ * @returns Amber attribute
+ */
+uint8_t dotdot_get_unify_switch_color_amber(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id,
+  attribute_store_node_value_state_t value_state);
+
+/**
+ * @brief Set the DotDot UnifySwitchColor - Amber attribute under a UNID/EndpoinID
+ *
+ * @param unid          Node's UNID
+ * @param endpoint_id   Endpoint ID
+ * @param value_state   value state to write for the node,
+ *                      see \ref attribute_store_set_node_attribute_value
+ * 
+ * @param new_amber new value to set
+ * @returns sl_status_t SL_STATUS_OK on success
+ */
+sl_status_t dotdot_set_unify_switch_color_amber(
+  const dotdot_unid_t unid,
+  dotdot_endpoint_id_t endpoint_id,
+  attribute_store_node_value_state_t value_state,
+  uint8_t new_amber
+  );
+
+/**
+ * @brief Undefines the Reported value of the the DotDot UnifySwitchColor - Amber
+ * attribute under a UNID/EndpoinID
+ *
+ * @param unid          Node's UNID
+ * @param endpoint_id   Endpoint ID
+ * @returns sl_status_t SL_STATUS_OK on success
+ */
+sl_status_t dotdot_unify_switch_color_amber_undefine_reported(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id);
+
+/**
+ * @brief Undefines the Desired value of the DotDot
+ * UnifySwitchColor - Amber attribute under a UNID/EndpointID
+ *
+ * @param unid          Node's UNID
+ * @param endpoint_id   Endpoint ID
+ * @returns sl_status_t SL_STATUS_OK on success
+ */
+sl_status_t dotdot_unify_switch_color_amber_undefine_desired(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id);
+
+/**
+ * @brief Checks if the reported value is defined for the DotDot
+ * UnifySwitchColor - Amber attribute under a UNID/EndpointID
+ *
+ * @param unid          Node's UNID
+ * @param endpoint_id   Endpoint ID
+ * @returns true if defined, false is undefined or non-existent
+ */
+bool dotdot_unify_switch_color_amber_is_reported_defined(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id);
+
+/**
+ * @brief Checks if the desired value is defined for the DotDot
+ * UnifySwitchColor - Amber attribute under a UNID/EndpointID
+ *
+ * @param unid          Node's UNID
+ * @param endpoint_id   Endpoint ID
+ * @returns true if defined, false is undefined or non-existent
+ */
+bool dotdot_unify_switch_color_amber_is_desired_defined(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id);
+
+/**
+ * @brief Creates a DotDot UnifySwitchColor - Amber attribute under a UNID/EndpoinID
+ *
+ * @param unid          Node's UNID
+ * @param endpoint_id   Endpoint ID
+ * @returns sl_status_t SL_STATUS_OK on success
+ */
+sl_status_t dotdot_create_unify_switch_color_amber(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id);
+// UnifySwitchColor Cyan
+/**
+ * @brief Verifies if the DotDot UnifySwitchColor - Cyan is supported
+ * under a UNID/EndpoinID
+ *
+ * @param unid          Node's UNID
+ * @param endpoint_id   Endpoint ID
+ *
+ * @returns true if Cyan is supported
+ * @returns false if Cyan is not supported
+ */
+bool dotdot_is_supported_unify_switch_color_cyan (
+              const dotdot_unid_t unid, const dotdot_endpoint_id_t endpoint_id);
+
+/**
+ * @brief Gets the DotDot UnifySwitchColor - Cyan attribute value under a UNID/EndpoinID
+ *
+ * @param unid          Node's UNID
+ * @param endpoint_id   Endpoint ID
+ * @param value_state   value state to get,
+ *                      see \ref attribute_store_get_node_attribute_value
+ * 
+ *
+ * @returns Cyan attribute
+ */
+uint8_t dotdot_get_unify_switch_color_cyan(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id,
+  attribute_store_node_value_state_t value_state);
+
+/**
+ * @brief Set the DotDot UnifySwitchColor - Cyan attribute under a UNID/EndpoinID
+ *
+ * @param unid          Node's UNID
+ * @param endpoint_id   Endpoint ID
+ * @param value_state   value state to write for the node,
+ *                      see \ref attribute_store_set_node_attribute_value
+ * 
+ * @param new_cyan new value to set
+ * @returns sl_status_t SL_STATUS_OK on success
+ */
+sl_status_t dotdot_set_unify_switch_color_cyan(
+  const dotdot_unid_t unid,
+  dotdot_endpoint_id_t endpoint_id,
+  attribute_store_node_value_state_t value_state,
+  uint8_t new_cyan
+  );
+
+/**
+ * @brief Undefines the Reported value of the the DotDot UnifySwitchColor - Cyan
+ * attribute under a UNID/EndpoinID
+ *
+ * @param unid          Node's UNID
+ * @param endpoint_id   Endpoint ID
+ * @returns sl_status_t SL_STATUS_OK on success
+ */
+sl_status_t dotdot_unify_switch_color_cyan_undefine_reported(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id);
+
+/**
+ * @brief Undefines the Desired value of the DotDot
+ * UnifySwitchColor - Cyan attribute under a UNID/EndpointID
+ *
+ * @param unid          Node's UNID
+ * @param endpoint_id   Endpoint ID
+ * @returns sl_status_t SL_STATUS_OK on success
+ */
+sl_status_t dotdot_unify_switch_color_cyan_undefine_desired(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id);
+
+/**
+ * @brief Checks if the reported value is defined for the DotDot
+ * UnifySwitchColor - Cyan attribute under a UNID/EndpointID
+ *
+ * @param unid          Node's UNID
+ * @param endpoint_id   Endpoint ID
+ * @returns true if defined, false is undefined or non-existent
+ */
+bool dotdot_unify_switch_color_cyan_is_reported_defined(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id);
+
+/**
+ * @brief Checks if the desired value is defined for the DotDot
+ * UnifySwitchColor - Cyan attribute under a UNID/EndpointID
+ *
+ * @param unid          Node's UNID
+ * @param endpoint_id   Endpoint ID
+ * @returns true if defined, false is undefined or non-existent
+ */
+bool dotdot_unify_switch_color_cyan_is_desired_defined(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id);
+
+/**
+ * @brief Creates a DotDot UnifySwitchColor - Cyan attribute under a UNID/EndpoinID
+ *
+ * @param unid          Node's UNID
+ * @param endpoint_id   Endpoint ID
+ * @returns sl_status_t SL_STATUS_OK on success
+ */
+sl_status_t dotdot_create_unify_switch_color_cyan(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id);
+// UnifySwitchColor Purple
+/**
+ * @brief Verifies if the DotDot UnifySwitchColor - Purple is supported
+ * under a UNID/EndpoinID
+ *
+ * @param unid          Node's UNID
+ * @param endpoint_id   Endpoint ID
+ *
+ * @returns true if Purple is supported
+ * @returns false if Purple is not supported
+ */
+bool dotdot_is_supported_unify_switch_color_purple (
+              const dotdot_unid_t unid, const dotdot_endpoint_id_t endpoint_id);
+
+/**
+ * @brief Gets the DotDot UnifySwitchColor - Purple attribute value under a UNID/EndpoinID
+ *
+ * @param unid          Node's UNID
+ * @param endpoint_id   Endpoint ID
+ * @param value_state   value state to get,
+ *                      see \ref attribute_store_get_node_attribute_value
+ * 
+ *
+ * @returns Purple attribute
+ */
+uint8_t dotdot_get_unify_switch_color_purple(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id,
+  attribute_store_node_value_state_t value_state);
+
+/**
+ * @brief Set the DotDot UnifySwitchColor - Purple attribute under a UNID/EndpoinID
+ *
+ * @param unid          Node's UNID
+ * @param endpoint_id   Endpoint ID
+ * @param value_state   value state to write for the node,
+ *                      see \ref attribute_store_set_node_attribute_value
+ * 
+ * @param new_purple new value to set
+ * @returns sl_status_t SL_STATUS_OK on success
+ */
+sl_status_t dotdot_set_unify_switch_color_purple(
+  const dotdot_unid_t unid,
+  dotdot_endpoint_id_t endpoint_id,
+  attribute_store_node_value_state_t value_state,
+  uint8_t new_purple
+  );
+
+/**
+ * @brief Undefines the Reported value of the the DotDot UnifySwitchColor - Purple
+ * attribute under a UNID/EndpoinID
+ *
+ * @param unid          Node's UNID
+ * @param endpoint_id   Endpoint ID
+ * @returns sl_status_t SL_STATUS_OK on success
+ */
+sl_status_t dotdot_unify_switch_color_purple_undefine_reported(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id);
+
+/**
+ * @brief Undefines the Desired value of the DotDot
+ * UnifySwitchColor - Purple attribute under a UNID/EndpointID
+ *
+ * @param unid          Node's UNID
+ * @param endpoint_id   Endpoint ID
+ * @returns sl_status_t SL_STATUS_OK on success
+ */
+sl_status_t dotdot_unify_switch_color_purple_undefine_desired(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id);
+
+/**
+ * @brief Checks if the reported value is defined for the DotDot
+ * UnifySwitchColor - Purple attribute under a UNID/EndpointID
+ *
+ * @param unid          Node's UNID
+ * @param endpoint_id   Endpoint ID
+ * @returns true if defined, false is undefined or non-existent
+ */
+bool dotdot_unify_switch_color_purple_is_reported_defined(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id);
+
+/**
+ * @brief Checks if the desired value is defined for the DotDot
+ * UnifySwitchColor - Purple attribute under a UNID/EndpointID
+ *
+ * @param unid          Node's UNID
+ * @param endpoint_id   Endpoint ID
+ * @returns true if defined, false is undefined or non-existent
+ */
+bool dotdot_unify_switch_color_purple_is_desired_defined(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id);
+
+/**
+ * @brief Creates a DotDot UnifySwitchColor - Purple attribute under a UNID/EndpoinID
+ *
+ * @param unid          Node's UNID
+ * @param endpoint_id   Endpoint ID
+ * @returns sl_status_t SL_STATUS_OK on success
+ */
+sl_status_t dotdot_create_unify_switch_color_purple(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id);
+
+/**
+ * @brief Checks if a UNID/Endpoint supports any attribute for the UnifySwitchColor
+ * Cluster
+ *
+ * @param unid          Node's UNID
+ * @param endpoint_id   Endpoint ID
+ * @returns true if at least 1 attribute in the Attribute Store, false otherwise
+ */
+bool dotdot_is_any_unify_switch_color_attribute_supported(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id);
+
+/**
+ * @brief Checks if a UNID/Endpoint supports any writable attribute for the
+ * UnifySwitchColor Cluster
+ *
+ * @param unid          Node's UNID
+ * @param endpoint_id   Endpoint ID
+ * @returns true if at least 1 writable attribute in the Attribute Store, false otherwise
+ */
+bool dotdot_is_any_unify_switch_color_writable_attribute_supported(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id);
+
 #ifdef __cplusplus
 }
 #endif // __cplusplus
diff --git a/components/unify_dotdot_attribute_store/zap-generated/include/unify_dotdot_defined_attribute_types.h b/components/unify_dotdot_attribute_store/zap-generated/include/unify_dotdot_defined_attribute_types.h
index 6f3c5b0f35..6ca13e5787 100644
--- a/components/unify_dotdot_attribute_store/zap-generated/include/unify_dotdot_defined_attribute_types.h
+++ b/components/unify_dotdot_attribute_store/zap-generated/include/unify_dotdot_defined_attribute_types.h
@@ -810,6 +810,15 @@ DEFINE_ATTRIBUTE(DOTDOT_ATTRIBUTE_ID_UNIFY_HUMIDITY_CONTROL_AUTO_SETPOINT_MAX ,
 DEFINE_ATTRIBUTE(DOTDOT_ATTRIBUTE_ID_UNIFY_HUMIDITY_CONTROL_AUTO_SETPOINT , 0xfda00011)
 DEFINE_ATTRIBUTE(DOTDOT_ATTRIBUTE_ID_UNIFY_HUMIDITY_CONTROL_AUTO_SETPOINT_SCALE , 0xfda00012)
 DEFINE_ATTRIBUTE(DOTDOT_ATTRIBUTE_ID_UNIFY_HUMIDITY_CONTROL_AUTO_SETPOINT_PRECISION , 0xfda00013)
+// Attribute Defines for UnifySwitchColor
+DEFINE_ATTRIBUTE(DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_WARM_WHITE , 0xffa10000)
+DEFINE_ATTRIBUTE(DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_COLD_WHITE , 0xffa10001)
+DEFINE_ATTRIBUTE(DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_RED , 0xffa10002)
+DEFINE_ATTRIBUTE(DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_GREEN , 0xffa10003)
+DEFINE_ATTRIBUTE(DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_BLUE , 0xffa10004)
+DEFINE_ATTRIBUTE(DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_AMBER , 0xffa10005)
+DEFINE_ATTRIBUTE(DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_CYAN , 0xffa10006)
+DEFINE_ATTRIBUTE(DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_PURPLE , 0xffa10007)
 
 // Additional manually defined types:
 
diff --git a/components/unify_dotdot_attribute_store/zap-generated/src/unify_dotdot_attribute_store_attribute_publisher.cpp b/components/unify_dotdot_attribute_store/zap-generated/src/unify_dotdot_attribute_store_attribute_publisher.cpp
index 75631aebad..559bcfb380 100644
--- a/components/unify_dotdot_attribute_store/zap-generated/src/unify_dotdot_attribute_store_attribute_publisher.cpp
+++ b/components/unify_dotdot_attribute_store/zap-generated/src/unify_dotdot_attribute_store_attribute_publisher.cpp
@@ -26377,6 +26377,375 @@ static void unify_humidity_control_cluster_cluster_revision_callback(
 }
 
 
+/**
+ * @brief Publishes the desired value of an updated attribute store node for
+ * the UnifySwitchColor cluster.
+ * @param updated_node Updated attribute store node
+ * @param change       Type of change applied
+ */
+static void unify_switch_color_cluster_publish_desired_value_callback(
+   attribute_store_node_t updated_node, attribute_store_change_t change)
+{
+  // clang-format on
+  if (false == is_publish_desired_attribute_values_to_mqtt_enabled()) {
+    return;
+  }
+  if (change == ATTRIBUTE_DELETED || change == ATTRIBUTE_CREATED) {
+    return;
+  }
+  // Scene exception: check that the attribute is not under the Scene Table extension, which is a config and not the node's state.
+  if (ATTRIBUTE_STORE_INVALID_NODE
+      != attribute_store_get_first_parent_with_type(
+        updated_node,
+        DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_TABLE)) {
+    return;
+  }
+
+  // Get the UNID and EndPoint, and prepare the basic topic
+  char unid[MAXIMUM_UNID_SIZE]     = {};
+  // clang-format off
+  // clang-format on
+  dotdot_endpoint_id_t endpoint_id = 0;
+  if (SL_STATUS_OK
+      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
+                                                     unid,
+                                                     &endpoint_id)) {
+    return;
+  }
+  // clang-format off
+  // clang-format on
+
+  std::string base_topic = "ucl/by-unid/" + std::string(unid);
+  // clang-format off
+  base_topic += "/ep" + std::to_string(endpoint_id);
+  // clang-format on
+
+  attribute_store_type_t type = attribute_store_get_node_type(updated_node);
+  if (type == ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
+    sl_log_debug(LOG_TAG,
+                 "Warning: Invalid type for Attribute ID %d, "
+                 "this should not happen.",
+                 updated_node);
+    return;
+  }
+
+  // If the value got updated but both Reported and Desired undefined, we skip publication
+  if (false == attribute_store_is_reported_defined(updated_node)
+      && false == attribute_store_is_desired_defined(updated_node)) {
+    sl_log_debug(LOG_TAG,
+                 "Reported/Desired values are undefined. "
+                 "Skipping publication");
+    return;
+  }
+
+  // clang-format off
+  try {
+    attribute_store::attribute attr(updated_node);
+      if (type == DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_WARM_WHITE) {
+          uic_mqtt_dotdot_unify_switch_color_warm_white_publish(
+            base_topic.c_str(),
+            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
+            UCL_MQTT_PUBLISH_TYPE_DESIRED);
+        return;
+      }
+          if (type == DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_COLD_WHITE) {
+          uic_mqtt_dotdot_unify_switch_color_cold_white_publish(
+            base_topic.c_str(),
+            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
+            UCL_MQTT_PUBLISH_TYPE_DESIRED);
+        return;
+      }
+          if (type == DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_RED) {
+          uic_mqtt_dotdot_unify_switch_color_red_publish(
+            base_topic.c_str(),
+            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
+            UCL_MQTT_PUBLISH_TYPE_DESIRED);
+        return;
+      }
+          if (type == DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_GREEN) {
+          uic_mqtt_dotdot_unify_switch_color_green_publish(
+            base_topic.c_str(),
+            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
+            UCL_MQTT_PUBLISH_TYPE_DESIRED);
+        return;
+      }
+          if (type == DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_BLUE) {
+          uic_mqtt_dotdot_unify_switch_color_blue_publish(
+            base_topic.c_str(),
+            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
+            UCL_MQTT_PUBLISH_TYPE_DESIRED);
+        return;
+      }
+          if (type == DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_AMBER) {
+          uic_mqtt_dotdot_unify_switch_color_amber_publish(
+            base_topic.c_str(),
+            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
+            UCL_MQTT_PUBLISH_TYPE_DESIRED);
+        return;
+      }
+          if (type == DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_CYAN) {
+          uic_mqtt_dotdot_unify_switch_color_cyan_publish(
+            base_topic.c_str(),
+            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
+            UCL_MQTT_PUBLISH_TYPE_DESIRED);
+        return;
+      }
+          if (type == DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_PURPLE) {
+          uic_mqtt_dotdot_unify_switch_color_purple_publish(
+            base_topic.c_str(),
+            static_cast<uint8_t>(attr.desired_or_reported<uint8_t>()),
+            UCL_MQTT_PUBLISH_TYPE_DESIRED);
+        return;
+      }
+      } catch (std::exception &ex) {
+    sl_log_warning(LOG_TAG, "Failed to publish the Desired attribute value: %s", ex.what());
+  }
+}
+
+/**
+ * @brief Publishes the reported value of an updated attribute store node for
+ * the UnifySwitchColor cluster.
+ * @param updated_node Updated attribute store node
+ * @param change       Type of change applied
+ */
+static void unify_switch_color_cluster_publish_reported_value_callback(
+   attribute_store_node_t updated_node, attribute_store_change_t change)
+{
+  // clang-format on
+  if (false == is_publish_reported_attribute_values_to_mqtt_enabled()) {
+    return;
+  }
+  if (change == ATTRIBUTE_CREATED) {
+    return;
+  }
+  // Scene exception: check that the attribute is not under the Scene Table extension, which is a config and not the node's state.
+  if (ATTRIBUTE_STORE_INVALID_NODE
+      != attribute_store_get_first_parent_with_type(
+        updated_node,
+        DOTDOT_ATTRIBUTE_ID_SCENES_SCENE_TABLE)) {
+    return;
+  }
+
+  // Get the UNID and EndPoint, and prepare the basic topic
+  char unid[MAXIMUM_UNID_SIZE]     = {};
+  // clang-format off
+  // clang-format on
+  dotdot_endpoint_id_t endpoint_id = 0;
+  if (SL_STATUS_OK
+      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
+                                                     unid,
+                                                     &endpoint_id)) {
+    return;
+  }
+  // clang-format off
+  // clang-format on
+
+  std::string base_topic = "ucl/by-unid/" + std::string(unid);
+  // clang-format off
+  base_topic += "/ep" + std::to_string(endpoint_id);
+  // clang-format on
+
+  attribute_store_type_t type = attribute_store_get_node_type(updated_node);
+  if (type == ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE) {
+    sl_log_debug(LOG_TAG,
+                 "Warning: Invalid type for Attribute ID %d, "
+                 "this should not happen.",
+                 updated_node);
+    return;
+  }
+
+  // Deletion case:
+  if (change == ATTRIBUTE_DELETED) {
+    // clang-format off
+    switch(type) {
+     case DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_WARM_WHITE:
+        // clang-format on
+        sl_log_debug(LOG_TAG,
+                     "Unretaining UnifySwitchColor::WarmWhite under topic %s",
+                     base_topic.c_str());
+        // clang-format off
+      uic_mqtt_dotdot_unify_switch_color_warm_white_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
+      break;
+     case DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_COLD_WHITE:
+        // clang-format on
+        sl_log_debug(LOG_TAG,
+                     "Unretaining UnifySwitchColor::ColdWhite under topic %s",
+                     base_topic.c_str());
+        // clang-format off
+      uic_mqtt_dotdot_unify_switch_color_cold_white_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
+      break;
+     case DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_RED:
+        // clang-format on
+        sl_log_debug(LOG_TAG,
+                     "Unretaining UnifySwitchColor::Red under topic %s",
+                     base_topic.c_str());
+        // clang-format off
+      uic_mqtt_dotdot_unify_switch_color_red_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
+      break;
+     case DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_GREEN:
+        // clang-format on
+        sl_log_debug(LOG_TAG,
+                     "Unretaining UnifySwitchColor::Green under topic %s",
+                     base_topic.c_str());
+        // clang-format off
+      uic_mqtt_dotdot_unify_switch_color_green_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
+      break;
+     case DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_BLUE:
+        // clang-format on
+        sl_log_debug(LOG_TAG,
+                     "Unretaining UnifySwitchColor::Blue under topic %s",
+                     base_topic.c_str());
+        // clang-format off
+      uic_mqtt_dotdot_unify_switch_color_blue_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
+      break;
+     case DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_AMBER:
+        // clang-format on
+        sl_log_debug(LOG_TAG,
+                     "Unretaining UnifySwitchColor::Amber under topic %s",
+                     base_topic.c_str());
+        // clang-format off
+      uic_mqtt_dotdot_unify_switch_color_amber_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
+      break;
+     case DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_CYAN:
+        // clang-format on
+        sl_log_debug(LOG_TAG,
+                     "Unretaining UnifySwitchColor::Cyan under topic %s",
+                     base_topic.c_str());
+        // clang-format off
+      uic_mqtt_dotdot_unify_switch_color_cyan_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
+      break;
+     case DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_PURPLE:
+        // clang-format on
+        sl_log_debug(LOG_TAG,
+                     "Unretaining UnifySwitchColor::Purple under topic %s",
+                     base_topic.c_str());
+        // clang-format off
+      uic_mqtt_dotdot_unify_switch_color_purple_unretain(base_topic.c_str(), UCL_MQTT_PUBLISH_TYPE_ALL);
+      break;
+    default:
+    break;
+    }
+    // clang-format on
+    return;
+  }
+
+  // If the value got updated but undefined, we skip publication
+  if (false == attribute_store_is_reported_defined(updated_node)) {
+    sl_log_debug(LOG_TAG, "Reported value is undefined. Skipping publication");
+    return;
+  }
+
+  // Else we assume update case:
+  // clang-format off
+  try {
+    attribute_store::attribute attr(updated_node);
+      if (type == DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_WARM_WHITE) {
+          uic_mqtt_dotdot_unify_switch_color_warm_white_publish(
+            base_topic.c_str(),
+            static_cast<uint8_t>(attr.reported<uint8_t>()),
+            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
+        return;
+      }
+          if (type == DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_COLD_WHITE) {
+          uic_mqtt_dotdot_unify_switch_color_cold_white_publish(
+            base_topic.c_str(),
+            static_cast<uint8_t>(attr.reported<uint8_t>()),
+            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
+        return;
+      }
+          if (type == DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_RED) {
+          uic_mqtt_dotdot_unify_switch_color_red_publish(
+            base_topic.c_str(),
+            static_cast<uint8_t>(attr.reported<uint8_t>()),
+            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
+        return;
+      }
+          if (type == DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_GREEN) {
+          uic_mqtt_dotdot_unify_switch_color_green_publish(
+            base_topic.c_str(),
+            static_cast<uint8_t>(attr.reported<uint8_t>()),
+            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
+        return;
+      }
+          if (type == DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_BLUE) {
+          uic_mqtt_dotdot_unify_switch_color_blue_publish(
+            base_topic.c_str(),
+            static_cast<uint8_t>(attr.reported<uint8_t>()),
+            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
+        return;
+      }
+          if (type == DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_AMBER) {
+          uic_mqtt_dotdot_unify_switch_color_amber_publish(
+            base_topic.c_str(),
+            static_cast<uint8_t>(attr.reported<uint8_t>()),
+            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
+        return;
+      }
+          if (type == DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_CYAN) {
+          uic_mqtt_dotdot_unify_switch_color_cyan_publish(
+            base_topic.c_str(),
+            static_cast<uint8_t>(attr.reported<uint8_t>()),
+            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
+        return;
+      }
+          if (type == DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_PURPLE) {
+          uic_mqtt_dotdot_unify_switch_color_purple_publish(
+            base_topic.c_str(),
+            static_cast<uint8_t>(attr.reported<uint8_t>()),
+            (attr.desired_exists() && !attribute_store_is_value_matched(updated_node)) ? UCL_MQTT_PUBLISH_TYPE_REPORTED : UCL_MQTT_PUBLISH_TYPE_ALL);
+        return;
+      }
+      } catch (std::exception &ex) {
+    sl_log_warning(LOG_TAG, "Failed to publish the Reported attribute value: %s", ex.what());
+  }
+}
+
+static void unify_switch_color_cluster_cluster_revision_callback(
+   attribute_store_node_t updated_node, attribute_store_change_t change)
+{
+  // clang-format on
+  if (false == is_publish_reported_attribute_values_to_mqtt_enabled()) {
+    return;
+  }
+
+  // Get the UNID and EndPoint, and prepare the basic topic
+  char unid[MAXIMUM_UNID_SIZE]     = {};
+  dotdot_endpoint_id_t endpoint_id = 0;
+  // clang-format off
+  // clang-format on
+  if (SL_STATUS_OK
+      != unify_dotdot_attributes_get_unid_endpoint()(updated_node,
+                                                     unid,
+                                                     &endpoint_id)) {
+    return;
+  }
+  // clang-format off
+  // clang-format on
+
+  std::string base_topic = "ucl/by-unid/" + std::string(unid);
+  // clang-format off
+  base_topic += "/ep" + std::to_string(endpoint_id);
+
+  if ((change == ATTRIBUTE_CREATED) || (change == ATTRIBUTE_UPDATED)) {
+    // On attribute creation, make sure to publish the attribute revision for the first time
+    std::string cluster_revision_topic = base_topic + "/UnifySwitchColor/Attributes/ClusterRevision";
+    if (uic_mqtt_count_topics(cluster_revision_topic.c_str()) == 0) {
+      uic_mqtt_dotdot_unify_switch_color_publish_cluster_revision(base_topic.c_str(), 1);
+    }
+  }
+
+  if (change == ATTRIBUTE_DELETED) {
+    // Check if we just erased the last attribute under a cluster, if yes, unretain
+    // the Cluster revision too.
+    if (false == dotdot_is_any_unify_switch_color_attribute_supported(unid, endpoint_id)) {
+      base_topic +=  "/UnifySwitchColor";
+      sl_log_debug(LOG_TAG, "No more attributes supported for UnifySwitchColor cluster for UNID %s Endpoint %d. Unretaining leftover topics at %s",unid, endpoint_id, base_topic.c_str());
+      uic_mqtt_unretain(base_topic.c_str());
+    }
+  }
+}
+
+
 
 // Initialization of the component.
 sl_status_t unify_dotdot_attribute_store_attribute_publisher_init()
@@ -36615,6 +36984,118 @@ sl_status_t unify_dotdot_attribute_store_attribute_publisher_init()
     attribute_store_register_callback_by_type(
       unify_humidity_control_cluster_cluster_revision_callback,
       DOTDOT_ATTRIBUTE_ID_UNIFY_HUMIDITY_CONTROL_AUTO_SETPOINT_PRECISION);
+    //Desired attribute state
+    attribute_store_register_callback_by_type_and_state(
+      unify_switch_color_cluster_publish_desired_value_callback,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_WARM_WHITE,
+      DESIRED_ATTRIBUTE);
+    //Reported attribute state
+    attribute_store_register_callback_by_type_and_state(
+      unify_switch_color_cluster_publish_reported_value_callback,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_WARM_WHITE,
+      REPORTED_ATTRIBUTE);
+    //registering a callback when an attribute is created for publishing cluster revision
+    attribute_store_register_callback_by_type(
+      unify_switch_color_cluster_cluster_revision_callback,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_WARM_WHITE);
+    //Desired attribute state
+    attribute_store_register_callback_by_type_and_state(
+      unify_switch_color_cluster_publish_desired_value_callback,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_COLD_WHITE,
+      DESIRED_ATTRIBUTE);
+    //Reported attribute state
+    attribute_store_register_callback_by_type_and_state(
+      unify_switch_color_cluster_publish_reported_value_callback,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_COLD_WHITE,
+      REPORTED_ATTRIBUTE);
+    //registering a callback when an attribute is created for publishing cluster revision
+    attribute_store_register_callback_by_type(
+      unify_switch_color_cluster_cluster_revision_callback,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_COLD_WHITE);
+    //Desired attribute state
+    attribute_store_register_callback_by_type_and_state(
+      unify_switch_color_cluster_publish_desired_value_callback,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_RED,
+      DESIRED_ATTRIBUTE);
+    //Reported attribute state
+    attribute_store_register_callback_by_type_and_state(
+      unify_switch_color_cluster_publish_reported_value_callback,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_RED,
+      REPORTED_ATTRIBUTE);
+    //registering a callback when an attribute is created for publishing cluster revision
+    attribute_store_register_callback_by_type(
+      unify_switch_color_cluster_cluster_revision_callback,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_RED);
+    //Desired attribute state
+    attribute_store_register_callback_by_type_and_state(
+      unify_switch_color_cluster_publish_desired_value_callback,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_GREEN,
+      DESIRED_ATTRIBUTE);
+    //Reported attribute state
+    attribute_store_register_callback_by_type_and_state(
+      unify_switch_color_cluster_publish_reported_value_callback,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_GREEN,
+      REPORTED_ATTRIBUTE);
+    //registering a callback when an attribute is created for publishing cluster revision
+    attribute_store_register_callback_by_type(
+      unify_switch_color_cluster_cluster_revision_callback,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_GREEN);
+    //Desired attribute state
+    attribute_store_register_callback_by_type_and_state(
+      unify_switch_color_cluster_publish_desired_value_callback,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_BLUE,
+      DESIRED_ATTRIBUTE);
+    //Reported attribute state
+    attribute_store_register_callback_by_type_and_state(
+      unify_switch_color_cluster_publish_reported_value_callback,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_BLUE,
+      REPORTED_ATTRIBUTE);
+    //registering a callback when an attribute is created for publishing cluster revision
+    attribute_store_register_callback_by_type(
+      unify_switch_color_cluster_cluster_revision_callback,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_BLUE);
+    //Desired attribute state
+    attribute_store_register_callback_by_type_and_state(
+      unify_switch_color_cluster_publish_desired_value_callback,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_AMBER,
+      DESIRED_ATTRIBUTE);
+    //Reported attribute state
+    attribute_store_register_callback_by_type_and_state(
+      unify_switch_color_cluster_publish_reported_value_callback,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_AMBER,
+      REPORTED_ATTRIBUTE);
+    //registering a callback when an attribute is created for publishing cluster revision
+    attribute_store_register_callback_by_type(
+      unify_switch_color_cluster_cluster_revision_callback,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_AMBER);
+    //Desired attribute state
+    attribute_store_register_callback_by_type_and_state(
+      unify_switch_color_cluster_publish_desired_value_callback,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_CYAN,
+      DESIRED_ATTRIBUTE);
+    //Reported attribute state
+    attribute_store_register_callback_by_type_and_state(
+      unify_switch_color_cluster_publish_reported_value_callback,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_CYAN,
+      REPORTED_ATTRIBUTE);
+    //registering a callback when an attribute is created for publishing cluster revision
+    attribute_store_register_callback_by_type(
+      unify_switch_color_cluster_cluster_revision_callback,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_CYAN);
+    //Desired attribute state
+    attribute_store_register_callback_by_type_and_state(
+      unify_switch_color_cluster_publish_desired_value_callback,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_PURPLE,
+      DESIRED_ATTRIBUTE);
+    //Reported attribute state
+    attribute_store_register_callback_by_type_and_state(
+      unify_switch_color_cluster_publish_reported_value_callback,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_PURPLE,
+      REPORTED_ATTRIBUTE);
+    //registering a callback when an attribute is created for publishing cluster revision
+    attribute_store_register_callback_by_type(
+      unify_switch_color_cluster_cluster_revision_callback,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_PURPLE);
 
   return SL_STATUS_OK;
 }
diff --git a/components/unify_dotdot_attribute_store/zap-generated/src/unify_dotdot_attribute_store_force_read_attributes_command_callbacks.c b/components/unify_dotdot_attribute_store/zap-generated/src/unify_dotdot_attribute_store_force_read_attributes_command_callbacks.c
index fe3a605125..17cb0e11f5 100644
--- a/components/unify_dotdot_attribute_store/zap-generated/src/unify_dotdot_attribute_store_force_read_attributes_command_callbacks.c
+++ b/components/unify_dotdot_attribute_store/zap-generated/src/unify_dotdot_attribute_store_force_read_attributes_command_callbacks.c
@@ -4619,6 +4619,71 @@ static sl_status_t uic_mqtt_dotdot_unify_humidity_control_force_read_attributes_
   }
   return SL_STATUS_OK;
 }
+////////////////////////////////////////////////////////////////////////////////
+// Start of cluster UnifySwitchColor
+////////////////////////////////////////////////////////////////////////////////
+static sl_status_t uic_mqtt_dotdot_unify_switch_color_force_read_attributes_callback (
+  const dotdot_unid_t unid,
+  dotdot_endpoint_id_t endpoint_id,
+  uic_mqtt_dotdot_callback_call_type_t call_type,
+  uic_mqtt_dotdot_unify_switch_color_updated_state_t attribute_list) {
+
+  if (false == is_force_read_attributes_enabled()){
+    return SL_STATUS_FAIL;
+  }
+
+  if (call_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
+    if (is_automatic_deduction_of_supported_commands_enabled()) {
+      return dotdot_is_any_unify_switch_color_attribute_supported(unid, endpoint_id) ?
+        SL_STATUS_OK : SL_STATUS_FAIL;
+    } else {
+      return SL_STATUS_FAIL;
+    }
+  }
+
+  // Go and undefine everything that needs to be read again:
+  if (true == attribute_list.warm_white) {
+    if (SL_STATUS_OK == dotdot_unify_switch_color_warm_white_undefine_reported(unid, endpoint_id)) {
+      sl_log_debug(LOG_TAG, "Undefined Reported value of UnifySwitchColor::WarmWhite under %s - Endpoint %d", unid, endpoint_id);
+    }
+  }
+  if (true == attribute_list.cold_white) {
+    if (SL_STATUS_OK == dotdot_unify_switch_color_cold_white_undefine_reported(unid, endpoint_id)) {
+      sl_log_debug(LOG_TAG, "Undefined Reported value of UnifySwitchColor::ColdWhite under %s - Endpoint %d", unid, endpoint_id);
+    }
+  }
+  if (true == attribute_list.red) {
+    if (SL_STATUS_OK == dotdot_unify_switch_color_red_undefine_reported(unid, endpoint_id)) {
+      sl_log_debug(LOG_TAG, "Undefined Reported value of UnifySwitchColor::Red under %s - Endpoint %d", unid, endpoint_id);
+    }
+  }
+  if (true == attribute_list.green) {
+    if (SL_STATUS_OK == dotdot_unify_switch_color_green_undefine_reported(unid, endpoint_id)) {
+      sl_log_debug(LOG_TAG, "Undefined Reported value of UnifySwitchColor::Green under %s - Endpoint %d", unid, endpoint_id);
+    }
+  }
+  if (true == attribute_list.blue) {
+    if (SL_STATUS_OK == dotdot_unify_switch_color_blue_undefine_reported(unid, endpoint_id)) {
+      sl_log_debug(LOG_TAG, "Undefined Reported value of UnifySwitchColor::Blue under %s - Endpoint %d", unid, endpoint_id);
+    }
+  }
+  if (true == attribute_list.amber) {
+    if (SL_STATUS_OK == dotdot_unify_switch_color_amber_undefine_reported(unid, endpoint_id)) {
+      sl_log_debug(LOG_TAG, "Undefined Reported value of UnifySwitchColor::Amber under %s - Endpoint %d", unid, endpoint_id);
+    }
+  }
+  if (true == attribute_list.cyan) {
+    if (SL_STATUS_OK == dotdot_unify_switch_color_cyan_undefine_reported(unid, endpoint_id)) {
+      sl_log_debug(LOG_TAG, "Undefined Reported value of UnifySwitchColor::Cyan under %s - Endpoint %d", unid, endpoint_id);
+    }
+  }
+  if (true == attribute_list.purple) {
+    if (SL_STATUS_OK == dotdot_unify_switch_color_purple_undefine_reported(unid, endpoint_id)) {
+      sl_log_debug(LOG_TAG, "Undefined Reported value of UnifySwitchColor::Purple under %s - Endpoint %d", unid, endpoint_id);
+    }
+  }
+  return SL_STATUS_OK;
+}
 // clang-format on
 
 ////////////////////////////////////////////////////////////////////////////////
@@ -4733,6 +4798,8 @@ sl_status_t
   
   uic_mqtt_dotdot_set_unify_humidity_control_force_read_attributes_callback(&uic_mqtt_dotdot_unify_humidity_control_force_read_attributes_callback);
   
+  uic_mqtt_dotdot_set_unify_switch_color_force_read_attributes_callback(&uic_mqtt_dotdot_unify_switch_color_force_read_attributes_callback);
+  
   // clang-format on
 
   return SL_STATUS_OK;
diff --git a/components/unify_dotdot_attribute_store/zap-generated/src/unify_dotdot_attribute_store_helpers.cpp b/components/unify_dotdot_attribute_store/zap-generated/src/unify_dotdot_attribute_store_helpers.cpp
index ba326df8ab..2d6b9ffc81 100644
--- a/components/unify_dotdot_attribute_store/zap-generated/src/unify_dotdot_attribute_store_helpers.cpp
+++ b/components/unify_dotdot_attribute_store/zap-generated/src/unify_dotdot_attribute_store_helpers.cpp
@@ -85167,5 +85167,936 @@ bool dotdot_is_any_unify_humidity_control_writable_attribute_supported(
   const dotdot_endpoint_id_t endpoint_id) {
 
 
+  return false;
+}
+////////////////////////////////////////////////////////////////////////////////
+// Start of cluster UnifySwitchColor
+////////////////////////////////////////////////////////////////////////////////
+bool dotdot_is_supported_unify_switch_color_warm_white(
+  const dotdot_unid_t unid, const dotdot_endpoint_id_t endpoint_id)
+{
+  attribute_store_node_t endpoint_node = unify_dotdot_attributes_get_endpoint_node()(unid, endpoint_id);
+  attribute_store_node_t node
+    = attribute_store_get_first_child_by_type(
+      endpoint_node,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_WARM_WHITE);
+  return attribute_store_node_exists(node);
+}
+
+uint8_t dotdot_get_unify_switch_color_warm_white(
+  const dotdot_unid_t unid,
+  dotdot_endpoint_id_t endpoint_id,
+  attribute_store_node_value_state_t value_state)
+{
+  attribute_store_node_t endpoint_node = unify_dotdot_attributes_get_endpoint_node()(unid, endpoint_id);
+  attribute_store_node_t node
+    = attribute_store_get_first_child_by_type(
+      endpoint_node,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_WARM_WHITE);
+
+  uint8_t result = {};
+  attribute_store_read_value(node,
+                             value_state,
+                             (uint8_t *)&result,
+                             sizeof(result));
+  return result;
+}
+
+sl_status_t dotdot_set_unify_switch_color_warm_white(
+  const dotdot_unid_t unid,
+  dotdot_endpoint_id_t endpoint_id,
+  attribute_store_node_value_state_t value_state,
+  uint8_t new_warm_white
+  )
+{
+  attribute_store_node_t endpoint_node = unify_dotdot_attributes_get_endpoint_node()(unid, endpoint_id);
+
+  attribute_store_node_t node
+    = attribute_store_get_first_child_by_type(
+      endpoint_node,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_WARM_WHITE);
+
+  return attribute_store_set_node_attribute_value(node,
+                                                  value_state,
+                                                  (uint8_t *)&new_warm_white,
+                                                  sizeof(uint8_t));
+  }
+
+sl_status_t dotdot_unify_switch_color_warm_white_undefine_reported(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id) {
+  attribute_store_node_t endpoint_node = unify_dotdot_attributes_get_endpoint_node()(unid, endpoint_id);
+  attribute_store_node_t node
+    = attribute_store_get_first_child_by_type(
+      endpoint_node,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_WARM_WHITE);
+  attribute_store_undefine_reported(node);
+  return (node != ATTRIBUTE_STORE_INVALID_NODE) ? SL_STATUS_OK : SL_STATUS_FAIL;
+}
+
+sl_status_t dotdot_unify_switch_color_warm_white_undefine_desired(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id) {
+
+  attribute_store_node_t endpoint_node = unify_dotdot_attributes_get_endpoint_node()(unid, endpoint_id);
+  attribute_store_node_t node
+    = attribute_store_get_first_child_by_type(
+      endpoint_node,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_WARM_WHITE);
+  attribute_store_undefine_desired(node);
+  return (node != ATTRIBUTE_STORE_INVALID_NODE) ? SL_STATUS_OK : SL_STATUS_FAIL;
+}
+
+
+bool dotdot_unify_switch_color_warm_white_is_reported_defined(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id)
+{
+  attribute_store_node_t endpoint_node = unify_dotdot_attributes_get_endpoint_node()(unid, endpoint_id);
+  attribute_store_node_t node
+    = attribute_store_get_first_child_by_type(
+      endpoint_node,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_WARM_WHITE);
+  return attribute_store_is_reported_defined(node);
+}
+
+bool dotdot_unify_switch_color_warm_white_is_desired_defined(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id)
+{
+  attribute_store_node_t endpoint_node = unify_dotdot_attributes_get_endpoint_node()(unid, endpoint_id);
+  attribute_store_node_t node
+    = attribute_store_get_first_child_by_type(
+      endpoint_node,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_WARM_WHITE);
+  return attribute_store_is_desired_defined(node);
+}
+
+sl_status_t dotdot_create_unify_switch_color_warm_white(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id) {
+
+  attribute_store_node_t endpoint_node = unify_dotdot_attributes_get_endpoint_node()(unid, endpoint_id);
+  attribute_store_node_t node =
+    attribute_store_create_child_if_missing(endpoint_node,
+                                           DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_WARM_WHITE);
+
+  return (node != ATTRIBUTE_STORE_INVALID_NODE) ? SL_STATUS_OK : SL_STATUS_FAIL;
+}
+bool dotdot_is_supported_unify_switch_color_cold_white(
+  const dotdot_unid_t unid, const dotdot_endpoint_id_t endpoint_id)
+{
+  attribute_store_node_t endpoint_node = unify_dotdot_attributes_get_endpoint_node()(unid, endpoint_id);
+  attribute_store_node_t node
+    = attribute_store_get_first_child_by_type(
+      endpoint_node,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_COLD_WHITE);
+  return attribute_store_node_exists(node);
+}
+
+uint8_t dotdot_get_unify_switch_color_cold_white(
+  const dotdot_unid_t unid,
+  dotdot_endpoint_id_t endpoint_id,
+  attribute_store_node_value_state_t value_state)
+{
+  attribute_store_node_t endpoint_node = unify_dotdot_attributes_get_endpoint_node()(unid, endpoint_id);
+  attribute_store_node_t node
+    = attribute_store_get_first_child_by_type(
+      endpoint_node,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_COLD_WHITE);
+
+  uint8_t result = {};
+  attribute_store_read_value(node,
+                             value_state,
+                             (uint8_t *)&result,
+                             sizeof(result));
+  return result;
+}
+
+sl_status_t dotdot_set_unify_switch_color_cold_white(
+  const dotdot_unid_t unid,
+  dotdot_endpoint_id_t endpoint_id,
+  attribute_store_node_value_state_t value_state,
+  uint8_t new_cold_white
+  )
+{
+  attribute_store_node_t endpoint_node = unify_dotdot_attributes_get_endpoint_node()(unid, endpoint_id);
+
+  attribute_store_node_t node
+    = attribute_store_get_first_child_by_type(
+      endpoint_node,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_COLD_WHITE);
+
+  return attribute_store_set_node_attribute_value(node,
+                                                  value_state,
+                                                  (uint8_t *)&new_cold_white,
+                                                  sizeof(uint8_t));
+  }
+
+sl_status_t dotdot_unify_switch_color_cold_white_undefine_reported(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id) {
+  attribute_store_node_t endpoint_node = unify_dotdot_attributes_get_endpoint_node()(unid, endpoint_id);
+  attribute_store_node_t node
+    = attribute_store_get_first_child_by_type(
+      endpoint_node,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_COLD_WHITE);
+  attribute_store_undefine_reported(node);
+  return (node != ATTRIBUTE_STORE_INVALID_NODE) ? SL_STATUS_OK : SL_STATUS_FAIL;
+}
+
+sl_status_t dotdot_unify_switch_color_cold_white_undefine_desired(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id) {
+
+  attribute_store_node_t endpoint_node = unify_dotdot_attributes_get_endpoint_node()(unid, endpoint_id);
+  attribute_store_node_t node
+    = attribute_store_get_first_child_by_type(
+      endpoint_node,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_COLD_WHITE);
+  attribute_store_undefine_desired(node);
+  return (node != ATTRIBUTE_STORE_INVALID_NODE) ? SL_STATUS_OK : SL_STATUS_FAIL;
+}
+
+
+bool dotdot_unify_switch_color_cold_white_is_reported_defined(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id)
+{
+  attribute_store_node_t endpoint_node = unify_dotdot_attributes_get_endpoint_node()(unid, endpoint_id);
+  attribute_store_node_t node
+    = attribute_store_get_first_child_by_type(
+      endpoint_node,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_COLD_WHITE);
+  return attribute_store_is_reported_defined(node);
+}
+
+bool dotdot_unify_switch_color_cold_white_is_desired_defined(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id)
+{
+  attribute_store_node_t endpoint_node = unify_dotdot_attributes_get_endpoint_node()(unid, endpoint_id);
+  attribute_store_node_t node
+    = attribute_store_get_first_child_by_type(
+      endpoint_node,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_COLD_WHITE);
+  return attribute_store_is_desired_defined(node);
+}
+
+sl_status_t dotdot_create_unify_switch_color_cold_white(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id) {
+
+  attribute_store_node_t endpoint_node = unify_dotdot_attributes_get_endpoint_node()(unid, endpoint_id);
+  attribute_store_node_t node =
+    attribute_store_create_child_if_missing(endpoint_node,
+                                           DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_COLD_WHITE);
+
+  return (node != ATTRIBUTE_STORE_INVALID_NODE) ? SL_STATUS_OK : SL_STATUS_FAIL;
+}
+bool dotdot_is_supported_unify_switch_color_red(
+  const dotdot_unid_t unid, const dotdot_endpoint_id_t endpoint_id)
+{
+  attribute_store_node_t endpoint_node = unify_dotdot_attributes_get_endpoint_node()(unid, endpoint_id);
+  attribute_store_node_t node
+    = attribute_store_get_first_child_by_type(
+      endpoint_node,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_RED);
+  return attribute_store_node_exists(node);
+}
+
+uint8_t dotdot_get_unify_switch_color_red(
+  const dotdot_unid_t unid,
+  dotdot_endpoint_id_t endpoint_id,
+  attribute_store_node_value_state_t value_state)
+{
+  attribute_store_node_t endpoint_node = unify_dotdot_attributes_get_endpoint_node()(unid, endpoint_id);
+  attribute_store_node_t node
+    = attribute_store_get_first_child_by_type(
+      endpoint_node,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_RED);
+
+  uint8_t result = {};
+  attribute_store_read_value(node,
+                             value_state,
+                             (uint8_t *)&result,
+                             sizeof(result));
+  return result;
+}
+
+sl_status_t dotdot_set_unify_switch_color_red(
+  const dotdot_unid_t unid,
+  dotdot_endpoint_id_t endpoint_id,
+  attribute_store_node_value_state_t value_state,
+  uint8_t new_red
+  )
+{
+  attribute_store_node_t endpoint_node = unify_dotdot_attributes_get_endpoint_node()(unid, endpoint_id);
+
+  attribute_store_node_t node
+    = attribute_store_get_first_child_by_type(
+      endpoint_node,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_RED);
+
+  return attribute_store_set_node_attribute_value(node,
+                                                  value_state,
+                                                  (uint8_t *)&new_red,
+                                                  sizeof(uint8_t));
+  }
+
+sl_status_t dotdot_unify_switch_color_red_undefine_reported(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id) {
+  attribute_store_node_t endpoint_node = unify_dotdot_attributes_get_endpoint_node()(unid, endpoint_id);
+  attribute_store_node_t node
+    = attribute_store_get_first_child_by_type(
+      endpoint_node,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_RED);
+  attribute_store_undefine_reported(node);
+  return (node != ATTRIBUTE_STORE_INVALID_NODE) ? SL_STATUS_OK : SL_STATUS_FAIL;
+}
+
+sl_status_t dotdot_unify_switch_color_red_undefine_desired(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id) {
+
+  attribute_store_node_t endpoint_node = unify_dotdot_attributes_get_endpoint_node()(unid, endpoint_id);
+  attribute_store_node_t node
+    = attribute_store_get_first_child_by_type(
+      endpoint_node,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_RED);
+  attribute_store_undefine_desired(node);
+  return (node != ATTRIBUTE_STORE_INVALID_NODE) ? SL_STATUS_OK : SL_STATUS_FAIL;
+}
+
+
+bool dotdot_unify_switch_color_red_is_reported_defined(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id)
+{
+  attribute_store_node_t endpoint_node = unify_dotdot_attributes_get_endpoint_node()(unid, endpoint_id);
+  attribute_store_node_t node
+    = attribute_store_get_first_child_by_type(
+      endpoint_node,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_RED);
+  return attribute_store_is_reported_defined(node);
+}
+
+bool dotdot_unify_switch_color_red_is_desired_defined(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id)
+{
+  attribute_store_node_t endpoint_node = unify_dotdot_attributes_get_endpoint_node()(unid, endpoint_id);
+  attribute_store_node_t node
+    = attribute_store_get_first_child_by_type(
+      endpoint_node,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_RED);
+  return attribute_store_is_desired_defined(node);
+}
+
+sl_status_t dotdot_create_unify_switch_color_red(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id) {
+
+  attribute_store_node_t endpoint_node = unify_dotdot_attributes_get_endpoint_node()(unid, endpoint_id);
+  attribute_store_node_t node =
+    attribute_store_create_child_if_missing(endpoint_node,
+                                           DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_RED);
+
+  return (node != ATTRIBUTE_STORE_INVALID_NODE) ? SL_STATUS_OK : SL_STATUS_FAIL;
+}
+bool dotdot_is_supported_unify_switch_color_green(
+  const dotdot_unid_t unid, const dotdot_endpoint_id_t endpoint_id)
+{
+  attribute_store_node_t endpoint_node = unify_dotdot_attributes_get_endpoint_node()(unid, endpoint_id);
+  attribute_store_node_t node
+    = attribute_store_get_first_child_by_type(
+      endpoint_node,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_GREEN);
+  return attribute_store_node_exists(node);
+}
+
+uint8_t dotdot_get_unify_switch_color_green(
+  const dotdot_unid_t unid,
+  dotdot_endpoint_id_t endpoint_id,
+  attribute_store_node_value_state_t value_state)
+{
+  attribute_store_node_t endpoint_node = unify_dotdot_attributes_get_endpoint_node()(unid, endpoint_id);
+  attribute_store_node_t node
+    = attribute_store_get_first_child_by_type(
+      endpoint_node,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_GREEN);
+
+  uint8_t result = {};
+  attribute_store_read_value(node,
+                             value_state,
+                             (uint8_t *)&result,
+                             sizeof(result));
+  return result;
+}
+
+sl_status_t dotdot_set_unify_switch_color_green(
+  const dotdot_unid_t unid,
+  dotdot_endpoint_id_t endpoint_id,
+  attribute_store_node_value_state_t value_state,
+  uint8_t new_green
+  )
+{
+  attribute_store_node_t endpoint_node = unify_dotdot_attributes_get_endpoint_node()(unid, endpoint_id);
+
+  attribute_store_node_t node
+    = attribute_store_get_first_child_by_type(
+      endpoint_node,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_GREEN);
+
+  return attribute_store_set_node_attribute_value(node,
+                                                  value_state,
+                                                  (uint8_t *)&new_green,
+                                                  sizeof(uint8_t));
+  }
+
+sl_status_t dotdot_unify_switch_color_green_undefine_reported(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id) {
+  attribute_store_node_t endpoint_node = unify_dotdot_attributes_get_endpoint_node()(unid, endpoint_id);
+  attribute_store_node_t node
+    = attribute_store_get_first_child_by_type(
+      endpoint_node,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_GREEN);
+  attribute_store_undefine_reported(node);
+  return (node != ATTRIBUTE_STORE_INVALID_NODE) ? SL_STATUS_OK : SL_STATUS_FAIL;
+}
+
+sl_status_t dotdot_unify_switch_color_green_undefine_desired(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id) {
+
+  attribute_store_node_t endpoint_node = unify_dotdot_attributes_get_endpoint_node()(unid, endpoint_id);
+  attribute_store_node_t node
+    = attribute_store_get_first_child_by_type(
+      endpoint_node,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_GREEN);
+  attribute_store_undefine_desired(node);
+  return (node != ATTRIBUTE_STORE_INVALID_NODE) ? SL_STATUS_OK : SL_STATUS_FAIL;
+}
+
+
+bool dotdot_unify_switch_color_green_is_reported_defined(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id)
+{
+  attribute_store_node_t endpoint_node = unify_dotdot_attributes_get_endpoint_node()(unid, endpoint_id);
+  attribute_store_node_t node
+    = attribute_store_get_first_child_by_type(
+      endpoint_node,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_GREEN);
+  return attribute_store_is_reported_defined(node);
+}
+
+bool dotdot_unify_switch_color_green_is_desired_defined(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id)
+{
+  attribute_store_node_t endpoint_node = unify_dotdot_attributes_get_endpoint_node()(unid, endpoint_id);
+  attribute_store_node_t node
+    = attribute_store_get_first_child_by_type(
+      endpoint_node,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_GREEN);
+  return attribute_store_is_desired_defined(node);
+}
+
+sl_status_t dotdot_create_unify_switch_color_green(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id) {
+
+  attribute_store_node_t endpoint_node = unify_dotdot_attributes_get_endpoint_node()(unid, endpoint_id);
+  attribute_store_node_t node =
+    attribute_store_create_child_if_missing(endpoint_node,
+                                           DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_GREEN);
+
+  return (node != ATTRIBUTE_STORE_INVALID_NODE) ? SL_STATUS_OK : SL_STATUS_FAIL;
+}
+bool dotdot_is_supported_unify_switch_color_blue(
+  const dotdot_unid_t unid, const dotdot_endpoint_id_t endpoint_id)
+{
+  attribute_store_node_t endpoint_node = unify_dotdot_attributes_get_endpoint_node()(unid, endpoint_id);
+  attribute_store_node_t node
+    = attribute_store_get_first_child_by_type(
+      endpoint_node,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_BLUE);
+  return attribute_store_node_exists(node);
+}
+
+uint8_t dotdot_get_unify_switch_color_blue(
+  const dotdot_unid_t unid,
+  dotdot_endpoint_id_t endpoint_id,
+  attribute_store_node_value_state_t value_state)
+{
+  attribute_store_node_t endpoint_node = unify_dotdot_attributes_get_endpoint_node()(unid, endpoint_id);
+  attribute_store_node_t node
+    = attribute_store_get_first_child_by_type(
+      endpoint_node,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_BLUE);
+
+  uint8_t result = {};
+  attribute_store_read_value(node,
+                             value_state,
+                             (uint8_t *)&result,
+                             sizeof(result));
+  return result;
+}
+
+sl_status_t dotdot_set_unify_switch_color_blue(
+  const dotdot_unid_t unid,
+  dotdot_endpoint_id_t endpoint_id,
+  attribute_store_node_value_state_t value_state,
+  uint8_t new_blue
+  )
+{
+  attribute_store_node_t endpoint_node = unify_dotdot_attributes_get_endpoint_node()(unid, endpoint_id);
+
+  attribute_store_node_t node
+    = attribute_store_get_first_child_by_type(
+      endpoint_node,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_BLUE);
+
+  return attribute_store_set_node_attribute_value(node,
+                                                  value_state,
+                                                  (uint8_t *)&new_blue,
+                                                  sizeof(uint8_t));
+  }
+
+sl_status_t dotdot_unify_switch_color_blue_undefine_reported(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id) {
+  attribute_store_node_t endpoint_node = unify_dotdot_attributes_get_endpoint_node()(unid, endpoint_id);
+  attribute_store_node_t node
+    = attribute_store_get_first_child_by_type(
+      endpoint_node,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_BLUE);
+  attribute_store_undefine_reported(node);
+  return (node != ATTRIBUTE_STORE_INVALID_NODE) ? SL_STATUS_OK : SL_STATUS_FAIL;
+}
+
+sl_status_t dotdot_unify_switch_color_blue_undefine_desired(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id) {
+
+  attribute_store_node_t endpoint_node = unify_dotdot_attributes_get_endpoint_node()(unid, endpoint_id);
+  attribute_store_node_t node
+    = attribute_store_get_first_child_by_type(
+      endpoint_node,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_BLUE);
+  attribute_store_undefine_desired(node);
+  return (node != ATTRIBUTE_STORE_INVALID_NODE) ? SL_STATUS_OK : SL_STATUS_FAIL;
+}
+
+
+bool dotdot_unify_switch_color_blue_is_reported_defined(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id)
+{
+  attribute_store_node_t endpoint_node = unify_dotdot_attributes_get_endpoint_node()(unid, endpoint_id);
+  attribute_store_node_t node
+    = attribute_store_get_first_child_by_type(
+      endpoint_node,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_BLUE);
+  return attribute_store_is_reported_defined(node);
+}
+
+bool dotdot_unify_switch_color_blue_is_desired_defined(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id)
+{
+  attribute_store_node_t endpoint_node = unify_dotdot_attributes_get_endpoint_node()(unid, endpoint_id);
+  attribute_store_node_t node
+    = attribute_store_get_first_child_by_type(
+      endpoint_node,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_BLUE);
+  return attribute_store_is_desired_defined(node);
+}
+
+sl_status_t dotdot_create_unify_switch_color_blue(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id) {
+
+  attribute_store_node_t endpoint_node = unify_dotdot_attributes_get_endpoint_node()(unid, endpoint_id);
+  attribute_store_node_t node =
+    attribute_store_create_child_if_missing(endpoint_node,
+                                           DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_BLUE);
+
+  return (node != ATTRIBUTE_STORE_INVALID_NODE) ? SL_STATUS_OK : SL_STATUS_FAIL;
+}
+bool dotdot_is_supported_unify_switch_color_amber(
+  const dotdot_unid_t unid, const dotdot_endpoint_id_t endpoint_id)
+{
+  attribute_store_node_t endpoint_node = unify_dotdot_attributes_get_endpoint_node()(unid, endpoint_id);
+  attribute_store_node_t node
+    = attribute_store_get_first_child_by_type(
+      endpoint_node,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_AMBER);
+  return attribute_store_node_exists(node);
+}
+
+uint8_t dotdot_get_unify_switch_color_amber(
+  const dotdot_unid_t unid,
+  dotdot_endpoint_id_t endpoint_id,
+  attribute_store_node_value_state_t value_state)
+{
+  attribute_store_node_t endpoint_node = unify_dotdot_attributes_get_endpoint_node()(unid, endpoint_id);
+  attribute_store_node_t node
+    = attribute_store_get_first_child_by_type(
+      endpoint_node,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_AMBER);
+
+  uint8_t result = {};
+  attribute_store_read_value(node,
+                             value_state,
+                             (uint8_t *)&result,
+                             sizeof(result));
+  return result;
+}
+
+sl_status_t dotdot_set_unify_switch_color_amber(
+  const dotdot_unid_t unid,
+  dotdot_endpoint_id_t endpoint_id,
+  attribute_store_node_value_state_t value_state,
+  uint8_t new_amber
+  )
+{
+  attribute_store_node_t endpoint_node = unify_dotdot_attributes_get_endpoint_node()(unid, endpoint_id);
+
+  attribute_store_node_t node
+    = attribute_store_get_first_child_by_type(
+      endpoint_node,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_AMBER);
+
+  return attribute_store_set_node_attribute_value(node,
+                                                  value_state,
+                                                  (uint8_t *)&new_amber,
+                                                  sizeof(uint8_t));
+  }
+
+sl_status_t dotdot_unify_switch_color_amber_undefine_reported(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id) {
+  attribute_store_node_t endpoint_node = unify_dotdot_attributes_get_endpoint_node()(unid, endpoint_id);
+  attribute_store_node_t node
+    = attribute_store_get_first_child_by_type(
+      endpoint_node,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_AMBER);
+  attribute_store_undefine_reported(node);
+  return (node != ATTRIBUTE_STORE_INVALID_NODE) ? SL_STATUS_OK : SL_STATUS_FAIL;
+}
+
+sl_status_t dotdot_unify_switch_color_amber_undefine_desired(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id) {
+
+  attribute_store_node_t endpoint_node = unify_dotdot_attributes_get_endpoint_node()(unid, endpoint_id);
+  attribute_store_node_t node
+    = attribute_store_get_first_child_by_type(
+      endpoint_node,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_AMBER);
+  attribute_store_undefine_desired(node);
+  return (node != ATTRIBUTE_STORE_INVALID_NODE) ? SL_STATUS_OK : SL_STATUS_FAIL;
+}
+
+
+bool dotdot_unify_switch_color_amber_is_reported_defined(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id)
+{
+  attribute_store_node_t endpoint_node = unify_dotdot_attributes_get_endpoint_node()(unid, endpoint_id);
+  attribute_store_node_t node
+    = attribute_store_get_first_child_by_type(
+      endpoint_node,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_AMBER);
+  return attribute_store_is_reported_defined(node);
+}
+
+bool dotdot_unify_switch_color_amber_is_desired_defined(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id)
+{
+  attribute_store_node_t endpoint_node = unify_dotdot_attributes_get_endpoint_node()(unid, endpoint_id);
+  attribute_store_node_t node
+    = attribute_store_get_first_child_by_type(
+      endpoint_node,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_AMBER);
+  return attribute_store_is_desired_defined(node);
+}
+
+sl_status_t dotdot_create_unify_switch_color_amber(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id) {
+
+  attribute_store_node_t endpoint_node = unify_dotdot_attributes_get_endpoint_node()(unid, endpoint_id);
+  attribute_store_node_t node =
+    attribute_store_create_child_if_missing(endpoint_node,
+                                           DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_AMBER);
+
+  return (node != ATTRIBUTE_STORE_INVALID_NODE) ? SL_STATUS_OK : SL_STATUS_FAIL;
+}
+bool dotdot_is_supported_unify_switch_color_cyan(
+  const dotdot_unid_t unid, const dotdot_endpoint_id_t endpoint_id)
+{
+  attribute_store_node_t endpoint_node = unify_dotdot_attributes_get_endpoint_node()(unid, endpoint_id);
+  attribute_store_node_t node
+    = attribute_store_get_first_child_by_type(
+      endpoint_node,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_CYAN);
+  return attribute_store_node_exists(node);
+}
+
+uint8_t dotdot_get_unify_switch_color_cyan(
+  const dotdot_unid_t unid,
+  dotdot_endpoint_id_t endpoint_id,
+  attribute_store_node_value_state_t value_state)
+{
+  attribute_store_node_t endpoint_node = unify_dotdot_attributes_get_endpoint_node()(unid, endpoint_id);
+  attribute_store_node_t node
+    = attribute_store_get_first_child_by_type(
+      endpoint_node,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_CYAN);
+
+  uint8_t result = {};
+  attribute_store_read_value(node,
+                             value_state,
+                             (uint8_t *)&result,
+                             sizeof(result));
+  return result;
+}
+
+sl_status_t dotdot_set_unify_switch_color_cyan(
+  const dotdot_unid_t unid,
+  dotdot_endpoint_id_t endpoint_id,
+  attribute_store_node_value_state_t value_state,
+  uint8_t new_cyan
+  )
+{
+  attribute_store_node_t endpoint_node = unify_dotdot_attributes_get_endpoint_node()(unid, endpoint_id);
+
+  attribute_store_node_t node
+    = attribute_store_get_first_child_by_type(
+      endpoint_node,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_CYAN);
+
+  return attribute_store_set_node_attribute_value(node,
+                                                  value_state,
+                                                  (uint8_t *)&new_cyan,
+                                                  sizeof(uint8_t));
+  }
+
+sl_status_t dotdot_unify_switch_color_cyan_undefine_reported(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id) {
+  attribute_store_node_t endpoint_node = unify_dotdot_attributes_get_endpoint_node()(unid, endpoint_id);
+  attribute_store_node_t node
+    = attribute_store_get_first_child_by_type(
+      endpoint_node,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_CYAN);
+  attribute_store_undefine_reported(node);
+  return (node != ATTRIBUTE_STORE_INVALID_NODE) ? SL_STATUS_OK : SL_STATUS_FAIL;
+}
+
+sl_status_t dotdot_unify_switch_color_cyan_undefine_desired(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id) {
+
+  attribute_store_node_t endpoint_node = unify_dotdot_attributes_get_endpoint_node()(unid, endpoint_id);
+  attribute_store_node_t node
+    = attribute_store_get_first_child_by_type(
+      endpoint_node,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_CYAN);
+  attribute_store_undefine_desired(node);
+  return (node != ATTRIBUTE_STORE_INVALID_NODE) ? SL_STATUS_OK : SL_STATUS_FAIL;
+}
+
+
+bool dotdot_unify_switch_color_cyan_is_reported_defined(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id)
+{
+  attribute_store_node_t endpoint_node = unify_dotdot_attributes_get_endpoint_node()(unid, endpoint_id);
+  attribute_store_node_t node
+    = attribute_store_get_first_child_by_type(
+      endpoint_node,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_CYAN);
+  return attribute_store_is_reported_defined(node);
+}
+
+bool dotdot_unify_switch_color_cyan_is_desired_defined(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id)
+{
+  attribute_store_node_t endpoint_node = unify_dotdot_attributes_get_endpoint_node()(unid, endpoint_id);
+  attribute_store_node_t node
+    = attribute_store_get_first_child_by_type(
+      endpoint_node,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_CYAN);
+  return attribute_store_is_desired_defined(node);
+}
+
+sl_status_t dotdot_create_unify_switch_color_cyan(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id) {
+
+  attribute_store_node_t endpoint_node = unify_dotdot_attributes_get_endpoint_node()(unid, endpoint_id);
+  attribute_store_node_t node =
+    attribute_store_create_child_if_missing(endpoint_node,
+                                           DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_CYAN);
+
+  return (node != ATTRIBUTE_STORE_INVALID_NODE) ? SL_STATUS_OK : SL_STATUS_FAIL;
+}
+bool dotdot_is_supported_unify_switch_color_purple(
+  const dotdot_unid_t unid, const dotdot_endpoint_id_t endpoint_id)
+{
+  attribute_store_node_t endpoint_node = unify_dotdot_attributes_get_endpoint_node()(unid, endpoint_id);
+  attribute_store_node_t node
+    = attribute_store_get_first_child_by_type(
+      endpoint_node,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_PURPLE);
+  return attribute_store_node_exists(node);
+}
+
+uint8_t dotdot_get_unify_switch_color_purple(
+  const dotdot_unid_t unid,
+  dotdot_endpoint_id_t endpoint_id,
+  attribute_store_node_value_state_t value_state)
+{
+  attribute_store_node_t endpoint_node = unify_dotdot_attributes_get_endpoint_node()(unid, endpoint_id);
+  attribute_store_node_t node
+    = attribute_store_get_first_child_by_type(
+      endpoint_node,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_PURPLE);
+
+  uint8_t result = {};
+  attribute_store_read_value(node,
+                             value_state,
+                             (uint8_t *)&result,
+                             sizeof(result));
+  return result;
+}
+
+sl_status_t dotdot_set_unify_switch_color_purple(
+  const dotdot_unid_t unid,
+  dotdot_endpoint_id_t endpoint_id,
+  attribute_store_node_value_state_t value_state,
+  uint8_t new_purple
+  )
+{
+  attribute_store_node_t endpoint_node = unify_dotdot_attributes_get_endpoint_node()(unid, endpoint_id);
+
+  attribute_store_node_t node
+    = attribute_store_get_first_child_by_type(
+      endpoint_node,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_PURPLE);
+
+  return attribute_store_set_node_attribute_value(node,
+                                                  value_state,
+                                                  (uint8_t *)&new_purple,
+                                                  sizeof(uint8_t));
+  }
+
+sl_status_t dotdot_unify_switch_color_purple_undefine_reported(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id) {
+  attribute_store_node_t endpoint_node = unify_dotdot_attributes_get_endpoint_node()(unid, endpoint_id);
+  attribute_store_node_t node
+    = attribute_store_get_first_child_by_type(
+      endpoint_node,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_PURPLE);
+  attribute_store_undefine_reported(node);
+  return (node != ATTRIBUTE_STORE_INVALID_NODE) ? SL_STATUS_OK : SL_STATUS_FAIL;
+}
+
+sl_status_t dotdot_unify_switch_color_purple_undefine_desired(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id) {
+
+  attribute_store_node_t endpoint_node = unify_dotdot_attributes_get_endpoint_node()(unid, endpoint_id);
+  attribute_store_node_t node
+    = attribute_store_get_first_child_by_type(
+      endpoint_node,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_PURPLE);
+  attribute_store_undefine_desired(node);
+  return (node != ATTRIBUTE_STORE_INVALID_NODE) ? SL_STATUS_OK : SL_STATUS_FAIL;
+}
+
+
+bool dotdot_unify_switch_color_purple_is_reported_defined(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id)
+{
+  attribute_store_node_t endpoint_node = unify_dotdot_attributes_get_endpoint_node()(unid, endpoint_id);
+  attribute_store_node_t node
+    = attribute_store_get_first_child_by_type(
+      endpoint_node,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_PURPLE);
+  return attribute_store_is_reported_defined(node);
+}
+
+bool dotdot_unify_switch_color_purple_is_desired_defined(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id)
+{
+  attribute_store_node_t endpoint_node = unify_dotdot_attributes_get_endpoint_node()(unid, endpoint_id);
+  attribute_store_node_t node
+    = attribute_store_get_first_child_by_type(
+      endpoint_node,
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_PURPLE);
+  return attribute_store_is_desired_defined(node);
+}
+
+sl_status_t dotdot_create_unify_switch_color_purple(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id) {
+
+  attribute_store_node_t endpoint_node = unify_dotdot_attributes_get_endpoint_node()(unid, endpoint_id);
+  attribute_store_node_t node =
+    attribute_store_create_child_if_missing(endpoint_node,
+                                           DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_PURPLE);
+
+  return (node != ATTRIBUTE_STORE_INVALID_NODE) ? SL_STATUS_OK : SL_STATUS_FAIL;
+}
+
+bool dotdot_is_any_unify_switch_color_attribute_supported(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id) {
+
+  if (true == dotdot_is_supported_unify_switch_color_warm_white(unid, endpoint_id)) {
+    return true;
+  }
+  if (true == dotdot_is_supported_unify_switch_color_cold_white(unid, endpoint_id)) {
+    return true;
+  }
+  if (true == dotdot_is_supported_unify_switch_color_red(unid, endpoint_id)) {
+    return true;
+  }
+  if (true == dotdot_is_supported_unify_switch_color_green(unid, endpoint_id)) {
+    return true;
+  }
+  if (true == dotdot_is_supported_unify_switch_color_blue(unid, endpoint_id)) {
+    return true;
+  }
+  if (true == dotdot_is_supported_unify_switch_color_amber(unid, endpoint_id)) {
+    return true;
+  }
+  if (true == dotdot_is_supported_unify_switch_color_cyan(unid, endpoint_id)) {
+    return true;
+  }
+  if (true == dotdot_is_supported_unify_switch_color_purple(unid, endpoint_id)) {
+    return true;
+  }
+
+  return false;
+}
+
+bool dotdot_is_any_unify_switch_color_writable_attribute_supported(
+  const dotdot_unid_t unid,
+  const dotdot_endpoint_id_t endpoint_id) {
+
+
   return false;
 }
diff --git a/components/unify_dotdot_attribute_store/zap-generated/src/unify_dotdot_attribute_store_registration.cpp b/components/unify_dotdot_attribute_store/zap-generated/src/unify_dotdot_attribute_store_registration.cpp
index 329813ba1c..15a883ab8a 100644
--- a/components/unify_dotdot_attribute_store/zap-generated/src/unify_dotdot_attribute_store_registration.cpp
+++ b/components/unify_dotdot_attribute_store/zap-generated/src/unify_dotdot_attribute_store_registration.cpp
@@ -17647,6 +17647,198 @@ sl_status_t unify_dotdot_attribute_store_registration_init()
   // clang-format off
   // clang-format on
 
+  {
+    // uint8 // uint8 // uint8_t
+    std::string attribute_type_string           = "uint8_t";
+    attribute_store_storage_type_t storage_type = UNKNOWN_STORAGE_TYPE;
+
+    // clang-format off
+    storage_type = attribute_storage_type_conversion(attribute_type_string);
+
+    if (storage_type == UNKNOWN_STORAGE_TYPE) {
+      sl_log_warning(LOG_TAG,
+                     "Unkown storage type for ZCL UnifySwitchColor WarmWhite, "
+                     "type:  uint8 // uint8_t");
+    }
+
+    status |= attribute_store_register_type(
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_WARM_WHITE,
+      "ZCL UnifySwitchColor WarmWhite",
+      ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE,
+      storage_type);
+  }
+
+  // clang-format off
+  // clang-format on
+
+  {
+    // uint8 // uint8 // uint8_t
+    std::string attribute_type_string           = "uint8_t";
+    attribute_store_storage_type_t storage_type = UNKNOWN_STORAGE_TYPE;
+
+    // clang-format off
+    storage_type = attribute_storage_type_conversion(attribute_type_string);
+
+    if (storage_type == UNKNOWN_STORAGE_TYPE) {
+      sl_log_warning(LOG_TAG,
+                     "Unkown storage type for ZCL UnifySwitchColor ColdWhite, "
+                     "type:  uint8 // uint8_t");
+    }
+
+    status |= attribute_store_register_type(
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_COLD_WHITE,
+      "ZCL UnifySwitchColor ColdWhite",
+      ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE,
+      storage_type);
+  }
+
+  // clang-format off
+  // clang-format on
+
+  {
+    // uint8 // uint8 // uint8_t
+    std::string attribute_type_string           = "uint8_t";
+    attribute_store_storage_type_t storage_type = UNKNOWN_STORAGE_TYPE;
+
+    // clang-format off
+    storage_type = attribute_storage_type_conversion(attribute_type_string);
+
+    if (storage_type == UNKNOWN_STORAGE_TYPE) {
+      sl_log_warning(LOG_TAG,
+                     "Unkown storage type for ZCL UnifySwitchColor Red, "
+                     "type:  uint8 // uint8_t");
+    }
+
+    status |= attribute_store_register_type(
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_RED,
+      "ZCL UnifySwitchColor Red",
+      ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE,
+      storage_type);
+  }
+
+  // clang-format off
+  // clang-format on
+
+  {
+    // uint8 // uint8 // uint8_t
+    std::string attribute_type_string           = "uint8_t";
+    attribute_store_storage_type_t storage_type = UNKNOWN_STORAGE_TYPE;
+
+    // clang-format off
+    storage_type = attribute_storage_type_conversion(attribute_type_string);
+
+    if (storage_type == UNKNOWN_STORAGE_TYPE) {
+      sl_log_warning(LOG_TAG,
+                     "Unkown storage type for ZCL UnifySwitchColor Green, "
+                     "type:  uint8 // uint8_t");
+    }
+
+    status |= attribute_store_register_type(
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_GREEN,
+      "ZCL UnifySwitchColor Green",
+      ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE,
+      storage_type);
+  }
+
+  // clang-format off
+  // clang-format on
+
+  {
+    // uint8 // uint8 // uint8_t
+    std::string attribute_type_string           = "uint8_t";
+    attribute_store_storage_type_t storage_type = UNKNOWN_STORAGE_TYPE;
+
+    // clang-format off
+    storage_type = attribute_storage_type_conversion(attribute_type_string);
+
+    if (storage_type == UNKNOWN_STORAGE_TYPE) {
+      sl_log_warning(LOG_TAG,
+                     "Unkown storage type for ZCL UnifySwitchColor Blue, "
+                     "type:  uint8 // uint8_t");
+    }
+
+    status |= attribute_store_register_type(
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_BLUE,
+      "ZCL UnifySwitchColor Blue",
+      ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE,
+      storage_type);
+  }
+
+  // clang-format off
+  // clang-format on
+
+  {
+    // uint8 // uint8 // uint8_t
+    std::string attribute_type_string           = "uint8_t";
+    attribute_store_storage_type_t storage_type = UNKNOWN_STORAGE_TYPE;
+
+    // clang-format off
+    storage_type = attribute_storage_type_conversion(attribute_type_string);
+
+    if (storage_type == UNKNOWN_STORAGE_TYPE) {
+      sl_log_warning(LOG_TAG,
+                     "Unkown storage type for ZCL UnifySwitchColor Amber, "
+                     "type:  uint8 // uint8_t");
+    }
+
+    status |= attribute_store_register_type(
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_AMBER,
+      "ZCL UnifySwitchColor Amber",
+      ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE,
+      storage_type);
+  }
+
+  // clang-format off
+  // clang-format on
+
+  {
+    // uint8 // uint8 // uint8_t
+    std::string attribute_type_string           = "uint8_t";
+    attribute_store_storage_type_t storage_type = UNKNOWN_STORAGE_TYPE;
+
+    // clang-format off
+    storage_type = attribute_storage_type_conversion(attribute_type_string);
+
+    if (storage_type == UNKNOWN_STORAGE_TYPE) {
+      sl_log_warning(LOG_TAG,
+                     "Unkown storage type for ZCL UnifySwitchColor Cyan, "
+                     "type:  uint8 // uint8_t");
+    }
+
+    status |= attribute_store_register_type(
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_CYAN,
+      "ZCL UnifySwitchColor Cyan",
+      ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE,
+      storage_type);
+  }
+
+  // clang-format off
+  // clang-format on
+
+  {
+    // uint8 // uint8 // uint8_t
+    std::string attribute_type_string           = "uint8_t";
+    attribute_store_storage_type_t storage_type = UNKNOWN_STORAGE_TYPE;
+
+    // clang-format off
+    storage_type = attribute_storage_type_conversion(attribute_type_string);
+
+    if (storage_type == UNKNOWN_STORAGE_TYPE) {
+      sl_log_warning(LOG_TAG,
+                     "Unkown storage type for ZCL UnifySwitchColor Purple, "
+                     "type:  uint8 // uint8_t");
+    }
+
+    status |= attribute_store_register_type(
+      DOTDOT_ATTRIBUTE_ID_UNIFY_SWITCH_COLOR_PURPLE,
+      "ZCL UnifySwitchColor Purple",
+      ATTRIBUTE_STORE_INVALID_ATTRIBUTE_TYPE,
+      storage_type);
+  }
+
+  // clang-format off
+  // clang-format on
+
   // Additional attributes:
   for (auto const &a: zcl_additional_attribute_schema) {
     status |= attribute_store_register_type(a.type,
diff --git a/components/unify_dotdot_attribute_store/zap-generated/src/unify_dotdot_attribute_store_write_attributes_command_callbacks.c b/components/unify_dotdot_attribute_store/zap-generated/src/unify_dotdot_attribute_store_write_attributes_command_callbacks.c
index 7443995a7b..8e992503d3 100644
--- a/components/unify_dotdot_attribute_store/zap-generated/src/unify_dotdot_attribute_store_write_attributes_command_callbacks.c
+++ b/components/unify_dotdot_attribute_store/zap-generated/src/unify_dotdot_attribute_store_write_attributes_command_callbacks.c
@@ -2585,6 +2585,36 @@ static sl_status_t unify_humidity_control_cluster_write_attributes_callback(
                endpoint_id);
   return SL_STATUS_OK;
 }
+////////////////////////////////////////////////////////////////////////////////
+// Start of cluster UnifySwitchColor
+////////////////////////////////////////////////////////////////////////////////
+// WriteAttribute Callbacks unify_switch_color
+static sl_status_t unify_switch_color_cluster_write_attributes_callback(
+  const dotdot_unid_t unid,
+  dotdot_endpoint_id_t endpoint_id,
+  uic_mqtt_dotdot_callback_call_type_t call_type,
+  uic_mqtt_dotdot_unify_switch_color_state_t attributes,
+  uic_mqtt_dotdot_unify_switch_color_updated_state_t updated_attributes)
+{
+  if (false == is_write_attributes_enabled()) {
+    return SL_STATUS_FAIL;
+  }
+
+  if (call_type == UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK) {
+    if (is_automatic_deduction_of_supported_commands_enabled()) {
+      return dotdot_is_any_unify_switch_color_writable_attribute_supported(unid, endpoint_id) ?
+        SL_STATUS_OK : SL_STATUS_FAIL;
+    } else {
+      return SL_STATUS_FAIL;
+    }
+  }
+
+  sl_log_debug(LOG_TAG,
+               "unify_switch_color: Incoming WriteAttributes command for %s, endpoint %d.\n",
+               unid,
+               endpoint_id);
+  return SL_STATUS_OK;
+}
 // clang-format on
 
 ////////////////////////////////////////////////////////////////////////////////
@@ -2758,6 +2788,9 @@ sl_status_t
   uic_mqtt_dotdot_set_unify_humidity_control_write_attributes_callback(
     &unify_humidity_control_cluster_write_attributes_callback);
   
+  uic_mqtt_dotdot_set_unify_switch_color_write_attributes_callback(
+    &unify_switch_color_cluster_write_attributes_callback);
+  
   // clang-format on
 
   return SL_STATUS_OK;
diff --git a/components/unify_dotdot_attribute_store/zap-generated/test/unify_dotdot_attribute_store_test.c b/components/unify_dotdot_attribute_store/zap-generated/test/unify_dotdot_attribute_store_test.c
index 12f32c1833..40b1d826a4 100644
--- a/components/unify_dotdot_attribute_store/zap-generated/test/unify_dotdot_attribute_store_test.c
+++ b/components/unify_dotdot_attribute_store/zap-generated/test/unify_dotdot_attribute_store_test.c
@@ -1420,6 +1420,24 @@ static uic_mqtt_dotdot_unify_humidity_control_setpoint_set_callback_t test_uic_m
 uic_mqtt_dotdot_unify_humidity_control_setpoint_set_callback_t get_uic_mqtt_dotdot_unify_humidity_control_setpoint_set_callback(){
   return test_uic_mqtt_dotdot_unify_humidity_control_setpoint_set_callback;
 }
+static uic_mqtt_dotdot_unify_switch_color_force_read_attributes_callback_t test_uic_mqtt_dotdot_unify_switch_color_force_read_attributes_callback = NULL;
+static uic_mqtt_dotdot_unify_switch_color_write_attributes_callback_t test_uic_mqtt_dotdot_unify_switch_color_write_attributes_callback = NULL;
+
+uic_mqtt_dotdot_unify_switch_color_force_read_attributes_callback_t get_uic_mqtt_dotdot_unify_switch_color_force_read_attributes_callback(){
+  return test_uic_mqtt_dotdot_unify_switch_color_force_read_attributes_callback;
+}
+uic_mqtt_dotdot_unify_switch_color_write_attributes_callback_t get_uic_mqtt_dotdot_unify_switch_color_write_attributes_callback(){
+  return test_uic_mqtt_dotdot_unify_switch_color_write_attributes_callback;
+}
+
+static uic_mqtt_dotdot_unify_switch_color_set_color_callback_t test_uic_mqtt_dotdot_unify_switch_color_set_color_callback = NULL;
+uic_mqtt_dotdot_unify_switch_color_set_color_callback_t get_uic_mqtt_dotdot_unify_switch_color_set_color_callback(){
+  return test_uic_mqtt_dotdot_unify_switch_color_set_color_callback;
+}
+static uic_mqtt_dotdot_unify_switch_color_start_stop_change_callback_t test_uic_mqtt_dotdot_unify_switch_color_start_stop_change_callback = NULL;
+uic_mqtt_dotdot_unify_switch_color_start_stop_change_callback_t get_uic_mqtt_dotdot_unify_switch_color_start_stop_change_callback(){
+  return test_uic_mqtt_dotdot_unify_switch_color_start_stop_change_callback;
+}
 // clang-format on
 
 #define TEST_UNID "test-unid-123"
@@ -3131,6 +3149,26 @@ void uic_mqtt_dotdot_unify_humidity_control_setpoint_set_callback_set_stub(
 {
   test_uic_mqtt_dotdot_unify_humidity_control_setpoint_set_callback = callback;
 }
+void set_uic_mqtt_dotdot_unify_switch_color_force_read_attributes_callback_stub(
+  const uic_mqtt_dotdot_unify_switch_color_force_read_attributes_callback_t callback, int cmock_num_calls)
+{
+  test_uic_mqtt_dotdot_unify_switch_color_force_read_attributes_callback = callback;
+}
+void set_uic_mqtt_dotdot_unify_switch_color_write_attributes_callback_stub(
+  const uic_mqtt_dotdot_unify_switch_color_write_attributes_callback_t callback, int cmock_num_calls)
+{
+  test_uic_mqtt_dotdot_unify_switch_color_write_attributes_callback = callback;
+}
+void uic_mqtt_dotdot_unify_switch_color_set_color_callback_set_stub(
+  const uic_mqtt_dotdot_unify_switch_color_set_color_callback_t callback, int cmock_num_calls)
+{
+  test_uic_mqtt_dotdot_unify_switch_color_set_color_callback = callback;
+}
+void uic_mqtt_dotdot_unify_switch_color_start_stop_change_callback_set_stub(
+  const uic_mqtt_dotdot_unify_switch_color_start_stop_change_callback_t callback, int cmock_num_calls)
+{
+  test_uic_mqtt_dotdot_unify_switch_color_start_stop_change_callback = callback;
+}
 // clang-format on
 
 // Test functions
@@ -4129,6 +4167,18 @@ void setUp()
   test_uic_mqtt_dotdot_unify_humidity_control_setpoint_set_callback = NULL;
   uic_mqtt_dotdot_unify_humidity_control_setpoint_set_callback_set_Stub(
     &uic_mqtt_dotdot_unify_humidity_control_setpoint_set_callback_set_stub);
+  test_uic_mqtt_dotdot_unify_switch_color_force_read_attributes_callback = NULL;
+  uic_mqtt_dotdot_set_unify_switch_color_force_read_attributes_callback_Stub(
+    &set_uic_mqtt_dotdot_unify_switch_color_force_read_attributes_callback_stub);
+  test_uic_mqtt_dotdot_unify_switch_color_write_attributes_callback = NULL;
+  uic_mqtt_dotdot_set_unify_switch_color_write_attributes_callback_Stub(
+    &set_uic_mqtt_dotdot_unify_switch_color_write_attributes_callback_stub);
+  test_uic_mqtt_dotdot_unify_switch_color_set_color_callback = NULL;
+  uic_mqtt_dotdot_unify_switch_color_set_color_callback_set_Stub(
+    &uic_mqtt_dotdot_unify_switch_color_set_color_callback_set_stub);
+  test_uic_mqtt_dotdot_unify_switch_color_start_stop_change_callback = NULL;
+  uic_mqtt_dotdot_unify_switch_color_start_stop_change_callback_set_Stub(
+    &uic_mqtt_dotdot_unify_switch_color_start_stop_change_callback_set_stub);
   // clang-format on
 
   group_command_dispatch = NULL;
@@ -4905,6 +4955,14 @@ void test_automatic_deduction_of_supported_commands()
   TEST_ASSERT_EQUAL(SL_STATUS_OK, dotdot_create_unify_humidity_control_auto_setpoint(expected_unid,expected_endpoint_id) );
   TEST_ASSERT_EQUAL(SL_STATUS_OK, dotdot_create_unify_humidity_control_auto_setpoint_scale(expected_unid,expected_endpoint_id) );
   TEST_ASSERT_EQUAL(SL_STATUS_OK, dotdot_create_unify_humidity_control_auto_setpoint_precision(expected_unid,expected_endpoint_id) );
+  TEST_ASSERT_EQUAL(SL_STATUS_OK, dotdot_create_unify_switch_color_warm_white(expected_unid,expected_endpoint_id) );
+  TEST_ASSERT_EQUAL(SL_STATUS_OK, dotdot_create_unify_switch_color_cold_white(expected_unid,expected_endpoint_id) );
+  TEST_ASSERT_EQUAL(SL_STATUS_OK, dotdot_create_unify_switch_color_red(expected_unid,expected_endpoint_id) );
+  TEST_ASSERT_EQUAL(SL_STATUS_OK, dotdot_create_unify_switch_color_green(expected_unid,expected_endpoint_id) );
+  TEST_ASSERT_EQUAL(SL_STATUS_OK, dotdot_create_unify_switch_color_blue(expected_unid,expected_endpoint_id) );
+  TEST_ASSERT_EQUAL(SL_STATUS_OK, dotdot_create_unify_switch_color_amber(expected_unid,expected_endpoint_id) );
+  TEST_ASSERT_EQUAL(SL_STATUS_OK, dotdot_create_unify_switch_color_cyan(expected_unid,expected_endpoint_id) );
+  TEST_ASSERT_EQUAL(SL_STATUS_OK, dotdot_create_unify_switch_color_purple(expected_unid,expected_endpoint_id) );
 
   // clang-format on
   // ColorControl checks the value in the bitmask:
@@ -8352,6 +8410,56 @@ void test_automatic_deduction_of_supported_commands()
       
       ));
   }
+  if (NULL != test_uic_mqtt_dotdot_unify_switch_color_set_color_callback) {
+    // Dummy command parameters
+      uint8_t color_component_id_value;
+      memset(&color_component_id_value, 0x00, sizeof(color_component_id_value));
+      uint8_t value_value;
+      memset(&value_value, 0x00, sizeof(value_value));
+      uint32_t duration_value;
+      memset(&duration_value, 0x00, sizeof(duration_value));
+  // Invoke with support check
+    TEST_ASSERT_EQUAL(SL_STATUS_FAIL, test_uic_mqtt_dotdot_unify_switch_color_set_color_callback(expected_unid,expected_endpoint_id,UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
+      ,
+        color_component_id_value,
+      
+        value_value,
+      
+        duration_value
+      
+      ));
+  }
+  if (NULL != test_uic_mqtt_dotdot_unify_switch_color_start_stop_change_callback) {
+    // Dummy command parameters
+      bool start_stop_value;
+      memset(&start_stop_value, 0x00, sizeof(start_stop_value));
+      bool up_down_value;
+      memset(&up_down_value, 0x00, sizeof(up_down_value));
+      bool ignor_start_level_value;
+      memset(&ignor_start_level_value, 0x00, sizeof(ignor_start_level_value));
+      uint8_t color_component_id_value;
+      memset(&color_component_id_value, 0x00, sizeof(color_component_id_value));
+      uint8_t start_level_value;
+      memset(&start_level_value, 0x00, sizeof(start_level_value));
+      uint32_t duration_value;
+      memset(&duration_value, 0x00, sizeof(duration_value));
+  // Invoke with support check
+    TEST_ASSERT_EQUAL(SL_STATUS_FAIL, test_uic_mqtt_dotdot_unify_switch_color_start_stop_change_callback(expected_unid,expected_endpoint_id,UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
+      ,
+        start_stop_value,
+      
+        up_down_value,
+      
+        ignor_start_level_value,
+      
+        color_component_id_value,
+      
+        start_level_value,
+      
+        duration_value
+      
+      ));
+  }
 
   // Invoke all commands with support check, they should return SL_STATUS_OK
   // because all ZCL attributes are supported
@@ -11791,5 +11899,55 @@ void test_automatic_deduction_of_supported_commands()
       
       ));
   }
+  if (NULL != test_uic_mqtt_dotdot_unify_switch_color_set_color_callback) {
+    // Dummy command parameters
+      uint8_t color_component_id_value;
+      memset(&color_component_id_value, 0x00, sizeof(color_component_id_value));
+      uint8_t value_value;
+      memset(&value_value, 0x00, sizeof(value_value));
+      uint32_t duration_value;
+      memset(&duration_value, 0x00, sizeof(duration_value));
+  // Invoke with support check
+    TEST_ASSERT_EQUAL(SL_STATUS_OK, test_uic_mqtt_dotdot_unify_switch_color_set_color_callback(expected_unid,expected_endpoint_id,UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
+      ,
+        color_component_id_value,
+      
+        value_value,
+      
+        duration_value
+      
+      ));
+  }
+  if (NULL != test_uic_mqtt_dotdot_unify_switch_color_start_stop_change_callback) {
+    // Dummy command parameters
+      bool start_stop_value;
+      memset(&start_stop_value, 0x00, sizeof(start_stop_value));
+      bool up_down_value;
+      memset(&up_down_value, 0x00, sizeof(up_down_value));
+      bool ignor_start_level_value;
+      memset(&ignor_start_level_value, 0x00, sizeof(ignor_start_level_value));
+      uint8_t color_component_id_value;
+      memset(&color_component_id_value, 0x00, sizeof(color_component_id_value));
+      uint8_t start_level_value;
+      memset(&start_level_value, 0x00, sizeof(start_level_value));
+      uint32_t duration_value;
+      memset(&duration_value, 0x00, sizeof(duration_value));
+  // Invoke with support check
+    TEST_ASSERT_EQUAL(SL_STATUS_OK, test_uic_mqtt_dotdot_unify_switch_color_start_stop_change_callback(expected_unid,expected_endpoint_id,UIC_MQTT_DOTDOT_CALLBACK_TYPE_SUPPORT_CHECK
+      ,
+        start_stop_value,
+      
+        up_down_value,
+      
+        ignor_start_level_value,
+      
+        color_component_id_value,
+      
+        start_level_value,
+      
+        duration_value
+      
+      ));
+  }
 
 }
diff --git a/components/unify_dotdot_attribute_store/zap-generated/test/unify_dotdot_attribute_store_test.h b/components/unify_dotdot_attribute_store/zap-generated/test/unify_dotdot_attribute_store_test.h
index d5c2ed0913..7e291a589c 100644
--- a/components/unify_dotdot_attribute_store/zap-generated/test/unify_dotdot_attribute_store_test.h
+++ b/components/unify_dotdot_attribute_store/zap-generated/test/unify_dotdot_attribute_store_test.h
@@ -867,4 +867,14 @@
 
   uic_mqtt_dotdot_unify_humidity_control_setpoint_set_callback_t get_uic_mqtt_dotdot_unify_humidity_control_setpoint_set_callback();
 
+
+  uic_mqtt_dotdot_unify_switch_color_force_read_attributes_callback_t get_uic_mqtt_dotdot_unify_switch_color_force_read_attributes_callback();
+  uic_mqtt_dotdot_unify_switch_color_write_attributes_callback_t get_uic_mqtt_dotdot_unify_switch_color_write_attributes_callback();
+
+
+  uic_mqtt_dotdot_unify_switch_color_set_color_callback_t get_uic_mqtt_dotdot_unify_switch_color_set_color_callback();
+
+
+  uic_mqtt_dotdot_unify_switch_color_start_stop_change_callback_t get_uic_mqtt_dotdot_unify_switch_color_start_stop_change_callback();
+
 #endif // UNIFY_DOTDOT_ATTRIBUTE_STORE_TEST_H
\ No newline at end of file
-- 
2.39.5

